<!DOCTYPE html>
<html lang="zh-CN">
  <head><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<link rel="alternate" href="/default" title="simpleapples" ><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.11.0" />
<link rel="canonical" href="http://www.simpleapples.com/page/2/"/>

<link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css" />
<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.11.0" />

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-116134610-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-116134610-1');
</script><script id="baidu_push">
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
<script>
  window.config = {"leancloud":{"app_id":null,"app_key":null},"toc":true,"fancybox":true,"pjax":"","latex":false};
</script>

    <title>simpleapples</title>
  <meta name="generator" content="Hexo 5.4.0"></head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">simpleapples</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list"><a href="/">
        <li class="mobile-menu-item">首页
          </li>
      </a><a href="/archives/">
        <li class="mobile-menu-item">归档
          </li>
      </a><a href="/about/">
        <li class="mobile-menu-item">关于
          </li>
      </a></ul>
</nav>
<div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">simpleapples</a>
</div>

<nav class="site-navbar"><ul id="menu" class="menu"><li class="menu-item">
          <a class="menu-item-link" href="/">
            首页
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            归档
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/about/">
            关于
            </a>
        </li>
      </ul></nav>
</header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content"><section id="posts" class="posts"><article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2018/10/25/faster-python-part-2/">翻译 | 更快的Python（二）</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-10-25
        </span><span class="post-category">
            <a href="/categories/Python/">Python</a>
            </span>
        </div>
    </header>

    <div class="post-content"><p><img src="/upload/20181025_11.png"></p>
<p>更快的Python（<a target="_blank" rel="noopener" href="http://pythonfasterway.org/">Python Faster Way</a>）使用代码示例来说明如何书写Python代码能带来更高的性能。本文对代码进行了讲解，从性能和可读性等角度来选择出最适合的写法。</p>
          <div class="read-more">
            <a href="/2018/10/25/faster-python-part-2/" class="read-more-link">阅读更多</a>
          </div>
        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2018/10/11/stacks-in-go/">Go的栈空间管理</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-10-11
        </span><span class="post-category">
            <a href="/categories/Golang/">Golang</a>
            </span>
        </div>
    </header>

    <div class="post-content"><p><img src="/upload/20181011_01.jpg"></p>
<h3 id="栈空间管理的基本逻辑"><a href="#栈空间管理的基本逻辑" class="headerlink" title="栈空间管理的基本逻辑"></a>栈空间管理的基本逻辑</h3><p>go语言通过goroutine提供了并发编程支持，goroutine是go运行库的功能，而不是操作系统线程实现的，goroutine可以被理解成一个用户态的线程。</p>
<p>既然goroutine是由go运行库管理的，那么go运行库也需要为每个goroutine创建并管理相应的栈空间，为每个goroutine分配的栈空间不能太大，goroutine开多时会浪费大量空间，也不能太小，会导致栈溢出。go语言选择栈的栈空间管理的方式是，一开始给一个比较小的空间，随着需要自动增长。当goroutine不需要那么大的空间时，栈空间也要自动缩小。</p>
<h3 id="分段栈-Segment-Stacks"><a href="#分段栈-Segment-Stacks" class="headerlink" title="分段栈 Segment Stacks"></a>分段栈 Segment Stacks</h3><p>在go 1.3之前，go使用分段栈。</p>
<p>分段栈实现了一种不连续但是可以持续增长的栈，开始时，栈只有一个段，当需要更多的栈空间时，会分配一个新的段，和上一个栈双向链接。这样，一个栈就是由多个双向链接的段所组成的。当新分配的段使用完毕后，新段会被释放掉。</p>
<p><img src="/upload/20181011_02.png"></p>
<p>分段栈实现了栈的按需收缩，在增加新分段时也不需要对原有分段中的数据进行拷贝，使得goroutine的使用代价非常低廉。</p>
<p>分段栈的好处是可以按需增长，空间利用率比较高，然而分段栈在某些情况下也存在一定的瑕疵。当一个段即将用尽，这时使用for循环执行一个比较耗空间的函数，会导致函数执行时goroutine进行段的分配，而执行完成返回时，进行段的销毁，这样就会导致在循环中出现多次栈的扩容和收缩，造成很大的性能损失，这种情况被称作栈分裂（Stack Split）。</p>
<h3 id="连续栈-Contiguous-Stacks"><a href="#连续栈-Contiguous-Stacks" class="headerlink" title="连续栈 Contiguous Stacks"></a>连续栈 Contiguous Stacks</h3><p>go 1.3推出了连续栈，连续栈使用了另外一种策略，不再把栈分成一段一段的，当栈空间不够时，直接new一个2倍大的栈空间，并将原先栈空间中的数据拷贝到新的栈空间中，而后销毁旧栈。这样当出现栈空间触及边界时，不会产生栈分裂的情况。</p>
<p>继续假设当前栈空间即将用尽，并且需要在for循环中执行一个比较消耗空间的函数。当该函数执行时，栈空间发生了扩容，变成原先2倍大小，函数执行完成一次后，栈空间的使用量缩小回执行前的大小，但是栈空间的使用量并没有小于栈大小的1/4，不会触发栈收缩，所以在整个for循环执行过程中，不会反复触发栈空间的收缩扩容。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>相比于分段栈，连续栈避免了某些场景下栈空间的的频繁伸缩。有一点需要注意的是，连续栈的收缩也是需要重新申请一段空间（原先的1/2大小），并进行栈拷贝操作的。</p>

        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2018/10/08/faster-python-part-1/">翻译 | 更快的Python（一）</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-10-08
        </span><span class="post-category">
            <a href="/categories/Python/">Python</a>
            </span>
        </div>
    </header>

    <div class="post-content"><p><img src="/upload/20181008_11.png"></p>
<p>更快的Python（<a target="_blank" rel="noopener" href="http://pythonfasterway.org/">Python Faster Way</a>）使用代码示例来说明如何书写Python代码能带来更高的性能。本文对代码进行了讲解，从性能和可读性等角度来选择出最适合的写法。</p>
<h3 id="例子1：字符串格式化"><a href="#例子1：字符串格式化" class="headerlink" title="例子1：字符串格式化"></a>例子1：字符串格式化</h3><p><img src="/upload/20181008_01.png"></p>
<ul>
<li>最差/最优时间比：<strong>1.95</strong></li>
<li>使用建议：Python 3.7或以上推荐使用f-string，其他版本推荐使用format方法。</li>
<li>说明：字符串格式化是代码中最常遇到的情况，虽然在连接少量字符串的情景中，使用+号的性能最优，但是使用+号的代码可读性最差。如果使用Python 3.7或优以上版本，可以使用f-string来解决这个问题，f-string的性能比format方法和%操作符的性能都要高，可读性也比+号好。</li>
</ul>
<h3 id="例子2：字典的初始化"><a href="#例子2：字典的初始化" class="headerlink" title="例子2：字典的初始化"></a>例子2：字典的初始化</h3><p><img src="/upload/20181008_02.png"></p>
<ul>
<li>最差/最优时间比：<strong>1.83</strong></li>
<li>使用建议：使用字面量初始化字典（以及其他集合类型）。</li>
<li>说明：Python中初始化集合类型时使用字面量的方式，解释器会直接调用BUILD_MAP等字节码来创建，如果用构造函数的方式来创建，则需要先查询构造方法，再执行构造方法。使用字面量初始化，Python代码也更简洁。</li>
</ul>
<h3 id="例子3：内置排序方法"><a href="#例子3：内置排序方法" class="headerlink" title="例子3：内置排序方法"></a>例子3：内置排序方法</h3><p><img src="/upload/20181008_03.png"></p>
<ul>
<li>最差/最优时间比：<strong>1.26</strong></li>
<li>使用建议：根据是否需要修改原始值来决定使用哪个方法。</li>
<li>说明：sorted和list.sort方法是Python中内置的排序方法，sorted方法不会修改原始值，list.sort方法在原始值上直接排序，会修改原始值。比较这两个方法的性能差异，意义不大。</li>
</ul>
<h3 id="例子4：初始化多个变量"><a href="#例子4：初始化多个变量" class="headerlink" title="例子4：初始化多个变量"></a>例子4：初始化多个变量</h3><p><img src="/upload/20181008_04.png"></p>
<ul>
<li>最差/最优时间比：<strong>1.01</strong></li>
<li>使用建议：推荐使用第二种。</li>
<li>说明：从字节码中可以看出两种方式出了执行顺序之外，基本一致，所以性能上也非常接近。</li>
</ul>
<h3 id="例子5：多个变量的比较"><a href="#例子5：多个变量的比较" class="headerlink" title="例子5：多个变量的比较"></a>例子5：多个变量的比较</h3><p><img src="/upload/20181008_05.png"></p>
<ul>
<li>最差/最优时间比：<strong>1.11</strong></li>
<li>使用建议：推荐使用第二种。</li>
<li>说明：使用第一种方法能带来一定的性能提升，但是提升有限，在实际情况中也很少出现多个变量连续比较大小的情况，并且第一种方法非常不Pythonic，所以推荐使用第二种。</li>
</ul>
<h3 id="例子6：if-true的条件判断"><a href="#例子6：if-true的条件判断" class="headerlink" title="例子6：if true的条件判断"></a>例子6：if true的条件判断</h3><p><img src="/upload/20181008_06.png"></p>
<ul>
<li>最差/最优时间比：<strong>1.17</strong></li>
<li>使用建议：推荐使用第一种。</li>
<li>说明：从字节码上看，第一种方法的性能最高，并且语法上也更加简洁。</li>
</ul>
<h3 id="例子7：if-false的条件判断"><a href="#例子7：if-false的条件判断" class="headerlink" title="例子7：if false的条件判断"></a>例子7：if false的条件判断</h3><p><img src="/upload/20181008_07.png"></p>
<ul>
<li>最差/最优时间比：<strong>1.10</strong></li>
<li>使用建议：推荐使用第一种。</li>
<li>说明：从字节码上看，第一种方法的性能最高，语法角度上，if not写成第二种和第三种都是不推荐的。</li>
</ul>
<h3 id="例子8：判断list是否为空"><a href="#例子8：判断list是否为空" class="headerlink" title="例子8：判断list是否为空"></a>例子8：判断list是否为空</h3><p><img src="/upload/20181008_08.png"></p>
<ul>
<li>最差/最优时间比：<strong>1.55</strong></li>
<li>使用建议：根据具体需求，优先使用前两种。</li>
<li>说明：前两种代码性能更高，代码更简洁。同时，空列表a并不等于None，所以使用if a is None无法实现对空列表的判断。</li>
</ul>
<h3 id="例子9：判断object是否为空"><a href="#例子9：判断object是否为空" class="headerlink" title="例子9：判断object是否为空"></a>例子9：判断object是否为空</h3><p><img src="/upload/20181008_09.png"></p>
<ul>
<li>最差/最优时间比：<strong>1.00</strong></li>
<li>使用建议：根据具体需求，优先使用前两种。</li>
<li>说明：理由同上一个例子。</li>
</ul>
<h3 id="例子10：遍历可迭代对象"><a href="#例子10：遍历可迭代对象" class="headerlink" title="例子10：遍历可迭代对象"></a>例子10：遍历可迭代对象</h3><p><img src="/upload/20181008_10.png"></p>
<ul>
<li>最差/最优时间比：<strong>1.12</strong></li>
<li>使用建议：根据具体情况选择。</li>
<li>说明：两者性能差别不大，使用enumerate方法，可以不需要取对象的长度，可以直接获取到对象的index。</li>
</ul>
<h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><ul>
<li><a target="_blank" rel="noopener" href="http://pythonfasterway.org/">Python Faster Way</a></li>
</ul>

        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2018/09/14/how-to-use-defer-in-go/">Go语言中defer的一些坑</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-09-14
        </span><span class="post-category">
            <a href="/categories/Golang/">Golang</a>
            </span>
        </div>
    </header>

    <div class="post-content"><p><img src="/upload/20180914_01.png"></p>
<p>defer语句是Go中一个非常有用的特性，可以将一个方法延迟到包裹该方法的方法返回时执行，在实际应用中，defer语句可以充当其他语言中try…catch…的角色，也可以用来处理关闭文件句柄等收尾操作。</p>
<h3 id="defer触发时机"><a href="#defer触发时机" class="headerlink" title="defer触发时机"></a>defer触发时机</h3><blockquote>
<p>A “defer” statement invokes a function whose execution is deferred to the moment the surrounding function returns, either because the surrounding function executed a return statement, reached the end of its function body, or because the corresponding goroutine is panicking.</p>
</blockquote>
<p>Go官方文档中对defer的执行时机做了阐述，分别是。</p>
<ul>
<li>包裹defer的函数返回时</li>
<li>包裹defer的函数执行到末尾时</li>
<li>所在的goroutine发生panic时</li>
</ul>
<h3 id="defer执行顺序"><a href="#defer执行顺序" class="headerlink" title="defer执行顺序"></a>defer执行顺序</h3><p>当一个方法中有多个defer时， defer会将要延迟执行的方法“压栈”，当defer被触发时，将所有“压栈”的方法“出栈”并执行。所以defer的执行顺序是LIFO的。</p>
<p>所以下面这段代码的输出不是1 2 3，而是3 2 1。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">stackingDefers</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;3&quot;</span>)</span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="坑1：defer在匿名返回值和命名返回值函数中的不同表现"><a href="#坑1：defer在匿名返回值和命名返回值函数中的不同表现" class="headerlink" title="坑1：defer在匿名返回值和命名返回值函数中的不同表现"></a>坑1：defer在匿名返回值和命名返回值函数中的不同表现</h3><p>先看下面两个方法执行的结果。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">returnValues</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> result <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        result++</span><br><span class="line">        fmt.Println(<span class="string">&quot;defer&quot;</span>)</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">namedReturnValues</span><span class="params">()</span> <span class="params">(result <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        result++</span><br><span class="line">        fmt.Println(<span class="string">&quot;defer&quot;</span>)</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的方法会输出0，下面的方法输出1。上面的方法使用了匿名返回值，下面的使用了命名返回值，除此之外其他的逻辑均相同，为什么输出的结果会有区别呢？</p>
<p>要搞清这个问题首先需要了解defer的执行逻辑，文档中说defer语句在方法返回“时”触发，也就是说return和defer是“同时”执行的。以匿名返回值方法举例，过程如下。</p>
<ul>
<li>将result赋值给返回值（可以理解成Go自动创建了一个返回值retValue，相当于执行retValue = result）</li>
<li>然后检查是否有defer，如果有则执行</li>
<li>返回刚才创建的返回值（retValue）</li>
</ul>
<p>在这种情况下，defer中的修改是对result执行的，而不是retValue，所以defer返回的依然是retValue。在命名返回值方法中，由于返回值在方法定义时已经被定义，所以没有创建retValue的过程，result就是retValue，defer对于result的修改也会被直接返回。</p>
<h3 id="坑2：在for循环中使用defer可能导致的性能问题"><a href="#坑2：在for循环中使用defer可能导致的性能问题" class="headerlink" title="坑2：在for循环中使用defer可能导致的性能问题"></a>坑2：在for循环中使用defer可能导致的性能问题</h3><p>看下面的代码</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deferInLoops</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">        f, _ := os.Open(<span class="string">&quot;/etc/hosts&quot;</span>)</span><br><span class="line">        <span class="keyword">defer</span> f.Close()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>defer在紧邻创建资源的语句后生命力，看上去逻辑没有什么问题。但是和直接调用相比，defer的执行存在着额外的开销，例如defer会对其后需要的参数进行内存拷贝，还需要对defer结构进行压栈出栈操作。所以在循环中定义defer可能导致大量的资源开销，在本例中，可以将f.Close()语句前的defer去掉，来减少大量defer导致的额外资源消耗。</p>
<h3 id="坑3：判断执行没有err之后，再defer释放资源"><a href="#坑3：判断执行没有err之后，再defer释放资源" class="headerlink" title="坑3：判断执行没有err之后，再defer释放资源"></a>坑3：判断执行没有err之后，再defer释放资源</h3><p>一些获取资源的操作可能会返回err参数，我们可以选择忽略返回的err参数，但是如果要使用defer进行延迟释放的的话，需要在使用defer之前先判断是否存在err，如果资源没有获取成功，即没有必要也不应该再对资源执行释放操作。如果不判断获取资源是否成功就执行释放操作的话，还有可能导致释放方法执行错误。</p>
<p>正确写法如下。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">resp, err := http.Get(url)</span><br><span class="line"><span class="comment">// 先判断操作是否成功</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果操作成功，再进行Close操作</span></span><br><span class="line"><span class="keyword">defer</span> resp.Body.Close()</span><br></pre></td></tr></table></figure>

<h3 id="坑4：调用os-Exit时defer不会被执行"><a href="#坑4：调用os-Exit时defer不会被执行" class="headerlink" title="坑4：调用os.Exit时defer不会被执行"></a>坑4：调用os.Exit时defer不会被执行</h3><p>当发生panic时，所在goroutine的所有defer会被执行，但是当调用os.Exit()方法退出程序时，defer并不会被执行。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deferExit</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;defer&quot;</span>)</span><br><span class="line">    &#125;()</span><br><span class="line">    os.Exit(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的defer并不会输出。</p>

        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2018/08/05/implementation-of-reservoir-sample-in-python/">用Python写算法 | 蓄水池算法实现随机抽样</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-08-05
        </span><span class="post-category">
            <a href="/categories/Python/">Python</a>
            </span>
        </div>
    </header>

    <div class="post-content"><p><img src="/upload/20180805_01.jpg"></p>
<blockquote>
<p>现在有一组数，不知道这组数的总量有多少，请描述一种算法能够在这组数据中随机抽取k个数，使得每个数被取出来的概率相等。</p>
</blockquote>
<p>如果这组数有n个，那么每个数字取到的概率就是k/n，但是这个问题的难点在于不知道这组数的总数，也就是不知道n，那么该怎么计算每个数取到的概率呢？</p>
<h1 id="蓄水池算法"><a href="#蓄水池算法" class="headerlink" title="蓄水池算法"></a>蓄水池算法</h1><p>游泳池（蓄水池）大家都不陌生，有些游泳池中的水是活的，有入水管也有出水管，那么和泳池体积相当的水流过之后，是不是泳池中所有的水都会被替换呢？当然不是，有的水在泳池中可能会存留很久，有的可能刚进去就流走了。仿照这种现象，蓄水池抽样算法诞生了，蓄水池算法的关键在于保证流入蓄水池的水和已经在池中的水以相同的概率留存在蓄水池中。并且蓄水池算法可以在不预先知道总量的情况下，在时间复杂度O(N)的情况下，来解决这类采样问题。</p>
<h1 id="核心原理"><a href="#核心原理" class="headerlink" title="核心原理"></a>核心原理</h1><p>这一部分涉及公式，为了保证效果直接贴了图过来。</p>
<p><img src="/upload/20180805_02.jpg"></p>
<h1 id="Python实现"><a href="#Python实现" class="headerlink" title="Python实现"></a>Python实现</h1><p>接下来尝试用Python实现一下蓄水池算法，由于蓄水池算法是在事先不知道总量的情况下抽样的，所以定义一个方法来接收单个元素，并且把这个方法放在类中，以持有采样后的数据。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReservoirSample</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, size</span>):</span></span><br><span class="line">        self._size = size</span><br><span class="line">        self._counter = <span class="number">0</span></span><br><span class="line">        self._sample = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">feed</span>(<span class="params">self, item</span>):</span></span><br><span class="line">        self._counter += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 第i个元素（i &lt;= k），直接进入池中</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self._sample) &lt; self._size:</span><br><span class="line">            self._sample.append(item)</span><br><span class="line">            <span class="keyword">return</span> self._sample</span><br><span class="line">        <span class="comment"># 第i个元素（i &gt; k），以k / i的概率进入池中</span></span><br><span class="line">        rand_int = random.randint(<span class="number">1</span>, self._counter)</span><br><span class="line">        <span class="keyword">if</span> rand_int &lt;= self._size:</span><br><span class="line">            self._sample[rand_int - <span class="number">1</span>] = item</span><br><span class="line">        <span class="keyword">return</span> self._sample</span><br></pre></td></tr></table></figure>

<h1 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h1><p>接下来实现一个测试用例验证实现的算法是否正确，既然是随机抽样，无法通过单词测试来验证是否正确，所以通过多次执行的方式来验证，比如从1-10里随机取样3个数，然后执行10000次取样，如果算法正确，最后结果中1-10被取样的次数应该是相同的，都是3000上下。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> unittest</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> reservoir_sample <span class="keyword">import</span> ReservoirSample</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestMain</span>(<span class="params">unittest.TestCase</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_reservoir_sample</span>(<span class="params">self</span>):</span></span><br><span class="line">        samples = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10000</span>):</span><br><span class="line">            sample = []</span><br><span class="line">            rs = ReservoirSample(<span class="number">3</span>)</span><br><span class="line">            <span class="keyword">for</span> item <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">11</span>):</span><br><span class="line">                sample = rs.feed(item)</span><br><span class="line">            samples.extend(sample)</span><br><span class="line">        r = Counter(samples)</span><br><span class="line">        <span class="built_in">print</span>(r)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    unittest.main()</span><br></pre></td></tr></table></figure>

<p>输出的结果如下</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Counter</span>(&#123;<span class="number">7</span>: <span class="number">3084</span>, <span class="number">6</span>: <span class="number">3042</span>, <span class="number">10</span>: <span class="number">3033</span>, <span class="number">3</span>: <span class="number">3020</span>, <span class="number">8</span>: <span class="number">3016</span>, <span class="number">5</span>: <span class="number">2997</span>, <span class="number">4</span>: <span class="number">2986</span>, <span class="number">2</span>: <span class="number">2972</span>, <span class="number">9</span>: <span class="number">2932</span>, <span class="number">1</span>: <span class="number">2918</span>&#125;)</span><br></pre></td></tr></table></figure>

<p>上面输出了每个数字被取样到的次数，通过图表可以清晰的看到分布情况</p>
<p><img src="/upload/20180805_03.png"></p>
<p>可以看出蓄水池算法对于随机抽样还是非常适合的，每个元素的抽样概率都相同。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>上述的算法和测试代码已经放在<a target="_blank" rel="noopener" href="https://github.com/python-fan/reservoir-sample">Github</a>，可以直接下载使用。</p>

        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2018/07/17/gofmt-formating-your-code/">使用gofmt格式化代码</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-07-17
        </span><span class="post-category">
            <a href="/categories/Golang/">Golang</a>
            </span>
        </div>
    </header>

    <div class="post-content"><p><img src="/upload/20180717_01.png"></p>
<p>对于一门编程语言来说，代码格式化是最容易引起争议的一个问题，不同的开发者可能会有不同的编码风格和习惯，但是如果所有开发者都能使用同一种格式来编写代码，开发者就可以将宝贵的时间专注在语言要解决的问题上。</p>
<h1 id="gofmt介绍"><a href="#gofmt介绍" class="headerlink" title="gofmt介绍"></a>gofmt介绍</h1><p>Golang的开发团队制定了统一的官方代码风格，并且推出了gofmt工具（gofmt或go fmt）来帮助开发者格式化他们的代码到统一的风格。gofmt是一个cli程序，会优先读取标准输入，如果传入了文件路径的话，会格式化这个文件，如果传入一个目录，会格式化目录中所有.go文件，如果不传参数，会格式化当前目录下的所有.go文件。</p>
<p>gofmt默认不对代码进行简化，使用-s参数可以开启简化代码功能，具体来说会进行如下的转换：</p>
<ul>
<li>  去除数组、切片、Map初始化时不必要的类型声明：</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">如下形式的切片表达式：</span><br><span class="line">    []T&#123;T&#123;&#125;, T&#123;&#125;&#125;</span><br><span class="line">将被简化为：</span><br><span class="line">    []T&#123;&#123;&#125;, &#123;&#125;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>  去除数组切片操作时不必要的索引指定</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">如下形式的切片表达式：</span><br><span class="line">    s[a:<span class="built_in">len</span>(s)]</span><br><span class="line">将被简化为：</span><br><span class="line">    s[a:]</span><br></pre></td></tr></table></figure>

<ul>
<li>  去除迭代时非必要的变量赋值</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">如下形式的迭代：</span><br><span class="line">    <span class="keyword">for</span> x, _ = <span class="keyword">range</span> v &#123;...&#125;</span><br><span class="line">将被简化为：</span><br><span class="line">    <span class="keyword">for</span> x = <span class="keyword">range</span> v &#123;...&#125;</span><br><span class="line">如下形式的迭代：</span><br><span class="line">    <span class="keyword">for</span> _ = <span class="keyword">range</span> v &#123;...&#125;</span><br><span class="line">将被简化为：</span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">range</span> v &#123;...&#125;</span><br></pre></td></tr></table></figure>

<p>gofmt命令参数列表如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">usage: gofmt [flags] [path ...]</span><br><span class="line">  -cpuprofile string</span><br><span class="line">        write cpu profile to this file</span><br><span class="line">  -d    display diffs instead of rewriting files</span><br><span class="line">  -e    report all errors (not just the first 10 on different lines)</span><br><span class="line">  -l    list files whose formatting differs from gofmt<span class="string">&#x27;s</span></span><br><span class="line"><span class="string">  -r string</span></span><br><span class="line"><span class="string">        rewrite rule (e.g., &#x27;</span>a[b:len(a)] -&gt; a[b:]<span class="string">&#x27;)</span></span><br><span class="line"><span class="string">  -s    simplify code</span></span><br><span class="line"><span class="string">  -w    write result to (source) file instead of stdout</span></span><br></pre></td></tr></table></figure>

<p>可以看到，gofmt命令还支持自定义的重写规则，使用-r参数，按照pattern -&gt; replacement的格式传入规则。</p>
<p>有如下内容的Golang程序，存储在main.go文件中。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   a := <span class="number">1</span></span><br><span class="line">   b := <span class="number">2</span></span><br><span class="line">   c := a + b</span><br><span class="line">   fmt.Println(c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用以下规则来格式化上面的代码。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gofmt -r <span class="string">&quot;a + b -&gt; b + a&quot;</span></span><br></pre></td></tr></table></figure>

<p>格式化的结果如下。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   a := <span class="number">1</span></span><br><span class="line">   b := <span class="number">2</span></span><br><span class="line">   c := b + a</span><br><span class="line">   fmt.Println(c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>*注意：Gofmt使用tab来表示缩进，并且对行宽度无限制，如果手动对代码进行了换行，gofmt也不会强制把代码格式化回一行。</strong></p>
<h1 id="go-fmt和gofmt"><a href="#go-fmt和gofmt" class="headerlink" title="go fmt和gofmt"></a>go fmt和gofmt</h1><p>gofmt是一个独立的cli程序，而go中还有一个go fmt命令，go fmt命令是gofmt的简单封装。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">usage: go fmt [-n] [-x] [packages]</span><br><span class="line"></span><br><span class="line">Fmt runs the <span class="built_in">command</span> <span class="string">&#x27;gofmt -l -w&#x27;</span> on the packages named</span><br><span class="line">by the import paths. It prints the names of the files that are modified.</span><br><span class="line">For more about gofmt, see <span class="string">&#x27;go doc cmd/gofmt&#x27;</span>.</span><br><span class="line">For more about specifying packages, see <span class="string">&#x27;go help packages&#x27;</span>.</span><br><span class="line">The -n flag prints commands that would be executed.</span><br><span class="line">The -x flag prints commands as they are executed.</span><br><span class="line">To run gofmt with specific options, run gofmt itself.</span><br><span class="line"></span><br><span class="line">See also: go fix, go vet.</span><br></pre></td></tr></table></figure>

<p>go fmt命令本身只有两个可选参数-n和-x，-n仅打印出内部要执行的go fmt的命令，-x命令既打印出go fmt命令又执行它，如果需要更细化的配置，需要直接执行gofmt命令。</p>
<p>go fmt在调用gofmt时添加了-l -w参数，相当于执行了<code>gofmt -l -w</code>。</p>
<h1 id="goland中配置gofmt"><a href="#goland中配置gofmt" class="headerlink" title="goland中配置gofmt"></a>goland中配置gofmt</h1><p>Goland是JetBrains公司推出的Go语言IDE，是一款功能强大，使用便捷的产品。</p>
<p>在Goland中，可以通过添加一个File Watcher来在文件发生变化的时候调用gofmt进行代码格式化，具体方法是，点击Preferences -&gt; Tools -&gt; File Watchers，点加号添加一个go fmt模版，Goland中预置的go fmt模版使用的是go fmt命令，将其替换为gofmt，然后在参数中增加-l -w -s参数，启用代码简化功能。添加配置后，保存源码时，goland就会执行代码格式化了。</p>
<p><img src="/upload/20180717_02.png"></p>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a target="_blank" rel="noopener" href="https://golang.org/cmd/gofmt/">https://golang.org/cmd/gofmt/</a></p>
<p><a target="_blank" rel="noopener" href="https://golang.org/doc/effective_go.html">https://golang.org/doc/effective_go.html</a></p>
<p><a target="_blank" rel="noopener" href="https://openhome.cc/Gossip/Go/gofmt.html">https://openhome.cc/Gossip/Go/gofmt.html</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/hyper0x/go_command_tutorial/blob/master/0.9.md">https://github.com/hyper0x/go_command_tutorial/blob/master/0.9.md</a></p>

        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2018/07/15/solving-kubernetes-dns-problem/">搭建Kubernetes集群时DNS无法解析问题的处理过程</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-07-15
        </span><span class="post-category">
            <a href="/categories/DevOps/">DevOps</a>
            </span>
        </div>
    </header>

    <div class="post-content"><p><img src="/upload/20180715_01.jpg"></p>
<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>在搭建Kubernetes集群过程中，安装了kube-dns插件后，运行一个ubuntu容器，发现容器内无法解析集群外域名，一开始可以解析集群内域名，一段时间后也无法解析集群内域名。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ nslookup kubernetes.default</span><br><span class="line">Server:    10.99.0.2</span><br><span class="line">Address 1: 10.99.0.2 kube-dns.kube-system.svc.cluster.local</span><br><span class="line"></span><br><span class="line">nslookup: can<span class="string">&#x27;t resolve &#x27;</span>kubernetes.default<span class="string">&#x27;</span></span><br></pre></td></tr></table></figure>

<h1 id="排查过程"><a href="#排查过程" class="headerlink" title="排查过程"></a>排查过程</h1><p>在排查问题前，先思考一下Kubernetes集群中的DNS解析过程，在安装好kube-dns的集群中，普通Pod的dnsPolicy属性是默认值ClusterFirst，也就是会指向集群内部的DNS服务器，kube-dns负责解析集群内部的域名，kube-dns Pod的dnsPolicy值是Default，意思是从所在Node继承DNS服务器，对于无法解析的外部域名，kube-dns会继续向集群外部的dns进行查询，过程如图。</p>
<p><img src="/upload/20180715_02.jpg"></p>
<p>Ubuntu容器是一个普通的Pod，在Linux系统中，/etc/resolv.conf是存储DNS服务器的文件，普通Pod的/etc/resolv.conf文件应该存储的是kube-dns的Service IP。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nameserver 10.99.0.2  <span class="comment"># 这里存储的是kube-dns的Service IP</span></span><br><span class="line">search default.svc.cluster.local. svc.cluster.local. cluster.local.</span><br><span class="line">options ndots:5</span><br></pre></td></tr></table></figure>

<p>查看后发现/etc/resolv.conf文件中存储的是kube-dns的Service IP，证明这一步没有问题，接下来查看一下kube-dns的Pod，先进入kube-dns的Pod中检查一下/etc/resolv.conf文件，这里存储的应该是集群外部的DNS服务器地址，查看后发现，这里存储的地址是127.0.0.53，进一步查看kube-dns Pod的log，发现出现了非常多的i/o timeout错误。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> 2018/07/11 07:12:47 [ERROR] 2 [www.baidu.com](http://www.baidu.com/). A: unreachable backend: <span class="built_in">read</span> udp 127.0.0.1:38019-&gt;127.0.0.53:53: i/o timeout</span><br><span class="line">2018/07/11 07:12:47 [ERROR] 2 [www.baidu.com](http://www.baidu.com/). A: unreachable backend: <span class="built_in">read</span> udp 127.0.0.1:57567-&gt;127.0.0.53:53: i/o timeout</span><br><span class="line">2018/07/11 07:12:47 [ERROR] 2 [www.baidu.com](http://www.baidu.com/). A: unreachable backend: <span class="built_in">read</span> udp 127.0.0.1:52599-&gt;127.0.0.53:53: i/o timeout</span><br><span class="line">2018/07/11 07:12:47 [ERROR] 2 [www.baidu.com](http://www.baidu.com/). A: unreachable backend: <span class="built_in">read</span> udp 127.0.0.1:42539-&gt;127.0.0.53:53: i/o timeout</span><br><span class="line">2018/07/11 07:12:47 [ERROR] 2 [www.baidu.com](http://www.baidu.com/). A: unreachable backend: <span class="built_in">read</span> udp 127.0.0.1:46885-&gt;127.0.0.53:53: i/o timeout</span><br><span class="line">2018/07/11 07:12:47 [ERROR] 2 [www.baidu.com](http://www.baidu.com/). A: unreachable backend: <span class="built_in">read</span> udp 127.0.0.1:44189-&gt;127.0.0.53:53: i/o timeout</span><br><span class="line">2018/07/11 07:12:47 [ERROR] 2 [www.baidu.com](http://www.baidu.com/). A: unreachable backend: <span class="built_in">read</span> udp 127.0.0.1:56505-&gt;127.0.0.53:53: i/o timeout</span><br><span class="line">2018/07/11 07:12:47 [ERROR] 2 [www.baidu.com](http://www.baidu.com/). A: unreachable backend: <span class="built_in">read</span> udp 127.0.0.1:47320-&gt;127.0.0.53:53: i/o timeout</span><br><span class="line">2018/07/11 07:12:47 [ERROR] 2 [www.baidu.com](http://www.baidu.com/). A: unreachable backend: <span class="built_in">read</span> udp 127.0.0.1:42464-&gt;127.0.0.53:53: i/o timeout</span><br><span class="line">2018/07/11 07:12:47 [ERROR] 2 [www.baidu.com](http://www.baidu.com/). A: unreachable backend: <span class="built_in">read</span> udp 127.0.0.1:49203-&gt;127.0.0.53:53: i/o timeout</span><br><span class="line">2018/07/11 07:12:47 [ERROR] 2 [www.baidu.com](http://www.baidu.com/). A: unreachable backend: <span class="built_in">read</span> udp 127.0.0.1:58103-&gt;127.0.0.53:53: i/o timeout</span><br><span class="line">2018/07/11 07:12:47 [ERROR] 2 [www.baidu.com](http://www.baidu.com/). A: unreachable backend: <span class="built_in">read</span> udp 127.0.0.1:47148-&gt;127.0.0.53:53: i/o timeout</span><br><span class="line">2018/07/11 07:12:47 [ERROR] 2 [www.baidu.com](http://www.baidu.com/). A: unreachable backend: <span class="built_in">read</span> udp 127.0.0.1:36883-&gt;127.0.0.53:53: i/o timeout</span><br><span class="line">2018/07/11 07:12:47 [ERROR] 2 [www.baidu.com](http://www.baidu.com/). A: unreachable backend: <span class="built_in">read</span> udp 127.0.0.1:40968-&gt;127.0.0.53:53: i/o timeout</span><br><span class="line">2018/07/11 07:12:47 [ERROR] 2 [www.baidu.com](http://www.baidu.com/). A: unreachable backend: <span class="built_in">read</span> udp 127.0.0.1:55672-&gt;127.0.0.53:53: i/o timeout</span><br></pre></td></tr></table></figure>

<p>现在基本上可以发现问题的原因了，kube-dns只能解析集群内部地址，而集群外部地址应该发给外部DNS服务器进行解析，由于kube-dns Pod中的/etc/resolv.conf文件存储的DNS服务器地址是127.0.0.53，127.<em>.</em>.*都是回环地址，也就是集群外域名的DNS解析请求会再次发送回kube-dns，导致形成一个循环，这也是一秒钟会出现几十次i/o timeout日志的原因，请求会不断的在kube-dns中循环，kube-dns就像一个黑洞一样，吃掉了所有dns解析请求，不断累积的请求最终会导致整个集群的网络出现卡顿。</p>
<p><img src="/upload/20180715_03.jpg"></p>
<h1 id="为什么"><a href="#为什么" class="headerlink" title="为什么"></a>为什么</h1><p>虽然问题的原因找到了，但是为什么kube-dns Pod中/etc/resolv.conf文件存储的DNS服务器是127.0.0.53？</p>
<p>kube-dns Pod的dnsPolicy值是Default，查看一下Kubernetes文档。</p>
<blockquote>
<p>“<code>Default</code>“: The Pod inherits the name resolution configuration from the node that the pods run on. See <a target="_blank" rel="noopener" href="https://kubernetes.io/docs/tasks/administer-cluster/dns-custom-nameservers/#inheriting-dns-from-the-node">related discussion</a> for more details.</p>
</blockquote>
<p>所以kube-dns的/etc/resolv.conf文件是从Node中继承来的，查看Node中的/etc/resolv.conf文件，存储的DNS服务器地址确实是127.0.0.53，那么下一个问题出现了，在Node中发送DNS解析请求为什么不会产生回环的问题呢？</p>
<p>Node使用的是Ubuntu 18.04 Server，在这个版本的系统中，DNS解析请求并不是直接发给所在网络的DNS服务器的，Ubuntu 18.04中有一个systemd-resolved服务，为本地应用程序提供了DNS解析服务，例如nslookup localhost，解析程序从/etc/resolv.conf文件中找到DNS服务器127.0.0.53，发送解析请求，systemd-resolved会监听在53端口上，捕获到解析请求后，如果是自己可以解析的，例如localhost，会直接返回127.0.0.1，如果不能解析，才会发送给外部服务器，而外部服务器的地址存储在/run/systemd/resolve/resolv.conf文件中，这个文件是systemd-resolved服务器的配置文件，过程如图。</p>
<p><img src="/upload/20180715_04.jpg"></p>
<h1 id="怎么破"><a href="#怎么破" class="headerlink" title="怎么破"></a>怎么破</h1><p>理解了问题的来龙去脉，解决问题的办法也就应运而生。在Kubernetes集群中，kubelet是worker组建，负责管理Pod，根据kubernetes文档，kubelet默认会从Node的/etc/resolv.conf文件读取DNS服务器地址，使得dnsPolicy是Default的Pod得以继承，kubelet中的–resolv-conf参数可以指定这个配置文件的地址。在Ubuntu 18.04中，将这个参数设置为systemd-resolved的DNS服务器配置文件/run/systemd/resolve/resolv.conf，Pod就会继承真正的外部DNS服务器。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过对问题的探究，也理解了Kubernetes集群中DNS解析的完整过程，如图。</p>
<p><img src="/upload/20180715_05.jpg"></p>
<p><em>* 在Ubuntu 16.04中也是类似的逻辑，只不过systemd-resolved换成了dnsmasq，监听地址是127.0.1.1</em><br><em>* 在具体实践过程中，也顺便探究了CoreDNS和KubeDNS架构和解析逻辑上的区别，不过不在此问题的讨论范围，有兴趣的朋友可以自己看一下。</em><br><em>* 如果Kubernetes集群是安装在NAT网络下的虚拟机上，虚拟机（也就是Kubernetes集群中的Node）中/etc/resolv.conf文件可能被修改为NAT的地址，也就不会出现上面这个问题。</em></p>
<h1 id="参考内容"><a href="#参考内容" class="headerlink" title="参考内容"></a>参考内容</h1><p> <a target="_blank" rel="noopener" href="https://kubernetes.io/docs/reference/command-line-tools-reference/kubelet/">https://kubernetes.io/docs/reference/command-line-tools-reference/kubelet/</a><br><a target="_blank" rel="noopener" href="https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/">https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/</a><br><a target="_blank" rel="noopener" href="https://kubernetes.io/docs/tasks/administer-cluster/dns-custom-nameservers/">https://kubernetes.io/docs/tasks/administer-cluster/dns-custom-nameservers/</a><br><a target="_blank" rel="noopener" href="https://www.freedesktop.org/software/systemd/man/systemd-resolved.service.html">https://www.freedesktop.org/software/systemd/man/systemd-resolved.service.html</a><br><a target="_blank" rel="noopener" href="https://github.com/kubernetes/kubernetes/issues/49411">https://github.com/kubernetes/kubernetes/issues/49411</a><br><a target="_blank" rel="noopener" href="https://github.com/kubernetes/kubernetes/issues/45828">https://github.com/kubernetes/kubernetes/issues/45828</a></p>

        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2018/07/10/build-golang-environment/">Golang环境安装和依赖管理</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-07-10
        </span><span class="post-category">
            <a href="/categories/Golang/">Golang</a>
            </span>
        </div>
    </header>

    <div class="post-content"><p>2015年，Go 1.5加入了一个试验性的vendor机制（到2016年的Go 1.6版变为默认开启），vendor机制就是在项目中加入了vendor文件夹，用于存放依赖，这样就可以将不同项目的依赖隔离开。<br><img src="/upload/20180710_02.png"></p>
<p>Golang一种静态强类型、编译型、并发型，并具有垃圾回收功能的编程语言。Golang提供了方便的安装包，支持Windows、Linux、Mac系统。</p>
<h1 id="下载安装包"><a href="#下载安装包" class="headerlink" title="下载安装包"></a>下载安装包</h1><p>Golang的官网是<a target="_blank" rel="noopener" href="https://golang.org/">https://golang.org/</a>，如果官网打不开，可以访问<a target="_blank" rel="noopener" href="https://golang.google.cn/">https://golang.google.cn/</a>这个域名。在官网点击Download Go会进入下载页，可以看到这里提供了针对各个系统的安装包，也提供了源码，可以下载源码编译安装。</p>
<p><img src="/upload/20180710_03.png"></p>
<p>下载运行安装包后，在terminal中执行go env命令，如果出现下面的输出说明已经安装成功。</p>
<p><img src="/upload/20180710_04.png"></p>
<h1 id="GOROOT与GOPATH"><a href="#GOROOT与GOPATH" class="headerlink" title="GOROOT与GOPATH"></a>GOROOT与GOPATH</h1><p>仔细看上面的输出，会发现其中有一个GOPATH，又有一个GOROOT，那么到底哪个才是Golang的运行环境呢。</p>
<p>首先访问一下GOROOT这个路径，会发现其中包含bin、lib等文件夹。GOROOT就是Golang的安装路径，其中包含Golang编译、工具、标准库等，在安装后就会存在。</p>
<p>和GOROOT不同，GOPATH是工作空间路径，从go 1.8开始，如果GOPATH没有被设置，会有一个默认值，在Unix上为$HOME/go，在Windows上为%USERPROFILE%/go，当调用go build时，它会在GOPATH中寻找源码。访问一下GOPATH这个路径，会发现其中只有pkg、bin、src三个文件夹，并且里面基本是空的，这是一个约定的目录结构，src文件夹用来存放源码、pkg存放编译后生成的文件，bin存放编译后生成的可执行文件。项目代码需要在GOPATH/src路径下。</p>
<p>GOPATH路径下出了存放项目代码，还存放所有通过go get安装的依赖，项目代码和依赖代码是平级的，当各个项目都有很多依赖的时候，这个GOPATH路径下的代码量会多的吓人，并且难以拆分。</p>
<h1 id="Vendor"><a href="#Vendor" class="headerlink" title="Vendor"></a>Vendor</h1><p>当使用go run或者go build命令时，会首先从当前路径下的vendor文件夹中查找依赖，如果vendor不存在，才会从GOPATH中查找依赖。</p>
<p>然而我们安装依赖通常使用go get或者go install命令，这两个命令依旧会把依赖安装到GOPATH路径下。</p>
<h1 id="包管理工具dep"><a href="#包管理工具dep" class="headerlink" title="包管理工具dep"></a>包管理工具dep</h1><p>Vendor只是go官方提供的一个机制，但是包管理的问题依然没有解决，并且也没有对依赖进行版本管理。如果要实现上述的功能，还需要借助包管理工具。</p>
<p>Go官方给出了包管理工具的对比：<a target="_blank" rel="noopener" href="https://github.com/golang/go/wiki/PackageManagementTools">https://github.com/golang/go/wiki/PackageManagementTools</a></p>
<p>dep是官方的试验性包管理工具，可以通过如下脚本安装</p>
<p>curl <a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/golang/dep/master/install.sh">https://raw.githubusercontent.com/golang/dep/master/install.sh</a> | sh</p>
<p>安装完成后，进入项目路径，执行</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dep <span class="keyword">init</span></span><br></pre></td></tr></table></figure>

<p>项目中会出现两个文件一个目录</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">Gopkg</span>.</span></span>toml</span><br><span class="line"><span class="module-access"><span class="module"><span class="identifier">Gopkg</span>.</span></span>lock</span><br><span class="line">vendor</span><br></pre></td></tr></table></figure>

<p>dep包管理的流程如图</p>
<p><img src="/upload/20180710_05.jpg"></p>
<ul>
<li><p>solving功能，它将当前项目中的导入包和Gopkg.toml中的规则作为输入，不可变的依赖关系图作为传递完成后的输出，形成Gopkg.lock。</p>
</li>
<li><p>vendor功能，将Gopkg.lock中的信息作为输入，确保项目编译时能使用在Gopkg.lock文件中锁定的版本。</p>
</li>
</ul>
<p>使用如下命令添加依赖</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dep ensure -add [github.com<span class="regexp">/gin-gonic/gi</span>n](http:<span class="regexp">//gi</span>thub.com<span class="regexp">/gin-gonic/gi</span>n)</span><br></pre></td></tr></table></figure>

<p>使用如下命令更新Gopkg.lock</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dep <span class="keyword">ensure</span> -update</span><br></pre></td></tr></table></figure>

        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2018/07/10/transition-of-parameters-of-functions-in-python/">你所不知道的Python | 函数参数的演进之路</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-07-10
        </span><span class="post-category">
            <a href="/categories/Python/">Python</a>
            </span>
        </div>
    </header>

    <div class="post-content"><p><img src="/upload/20180710_01.png"></p>
<p>函数参数处理机制是Python中一个非常重要的知识点，随着Python的演进，参数处理机制的灵活性和丰富性也在不断增加，使得我们不仅可以写出简化的代码，也能处理复杂的调用。</p>
<h1 id="关键字参数"><a href="#关键字参数" class="headerlink" title="关键字参数"></a>关键字参数</h1><p><strong>调用时指定参数的名称，且与函数声明时的参数名称一致。</strong></p>
<p>关键字参数是Python函数中最基础也最常见的，我们写一个记账的函数，参数是需要记录的时间和金额。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_record</span>(<span class="params">date, amount</span>):</span></span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;date:&#x27;</span>, date, <span class="string">&#x27;amount:&#x27;</span>, amount)</span><br></pre></td></tr></table></figure>

<p>这里的amount参数就是一个关键字参数，关键字参数支持两种调用方式：</p>
<ul>
<li><strong>位置调用</strong></li>
<li><strong>关键字调用</strong></li>
</ul>
<p>位置调用，就是按参数的位置进行调用，例如传入两个参数，第一个是字符串2018-07-06，第二个是整数10，那么这两个参数会被分别赋予date和amount变量，如果顺序反过来，则这两个参数分别赋予amount和date变量。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">add_record(<span class="string">&#x27;2018-07-06&#x27;</span>, <span class="number">10</span>)  <span class="comment"># 输出date: 2018-07-06 amount: 10</span></span><br><span class="line">add_record(<span class="number">10</span>, <span class="string">&#x27;2018-07-06&#x27;</span>)  <span class="comment"># 输出date: 10 amount: 2018-07-06</span></span><br></pre></td></tr></table></figure>

<p>关键字调用，可以忽略参数顺序，直接指定参数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_record(amount=<span class="number">10</span>, date=<span class="string">&#x27;2018-07-06&#x27;</span>)  <span class="comment"># 虽然参数顺序反了，但是使用了关键字调用，所以依然输出date: 2018-07-06 amount: 10</span></span><br></pre></td></tr></table></figure>

<h1 id="仅限关键字参数"><a href="#仅限关键字参数" class="headerlink" title="仅限关键字参数"></a>仅限关键字参数</h1><p>我们定义一个Person类，并实现它的<code>__init__</code>方法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, age,  gender, height, weight</span>):</span></span><br><span class="line">		self._name = name</span><br><span class="line">		self._age = age</span><br><span class="line">		self._gender = gender</span><br><span class="line">		self._height = height</span><br><span class="line">		self._weight = weight</span><br></pre></td></tr></table></figure>

<p>当初始化这个类的时候，我们可以使用关键字调用，也可以使用位置调用。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Person(<span class="string">&#x27;Wendy&#x27;</span>, <span class="number">24</span>, <span class="string">&#x27;female&#x27;</span>, <span class="number">160</span>, <span class="number">48</span>)</span><br><span class="line">Person(<span class="string">&#x27;John&#x27;</span>, age=<span class="number">27</span>, gender=<span class="string">&#x27;male&#x27;</span>, height=<span class="number">170</span>, weight=<span class="number">52</span>)</span><br></pre></td></tr></table></figure>

<p>对比上面两种方式，我们会发现参数多的时候通过关键字指定参数不仅更加清晰，也更具有可读性。如果我们希望函数只允许关键字调用，该如何做呢？Python 3.0中，引入了一种新的仅限关键字参数，能实现我们的需求。</p>
<p>下面将age以后的参数修改为只允许关键字调用，定义函数时想指定仅限关键字参数，要把它们放到前面有星号的参数后面，在Python中有星号的参数是可变参数的意思，如果不想支持可变参数，可以在参数中放一个星号作为分割。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">        <span class="comment"># 参数中的星号作为关键字参数和仅限关键字参数的分割</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, *, age=<span class="string">&#x27;22&#x27;</span>, gender=<span class="string">&#x27;female&#x27;</span>, height=<span class="number">160</span>, weight=<span class="number">50</span></span>):</span></span><br><span class="line">		self._name = name</span><br><span class="line">		self._age = age</span><br><span class="line">		self._gender = gender</span><br><span class="line">		self._height = height</span><br><span class="line">		self._weight = weight</span><br><span class="line"></span><br><span class="line">Person(<span class="string">&#x27;Wendy&#x27;</span>, <span class="number">24</span>, <span class="string">&#x27;female&#x27;</span>, <span class="number">160</span>, <span class="number">48</span>)  <span class="comment"># 报错，age以后参数不允许位置调用</span></span><br><span class="line">Person(<span class="string">&#x27;John&#x27;</span>, age=<span class="number">27</span>, gender=<span class="string">&#x27;male&#x27;</span>, height=<span class="number">170</span>, weight=<span class="number">52</span>)  <span class="comment"># 正常执行</span></span><br></pre></td></tr></table></figure>

<p>普通参数和仅限关键字参数中间由一个星号隔离开，星号以后的都是仅限关键字参数，只可以通过关键字指定，而不能通过位置指定。</p>
<h1 id="参数默认值"><a href="#参数默认值" class="headerlink" title="参数默认值"></a>参数默认值</h1><p><strong>在函数声明时，指定参数默认值，调用时不传入参数则使用默认值，相当于可选参数。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_record</span>(<span class="params">date, amount=<span class="number">0</span></span>):</span></span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;date:&#x27;</span>, date, <span class="string">&#x27;amount:&#x27;</span>, amount)</span><br><span class="line"></span><br><span class="line">add_record(<span class="string">&#x27;2018-07-06&#x27;</span>)  <span class="comment"># 输出date: 2018-07-06 amount: 0</span></span><br></pre></td></tr></table></figure>

<p>上面代码中没有传入amount参数，所以amount直接被置为默认值0。有一点需要注意的是，<strong>默认参数需要设置在必选参数后面</strong>，并且默认参数既可以通过位置调用，也可以通过关键字调用。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">add_record(<span class="string">&#x27;2018-07-06&#x27;</span>, <span class="number">10</span>)  <span class="comment"># 通过位置指定参数</span></span><br><span class="line">add_record(<span class="string">&#x27;2018-07-06&#x27;</span>, amount=<span class="number">10</span>)  <span class="comment"># 通过位置指定参数</span></span><br><span class="line">add_record(amount=<span class="number">10</span>, <span class="string">&#x27;2018-07-06&#x27;</span>)  <span class="comment"># 报错，默认参数必须在必选参数后面</span></span><br></pre></td></tr></table></figure>

<p>参数默认值既支持关键字参数，也支持仅限关键字参数。</p>
<h1 id="可变长参数"><a href="#可变长参数" class="headerlink" title="可变长参数"></a>可变长参数</h1><p><strong>“可变长”顾名思义是允许在调用时传入多个参数，可变长参数适用于参数数量不确定的场景，可变参数有两种，一种是关键字可变长参数，另一种是非关键字可变长参数。</strong></p>
<p>非关键字可变长参数的写法是在参数名前加一个星号，Python会将这些多出来的参数的值放入一个元组中，由于元组中只有参数值而没有参数名称，所以是关键字参数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_args</span>(<span class="params">*args</span>):</span></span><br><span class="line">	<span class="built_in">print</span>(args)</span><br><span class="line"></span><br><span class="line">print_args(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)  <span class="comment"># 输出元组(1, 2, 3, 4, 5)</span></span><br><span class="line"></span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">print_args(a)  <span class="comment"># 直接传入时，列表a会被当作一个元素，所以输出([1, 2, 3, 4, 5],)</span></span><br><span class="line">print_args(*a)  <span class="comment"># 在传参时加星号可以将可迭代参数解包，所以列表a中每一个元素都被当作一个参数传入，输出(1, 2, 3, 4, 5)</span></span><br></pre></td></tr></table></figure>

<p>关键字可变长参数的写法是在参数名前加两个星号，Python会将这些多出来的参数的值放入一个字典中，由于字典中只有参数值而没有参数名称，所以是非关键字参数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_kwargs</span>(<span class="params">**kw_args</span>):</span></span><br><span class="line">	<span class="built_in">print</span>(kw_args)</span><br><span class="line"></span><br><span class="line">a = &#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;d&#x27;</span>: <span class="number">4</span>, <span class="string">&#x27;e&#x27;</span>: <span class="number">5</span>&#125;</span><br><span class="line">print_kwargs(**a)  <span class="comment"># 使用关键字可变参数时， &#123;&#x27;a&#x27;: 1, &#x27;c&#x27;: 3, &#x27;b&#x27;: 2, &#x27;e&#x27;: 5, &#x27;d&#x27;: 4&#125;</span></span><br></pre></td></tr></table></figure>

<h1 id="函数注解"><a href="#函数注解" class="headerlink" title="函数注解"></a>函数注解</h1><p>Python 3中为函数定义增加的另一个新功能是函数注解，所谓函数注解，就是可以在函数参数和返回值上添加任意的元数据。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_person</span>(<span class="params">name: <span class="built_in">str</span>, age: <span class="built_in">int</span>, gender: <span class="built_in">str</span> = <span class="string">&#x27;female&#x27;</span>, height: <span class="built_in">int</span> = <span class="number">160</span></span>)  -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>用create_person方法举例，可以看到在每个参数后面都跟了一个参数类型，在函数后面则是返回值类型，函数注解可以用在文档编写、类型检查中，在支持函数注解的IDE中，如果传入参数和返回的类型不符合函数注解中的类型，IDE会提示错误。</p>
<p>但是函数注解只是一个元数据，Python解释器执行时候并不会去检查类型，所以下面这种情况也是合法的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person(name=<span class="number">123</span>, age=<span class="string">&#x27;John&#x27;</span>)  <span class="comment"># 并不会报错</span></span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Python有着非常好入门的特点，但是随着语言本身的演进，很多高级功能也在持续加入，用好这些功能可以使我们的Python代码拥有更高的可读性，适应更加复杂的应用场景。</p>

        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2018/06/28/the-secret-of-string-concatenation/">你所不知道的Python | 字符串连接的秘密</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-06-28
        </span><span class="post-category">
            <a href="/categories/Python/">Python</a>
            </span>
        </div>
    </header>

    <div class="post-content"><p><img src="/upload/20180628_04.jpg"></p>
<p>字符串连接，就是将2个或以上的字符串合并成一个，看上去连接字符串是一个非常基础的小问题，但是在Python中，我们可以用多种方式实现字符串的连接，稍有不慎就有可能因为选择不当而给程序带来性能损失。</p>
<h1 id="方法1：加号连接"><a href="#方法1：加号连接" class="headerlink" title="方法1：加号连接"></a>方法1：加号连接</h1><p>很多语言都支持使用加号连接字符串，Python也不例外，只需要简单的将2个或多个字符串相加就可以完成拼接。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="string">&#x27;Python&#x27;</span></span><br><span class="line">b = <span class="string">&#x27;私房菜&#x27;</span></span><br><span class="line">r = a + b  <span class="comment"># 输出&#x27;Python私房菜&#x27;</span></span><br></pre></td></tr></table></figure>

<h1 id="方法2：使用-操作符"><a href="#方法2：使用-操作符" class="headerlink" title="方法2：使用%操作符"></a>方法2：使用%操作符</h1><p>在Python 2.6以前，%操作符是唯一一种格式化字符串的方法，它也可以用于连接字符串。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="string">&#x27;Python&#x27;</span></span><br><span class="line">b = <span class="string">&#x27;私房菜&#x27;</span></span><br><span class="line">r = <span class="string">&#x27;%s%s&#x27;</span> % (a, b)  <span class="comment"># 输出&#x27;Python私房菜&#x27;</span></span><br></pre></td></tr></table></figure>

<h1 id="方法3：使用format方法"><a href="#方法3：使用format方法" class="headerlink" title="方法3：使用format方法"></a>方法3：使用format方法</h1><p>format方法是Python 2.6中出现的一种代替%操作符的字符串格式化方法，同样可以用来连接字符串。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="string">&#x27;Python&#x27;</span></span><br><span class="line">b = <span class="string">&#x27;私房菜&#x27;</span></span><br><span class="line">r = <span class="string">&#x27;&#123;&#125;&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(a, b)</span><br></pre></td></tr></table></figure>

<h1 id="方法4：使用f-string"><a href="#方法4：使用f-string" class="headerlink" title="方法4：使用f-string"></a>方法4：使用f-string</h1><p>Python 3.6中引入了Formatted String Literals（字面量格式化字符串），简称f-string，f-string是%操作符和format方法的进化版，使用f-string连接字符串的方法和使用%操作符、format方法类似。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="string">&#x27;Python&#x27;</span></span><br><span class="line">b = <span class="string">&#x27;私房菜&#x27;</span></span><br><span class="line">r = <span class="string">f&#x27;<span class="subst">&#123;a&#125;</span><span class="subst">&#123;b&#125;</span>&#x27;</span></span><br></pre></td></tr></table></figure>

<h1 id="方法5：使用str-join-方法"><a href="#方法5：使用str-join-方法" class="headerlink" title="方法5：使用str.join()方法"></a>方法5：使用str.join()方法</h1><p>字符串有一个内置方法join，其参数是一个序列类型，例如数组或者元组等。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="string">&#x27;Python&#x27;</span></span><br><span class="line">b = <span class="string">&#x27;私房菜&#x27;</span></span><br><span class="line">r = <span class="string">&#x27;&#x27;</span>.join([a, b])</span><br></pre></td></tr></table></figure>

<h1 id="对比测试"><a href="#对比测试" class="headerlink" title="对比测试"></a>对比测试</h1><p>既然连接字符串有这么多方法，那么使用时到底选择哪种呢？我们从代码可读性和性能两个层面来评估一下上面5种方法。</p>
<p>使用timeit模块，分别执行上述5种方法的示例代码100000次，执行时间如图。</p>
<p><img src="/upload/20180628_05.png"></p>
<p>可以看到，%操作符、format和f-string都是字符串格式化方法，性能依次递增，加号连接的性能和f-string不相上下。</p>
<p>有一点需要注意的是，字符串类型是不可变的，所以每一次应用加号连接字符串都会生成一个新的字符串，连接多个字符串时，效率低下就是必然的了，我们将一次连接的字符串提升到10个和20个，再来进行2轮测试，下面是连接20个字符串时的耗时情况。</p>
<p><img src="/upload/20180628_06.png"></p>
<p>和连接两个字符串时的结果出现了一些不同，首先使用加号连接的方式在字符串数量较多时（大于10个），性能会急剧下降，str.join()方法在连接大量字符串时性能最好。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><strong>连接少量字符串时</strong><br>使用<strong>加号</strong>连接符在性能和可读性上都是明智的，如果对可读性有更高的要求，并且使用的Python 3.6以上版本，<strong>f-string</strong>也是一个非常好的选择，例如下面这种情况，f-string的可读性显然比加号连接好得多。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="string">f&#x27;姓名：<span class="subst">&#123;name&#125;</span> 年龄：<span class="subst">&#123;age&#125;</span> 性别：<span class="subst">&#123;gender&#125;</span>&#x27;</span></span><br><span class="line">b = <span class="string">&#x27;姓名：&#x27;</span> + name + <span class="string">&#x27;年龄：&#x27;</span> + age + <span class="string">&#x27;性别：&#x27;</span> + gender</span><br></pre></td></tr></table></figure>

<p><strong>连接大量字符串时</strong><br><strong>join</strong>和<strong>f-string</strong>都是性能最好的选择，选择时依然取决于你使用的Python版本以及对可读性的要求，f-string在连接大量字符串时可读性并不一定好。切记不要使用加号连接，尤其是在for循环中。</p>

        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2018/06/28/install-kvm-on-ubuntu-18.04-lts/">Ubuntu 18.04 LTS安装KVM虚拟机</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-06-28
        </span><span class="post-category">
            <a href="/categories/DevOps/">DevOps</a>
            </span>
        </div>
    </header>

    <div class="post-content"><p><img src="/upload/20180628_01.png"></p>
<p>前一阵使用在最新的Ubuntu 18.04上安装了KVM来虚拟一个小的VM集群，将主要过程和其中遇到的一些问题记录下来。</p>
<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><p>首先需要检查一下CPU是否支持虚拟化，执行一下命令来检查/proc/cpuinfo文件中是否又虚拟化相关的字眼，如果有的话表明CPU支持虚拟化技术。</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">egrep -c <span class="string">&#x27;(svm|vmx)&#x27;</span> <span class="regexp">/proc/</span>cpuinfo</span><br></pre></td></tr></table></figure>

<p>上面命令执行结果如果返回0，表示CPU不支持虚拟化技术。当然主板BIOS中的虚拟化技术也可能不是默认开启的，如果没有开启需要手动开启一下。</p>
<h1 id="安装KVM"><a href="#安装KVM" class="headerlink" title="安装KVM"></a>安装KVM</h1><p>执行以下命令安装KVM</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt <span class="keyword">install </span>qemu qemu-kvm libvirt-<span class="keyword">bin </span> <span class="keyword">bridge-utils </span> virt-manager</span><br></pre></td></tr></table></figure>

<p>将libvirtd添加自启动</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl <span class="keyword">start</span> libvirtd.service</span><br><span class="line">sudo systemctl <span class="keyword">enable</span> libvirtd.service</span><br></pre></td></tr></table></figure>

<h1 id="网络模式"><a href="#网络模式" class="headerlink" title="网络模式"></a>网络模式</h1><p>KVM安装完成后，首先需要进行网络设定，KVM支持四种网络模式：</p>
<ul>
<li>桥接模式</li>
<li>NAT模式</li>
<li>用户网络模式</li>
<li>直接分配设备模式</li>
</ul>
<p>主要讲一下前两种</p>
<h1 id="桥接（Bridge）模式"><a href="#桥接（Bridge）模式" class="headerlink" title="桥接（Bridge）模式"></a>桥接（Bridge）模式</h1><p>在桥接模式下，宿主机和虚拟机共享同一个物理网络设备，虚拟机中的网卡和物理机中的网卡是平行关系，所以虚拟机可以直接接入外部网络，虚拟机和宿主机有平级的IP。</p>
<p><img src="/upload/20180628_02.jpg" alt="桥接模式"></p>
<p>原本宿主机是通过网卡eth0连接外部网络的，网桥模式会新创建一个网桥br0，接管eth0来连接外部网络，然后将宿主机和虚拟机的网卡eth0都绑定到网桥上。</p>
<p>使用桥接模式需要进行以下操作：</p>
<p>编辑<code>/etc/network/interfaces</code>，增加如下内容</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">auto <span class="keyword">br0</span></span><br><span class="line"><span class="keyword"></span>iface <span class="keyword">br0 </span>inet dhcp  <span class="comment"># 网桥使用DHCP模式，从DHCP服务器获取IP</span></span><br><span class="line"><span class="keyword">bridge_ports </span>enp3s0  <span class="comment"># 网卡名称，网桥创建前连接外部的网卡，可通过ifconfig命令查看，有IP地址的就是</span></span><br><span class="line"><span class="keyword">bridge_stp </span>on  <span class="comment"># 避免数据链路出现死循环</span></span><br><span class="line"><span class="keyword">bridge_fd </span><span class="number">0</span>  <span class="comment"># 将转发延迟设置为0</span></span><br></pre></td></tr></table></figure>
<p>接下来需要重启networking服务（如果是通过SSH连接到宿主机上的，这一步会导致网络中断，如果出现问题可能导致连不上宿主机，最好在宿主机上直接操作）</p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="built_in">restart</span> networking.service</span><br></pre></td></tr></table></figure>

<p>使用ifconfig命令查看IP是否从enp3s0（网桥创建前的网卡）变到了br0上，如果没有变化则需要重启。如果宿主机ip已经成功变到网桥上，并且宿主机能正常上网而虚拟机获取不到ip，可能是ufw没有允许ip转发导致的，编辑<code>/etc/default/ufw</code>允许ip转发。</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">DEFAULT_FORWARD_POLICY</span>=<span class="string">&quot;ACCEPT&quot;</span></span><br></pre></td></tr></table></figure>

<p>重启ufw服务让设置生效</p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="built_in">restart</span> ufw.service</span><br></pre></td></tr></table></figure>

<h1 id="NAT（Network-Address-Translation）模式"><a href="#NAT（Network-Address-Translation）模式" class="headerlink" title="NAT（Network Address Translation）模式"></a>NAT（Network Address Translation）模式</h1><p>NAT模式是KVM默认的网络模式，KVM会创建一个名为virbr0的虚拟网桥，但是宿主机和虚拟机对于网桥来说不是平等的了，网桥会把虚拟机藏在背后，虚拟机会被分配一个内网IP，而从外网访问不到虚拟机。</p>
<p><img src="/upload/20180628_03.jpg" alt="NAT模式"></p>
<h1 id="安装Linux虚拟机"><a href="#安装Linux虚拟机" class="headerlink" title="安装Linux虚拟机"></a>安装Linux虚拟机</h1><p>使用如下命令安装安装Linux虚拟机</p>
<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo virt-install -n ubuntu_3</span><br><span class="line"> <span class="params">--description</span> <span class="string">&quot;ubuntu_3&quot;</span></span><br><span class="line"> <span class="params">--os-type=linux</span> <span class="params">--os-variant=ubuntu17</span>.10 <span class="params">--ram=1024</span> <span class="params">--vcpus=1</span></span><br><span class="line"> <span class="params">--disk</span> path=<span class="string">/var/lib/libvirt/images/ubuntu_3.img</span>,bus=virtio,size=50  <span class="comment"># 磁盘位置，大小50G</span></span><br><span class="line"> <span class="params">--network</span> bridge<span class="function">:br0</span>  <span class="comment"># 这里网络选择了桥接模式</span></span><br><span class="line"> <span class="params">--accelerate</span></span><br><span class="line"> <span class="params">--graphics</span> vnc,listen=0.0.0.0,keymap=en-us  <span class="comment"># VNC监听端口，注意要选择en-us作为key-map，否则键位布局可能会乱</span></span><br><span class="line"> <span class="params">--cdrom</span> <span class="string">/home/zzy/Downloads/ubuntu-18.04-live-server-amd64.iso</span>  <span class="comment"># 安装ISO路径</span></span><br></pre></td></tr></table></figure>

<h1 id="安装Windows-10虚拟机"><a href="#安装Windows-10虚拟机" class="headerlink" title="安装Windows 10虚拟机"></a>安装Windows 10虚拟机</h1><p>安装Windows 10虚拟机会出现没有virtio驱动的问题，导致安装程序找不到硬盘，需要先下载virtio驱动。</p>
<p><a target="_blank" rel="noopener" href="https://fedoraproject.org/wiki/Windows_Virtio_Drivers">https://fedoraproject.org/wiki/Windows_Virtio_Drivers</a></p>
<p>创建虚拟机时，将其加入到CD-ROM中</p>
<figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sudo virt-install -n win10</span><br><span class="line"> -<span class="ruby">-description <span class="string">&quot;win10&quot;</span></span></span><br><span class="line"><span class="ruby"></span> -<span class="ruby">-os-type=win --os-variant=win10</span></span><br><span class="line"><span class="ruby"></span> -<span class="ruby">-ram=<span class="number">4096</span> --vcpus=<span class="number">2</span></span></span><br><span class="line"><span class="ruby"></span> -<span class="ruby">-disk path=<span class="regexp">/var/lib</span><span class="regexp">/libvirt/images</span><span class="regexp">/win_10.img,bus=virtio,size=100</span></span></span><br><span class="line"><span class="regexp"><span class="ruby"></span></span> -<span class="ruby"><span class="regexp">-network bridge:br0</span></span></span><br><span class="line"><span class="regexp"><span class="ruby"></span></span> -<span class="ruby"><span class="regexp">-accelerate</span></span></span><br><span class="line"><span class="regexp"><span class="ruby"></span></span> -<span class="ruby"><span class="regexp">-graphics vnc,listen=0.0.0.0,keymap=en-us</span></span></span><br><span class="line"><span class="regexp"><span class="ruby"></span></span> -<span class="ruby"><span class="regexp">-cdrom =/home</span><span class="regexp">/zzy/</span>Downloads/cn_windows_10_consumer_editions_version_1803_updated_march_2018_x64_dvd_12063766.iso</span></span><br><span class="line"><span class="ruby"></span>-<span class="ruby">-cdrom=<span class="regexp">/home/zzy</span><span class="regexp">/Downloads/virtio</span>-win.iso</span></span><br></pre></td></tr></table></figure>

<h1 id="使用VNC客户端连接虚拟机"><a href="#使用VNC客户端连接虚拟机" class="headerlink" title="使用VNC客户端连接虚拟机"></a>使用VNC客户端连接虚拟机</h1><p>执行以下命令查看虚拟机的列表</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">sudo virus list</span></span><br></pre></td></tr></table></figure>
<p>通过上一步查处的虚拟机列表，查看单台机器的VNC端口</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">sudo</span> virsh vncdisplay ubuntu_<span class="number">3</span>  # ubuntu_<span class="number">3</span>是虚拟机名称</span><br></pre></td></tr></table></figure>

<p>知道了VNC端口号，就可以使用VNC客户端连接到虚拟机完成安装了。</p>

        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2018/06/20/wegame-causing-bsod-on-xps-15-9560/">大毒瘤！卸载WeGame解决XPS 15蓝屏问题</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-06-20
        </span><span class="post-category">
            <a href="/categories/Tech/">Tech</a>
            </span>
        </div>
    </header>

    <div class="post-content"><h1 id="潜伏期"><a href="#潜伏期" class="headerlink" title="潜伏期"></a>潜伏期</h1><p>去年4月底买了一台美版XPS 15 9560，用了几个月之后就会偶尔出现蓝屏问题，由于之前就在论坛上看到很多吐槽XPS品控的帖子，以为自己也中了枪，好在蓝屏也不频繁，不影响使用也就没管。</p>
<h1 id="上升期"><a href="#上升期" class="headerlink" title="上升期"></a>上升期</h1><p>进入今年5月，升级了Win10 1803后（基本上软件有更新我都会第一时间升级，体验最新的改进），蓝屏的次数开始多了起来，开始变得影响使用，于是开始着手查找问题。</p>
<p>由于心急，并没有看转储文件，而是直接Google了XPS 15的蓝屏问题，希望能尽快找到方案。很快发现具有类似问题的人不在少数，也有很大一部分人以此说XPS 15品控不好，看了很多内容后，把怀疑的方向放在了驱动层面（Dell有一个Dell Update软件，一有更新提示我就会更新驱动），于是从更新频率最高的显卡驱动入手，降级显卡驱动到上一个版本，然而并没有什么用。于是又降级了Wifi驱动，因为Wifi驱动也是最近更新的，并且XPS 15的Killer显卡兼容性似乎没有那么好。</p>
<p><img src="/upload/20180620_01.png" alt="XPS 15的驱动列表，可以看到Wifi和显卡驱动都是最近发布的"></p>
<p>降级完驱动之后，电脑进入了短暂的回光返照阶段，用了几个小时都没有蓝屏，然而紧接着更加不幸的问题就要发生了。</p>
<h1 id="爆发期"><a href="#爆发期" class="headerlink" title="爆发期"></a>爆发期</h1><p>用QQ接收一个大文件，大概1G，进行到一半的时候忽然蓝屏，重启后重新接收，准备传完之后再解决蓝屏问题，然而不幸的是传了一半又蓝屏了… 这时我把怀疑的方向转向了硬盘，于是降级了Intel RST驱动，心想降级要是没用的话，有可能是SSD跪了… 降级后怀着忐忑的心情再次重试，竟然…又蓝屏了…</p>
<p>这次把怀疑的方向转到了QQ或者Wifi上，毕竟是一用QQ接收大文件就出问题，那么不是QQ就是Wifi了，于是卸载QQ，用迅雷下载一个大文件，果不其然，又跪了…</p>
<p><img src="/upload/20180620_02.png"></p>
<p>然而已经降级了Wifi驱动，之前也一直没有什么问题，难道真的是硬件出了问题？这个时候，我内心已经有点放弃PC，转而在京东上看MBP的价格了…</p>
<p>然而MBP高企的售价让我冷静了下来，回来死马当活马医，继续找问题吧。</p>
<p>既然自己怀疑的方向都不对，只能信仰科学了，安装了WinDbg和BlueScreenView这两款软件来查看和分析转储文件（具体过程不再赘述，可以参考文末的相关资源）。</p>
<p><img src="/upload/20180620_03.jpeg" alt="从BlueScreenView里可以看到，机器以近乎疯狂的频率蓝屏"></p>
<p>从BlueScreenView里并没有看到太多信息，现在只剩下WinDbg这一根救命稻草了。</p>
<p><img src="/upload/20180620_04.jpeg"></p>
<p>不过好在WinDbg非常给力，分析了几个不同时间的转储文件，都提示问题可能是由tdx.sys文件造成的。</p>
<p><img src="/upload/20180620_05.png"></p>
<p>tdx是TDI Translation Driver的意思，TDI是传输层驱动接口的意思，那么可以肯定问题来自于网络，这也印证了每次使用网络传输大文件就会蓝屏的现象。紧接着，看到了另外一段话：</p>
<blockquote>
<p>WARNING: Unable to verify timestamp for QMTgpNetFlow764.sys</p>
</blockquote>
<p>这个QMTgpNetFlow764.sys又是什么，看前缀似乎像第三方的文件，先Google一下。</p>
<h1 id="真相大白"><a href="#真相大白" class="headerlink" title="真相大白"></a>真相大白</h1><p>Google了一下这个QMTgpNetFlow764.sys，终于拨云见日。</p>
<p><img src="/upload/20180620_06.png" alt="原来早有人发现了QMTgpNetFlow764.sys引发蓝屏问题的秘密"></p>
<p>根据网友们的分析（具体可以查看文末的相关资源），这5个文件来自于腾讯的游戏平台WeGame，于是卸载了腾讯系的游戏，并且重启删除了C:\Windows\system32\drivers目录下以QMT开头的5个文件，没关机使用至今（大约半个月）再也没有出现过蓝屏的情况，至此可以证明，腾讯WeGame平台是引起蓝屏的主要原因。</p>
<p><img src="/upload/20180620_07.png" alt="毒瘤们"></p>
<h1 id="相关资源"><a href="#相关资源" class="headerlink" title="相关资源"></a>相关资源</h1><p>BlueScreenView下载地址：<a target="_blank" rel="noopener" href="https://www.nirsoft.net/utils/blue_screen_view.html">https://www.nirsoft.net/utils/blue_screen_view.html</a></p>
<p>WinDbg下载地址：<a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/debugger-download-tools">https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/debugger-download-tools</a></p>
<p>WinDbg使用说明：<a target="_blank" rel="noopener" href="https://jingyan.baidu.com/article/9f7e7ec0b0aea36f281554df.html">https://jingyan.baidu.com/article/9f7e7ec0b0aea36f281554df.html</a></p>
<p>知乎用户<a target="_blank" rel="noopener" href="https://www.zhihu.com/people/weasley-frank">Weasley Frank</a>的专栏文章<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/33723838">TGP/WeGame驱动导致WSL网络服务异常
</a>对这个问题进行了简单分析</p>

        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2018/06/11/things-you-dont-know-about-python/">你所不知道的Python | 字符串格式化的演进之路</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-06-11
        </span><span class="post-category">
            <a href="/categories/Python/">Python</a>
            </span>
        </div>
    </header>

    <div class="post-content"><p><img src="/upload/20180611_01.jpg"></p>
<p>字符串格式化对于每个语言来说都是一个非常基础和常用的功能，学习Python的同学大概都知道可以用%语法来格式化字符串。然而为了让我们更方便的使用这个常用功能，语言本身也在对字符串格式化方法进行迭代。</p>
<h1 id="Python-2-6以前：-操作符"><a href="#Python-2-6以前：-操作符" class="headerlink" title="Python 2.6以前：%操作符"></a>Python 2.6以前：%操作符</h1><p>在Python 2.6出现之前，字符串迭代只有一种方法，就是%（也是取模）操作符，%操作符支持unicode和str类型的Python字符串，效果和C语言中的sprintf()方法相似，下面是一个使用%格式化字符串的例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;I&#x27;m %s. I&#x27;m %d year old&quot;</span> % (<span class="string">&#x27;Tom&#x27;</span>, <span class="number">27</span>))</span><br></pre></td></tr></table></figure>

<p>%符号前面使用一个字符串作为模板，模板中有标记格式的占位符号，%后面是一个tuple或者dict，用来传递需要格式化的值。占位符控制着显示的格式，下面列表展示了占位符的种类：</p>
<table>
<thead>
<tr>
<th>占位符</th>
<th>内容</th>
</tr>
</thead>
<tbody><tr>
<td>%d</td>
<td>十进制整数</td>
</tr>
<tr>
<td>%i</td>
<td>十进制整数</td>
</tr>
<tr>
<td>%o</td>
<td>八进制整数</td>
</tr>
<tr>
<td>%u</td>
<td>无符号整数</td>
</tr>
<tr>
<td>%x</td>
<td>无符号十六进制（小写）</td>
</tr>
<tr>
<td>%X</td>
<td>无符号十六进制（大写）</td>
</tr>
<tr>
<td>%e</td>
<td>浮点型（科学记数法，小写）</td>
</tr>
<tr>
<td>%E</td>
<td>浮点型（科学记数法，大写）</td>
</tr>
<tr>
<td>%f</td>
<td>浮点数</td>
</tr>
<tr>
<td>%F</td>
<td>浮点数</td>
</tr>
<tr>
<td>%g</td>
<td>浮点型，如果小数位数超过4位，使用科学记数法表示（小写）</td>
</tr>
<tr>
<td>%G</td>
<td>浮点型，如果小数位数超过4位，使用科学记数法表示（大写）</td>
</tr>
<tr>
<td>%c</td>
<td>单个字符</td>
</tr>
<tr>
<td>%r</td>
<td>字符串（调用repr()方法生成）</td>
</tr>
<tr>
<td>%s</td>
<td>字符串（调用str()方法生成）</td>
</tr>
</tbody></table>
<p>除了对数据类型的指定，%操作符还支持更复杂的格式控制：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%<span class="selector-attr">[数据名称]</span><span class="selector-attr">[对齐标志]</span><span class="selector-attr">[宽度]</span>.<span class="selector-attr">[精度]</span>类型</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>名称</th>
<th>内容</th>
</tr>
</thead>
<tbody><tr>
<td>数据名称</td>
<td>数据名称用于字典赋值，如果%符号后面传递的数组就不需要填写了</td>
</tr>
<tr>
<td>对齐标志</td>
<td>有+、-、0、‘ ’四种，+表示显示正负数符号，-表示左对齐，空格表示在左侧填充一个空格，0表示用0填充</td>
</tr>
<tr>
<td>宽度</td>
<td>表示格式化后的字符串长度，位数不足用0或空格补齐</td>
</tr>
<tr>
<td>精度</td>
<td>小数点后的位数</td>
</tr>
<tr>
<td>类型</td>
<td>数据类型（参考占位符种类）</td>
</tr>
</tbody></table>
<p>例如print(‘%053f’ % ‘12.34’)会输出0012.340</p>
<h1 id="Python-2-6：format函数"><a href="#Python-2-6：format函数" class="headerlink" title="Python 2.6：format函数"></a>Python 2.6：format函数</h1><p>到Python2.6时，出现了一种新的字符串格式化方式，str.format()函数，相比于%操作符，format函数使用{}和:代替了%，威力更加强大，在映射关系方面，format函数支持位置映射、关键字映射、对象属性映射、下标映射等多种方式，不仅参数可以不按顺序，也可以不用参数或者一个参数使用多次，下面通过几个例子来说明。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#123;1&#125; &#123;0&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="string">&#x27;abc&#x27;</span>, <span class="number">123</span>)  <span class="comment"># 可以不按顺序进行位置映射，输出&#x27;123 abc&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#123;&#125; &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="string">&#x27;abc&#x27;</span>, <span class="number">123</span>)  <span class="comment"># 可以不指定参数名称，输出&#x27;abc 123&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#123;1&#125; &#123;0&#125; &#123;1&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="string">&#x27;abc&#x27;</span>, <span class="number">123</span>)  <span class="comment"># 参数可以使用多次，输出&#x27;123 abc 123&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#123;name&#125; &#123;age&#125;&#x27;</span>.<span class="built_in">format</span>(name=<span class="string">&#x27;tom&#x27;</span>, age=<span class="number">27</span>)  <span class="comment"># 可以按关键字映射，输出&#x27;tom 27&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#123;person.name&#125; &#123;person.age&#125;&#x27;</span>.<span class="built_in">format</span>(person=person)  <span class="comment"># 可以按对象属性映射，输出&#x27;tom 27&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#123;0[1]&#125; &#123;0[0]&#125;&#x27;</span>.<span class="built_in">format</span>(lst)  <span class="comment"># 通过下标映射</span></span><br></pre></td></tr></table></figure>

<p>可以看到，format函数比%操作符使用起来更加方便，不需要记住太多各种占位符代表的意义，代码可读性也更高。在复杂格式控制方面，format函数也提供了更加强大的控制方式：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[填充字符]对齐方式][符号标志][#][宽度][,][.精度][类型]</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#123;:S^+#016,.2f&#125;&#x27;</span>.format(<span class="number">1234</span>)  <span class="meta"># 输出<span class="string">&#x27;SSS+1,234.00SSSS&#x27;</span></span></span><br></pre></td></tr></table></figure>

<p>我们以上面的代码为例，通过表格说明一下format格式控制参数：</p>
<table>
<thead>
<tr>
<th align="left">类型</th>
<th>说明</th>
<th>示例说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">填充字符</td>
<td>不填时默认用空格填充</td>
<td>S表示用S填充</td>
</tr>
<tr>
<td align="left">对齐方式</td>
<td>^表示居中对齐、&lt;表示左对齐、&gt;表示右对齐</td>
<td>^表示居中对齐，左右位数不足部分会用填充字符填充</td>
</tr>
<tr>
<td align="left">符号标志</td>
<td>+表示有符号（正数前显示+，负数前显示-），空格表示整数前加一个空格以和负数对齐</td>
<td>+表示正数前显示空格</td>
</tr>
<tr>
<td align="left">#</td>
<td>表示是否在二进制、八进制、十六进制前显示0b、0o、0x等符号</td>
<td>#表示显示进制符号，由于是十进制，所以不显示</td>
</tr>
<tr>
<td align="left">宽度</td>
<td>表示输出字符串的宽度</td>
<td>16表示字符串宽度为16，不足部分会补齐</td>
</tr>
<tr>
<td align="left">,</td>
<td>表示使用,作为千位分隔符</td>
<td>,表示使用千位分隔符</td>
</tr>
<tr>
<td align="left">精度</td>
<td>表示小数点后数字位数</td>
<td>.2表示精度为2为</td>
</tr>
<tr>
<td align="left">类型</td>
<td>s表示字符串类型，c表示字符类型，b\o\d分别表示二八十进制，x\X表示小写和大写十六进制，e\E表示小写和大写的科学记数法，f表示浮点型</td>
<td>f表示浮点型数字</td>
</tr>
</tbody></table>
<p>可以看到format函数在%基础上丰富了格式控制种类，并且使输出更容易。</p>
<h1 id="Python-3-6：f-string"><a href="#Python-3-6：f-string" class="headerlink" title="Python 3.6：f-string"></a>Python 3.6：f-string</h1><p>不少使用过ES6的小伙伴会知道其中的模板字符串，采用直接在字符串中内嵌变量的方式进行字符串格式化操作，Python在3.6版本中也为我们带来了类似的功能：Formatted String Literals（字面量格式化字符串），简称f-string。</p>
<p>f-string就是以f’’开头的字符串，类似u’’和b’’，字符串内容和format方法中的格式一样，但是可以直接将变量带入到字符串中，可读性进一步增加，例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">amount = <span class="number">1234</span></span><br><span class="line"><span class="string">f&#x27;请转账给我<span class="subst">&#123;amount:,<span class="number">.2</span>f&#125;</span>元&#x27;</span>  <span class="comment"># &#x27;请转账给我1,234.00元&#x27;</span></span><br></pre></td></tr></table></figure>

<p>同时，f-string的性能是比%和format都有提升的，我们做一个简单的测试，分别使用%操作符、format和f-string将下面语句执行10000次：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;My name is %s and i&#x27;</span>m %s years old.<span class="string">&#x27; % (name, age)</span></span><br><span class="line"><span class="string">&#x27;</span>My name <span class="keyword">is</span> &#123;&#125; <span class="keyword">and</span> i<span class="string">&#x27;m &#123;&#125; years old.&#x27;</span>.<span class="built_in">format</span>(name, age)</span><br><span class="line"><span class="string">f&#x27;My name is <span class="subst">&#123;name&#125;</span> and i&#x27;</span>m &#123;age&#125; years old.<span class="string">&#x27;</span></span><br></pre></td></tr></table></figure>

<p>用时结果如下：</p>
<p><img src="/upload/20180611_02.png"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>如果你的项目使用的Python版本已经提升到3.6，f-string格式化是首选方式，不仅在保持功能强大的同时语义上更容易理解，而且性能也有较大的提升。如果项目还没有提升到3.6或者使用的2.7，更建议使用format，虽然性能上没有优势，但是语义上还是比%操作符更加便于理解的，功能也更加强大。</p>

        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2018/05/31/python-cheat-sheet/">初学者必备 | Python Cheat Sheet 中文版</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-05-31
        </span><span class="post-category">
            <a href="/categories/Python/">Python</a>
            </span>
        </div>
    </header>

    <div class="post-content"><p>笔者整理了Python3中内置方法的速查表，包含：</p>
<ul>
<li>内置方法</li>
<li>列表处理方法</li>
<li>字典处理方法</li>
<li>元组处理方法</li>
<li>集合处理方法</li>
<li>序列类型的切片方法</li>
</ul>
<p>共计100多个方法，点击图片——查看原图——下载。</p>
<p><img src="/upload/20180531_01.jpg"></p>

        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2018/05/22/four-types-of-queue-in-python/">简析Python中的四种队列</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-05-22
        </span><span class="post-category">
            <a href="/categories/Python/">Python</a>
            </span>
        </div>
    </header>

    <div class="post-content"><p>队列是一种只允许在一端进行插入操作，而在另一端进行删除操作的线性表。</p>
<p>在Python文档中搜索队列（queue）会发现，Python标准库中包含了四种队列，分别是queue.Queue / asyncio.Queue / multiprocessing.Queue / collections.deque。</p>
<h1 id="collections-deque"><a href="#collections-deque" class="headerlink" title="collections.deque"></a>collections.deque</h1><p>deque是双端队列（double-ended queue）的缩写，由于两端都能编辑，deque既可以用来实现栈（stack）也可以用来实现队列（queue）。</p>
<p>deque支持丰富的操作方法，主要方法如图：</p>
<p><img src="/upload/20180522_01.jpg"></p>
<p>相比于list实现的队列，deque实现拥有更低的时间和空间复杂度。list实现在出队（pop）和插入（insert）时的空间复杂度大约为O(n)，deque在出队（pop）和入队（append）时的时间复杂度是O(1)。</p>
<p>deque也支持in操作符，可以使用如下写法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">q = collections.deque([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="number">5</span> <span class="keyword">in</span> q)  <span class="comment"># False</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">1</span> <span class="keyword">in</span> q)  <span class="comment"># True</span></span><br></pre></td></tr></table></figure>

<p>deque还封装了顺逆时针的旋转的方法：rotate。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 顺时针</span></span><br><span class="line">q = collections.deque([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line">q.rotate(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(q)  <span class="comment"># [4, 1, 2, 3]</span></span><br><span class="line">q.rotate(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(q)  <span class="comment"># [3, 4, 1, 2]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 逆时针</span></span><br><span class="line">q = collections.deque([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line">q.rotate(-<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(q)  <span class="comment"># [2, 3, 4, 1]</span></span><br><span class="line">q.rotate(-<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(q)  <span class="comment"># [3, 4, 1, 2]</span></span><br></pre></td></tr></table></figure>

<p>线程安全方面，通过查看collections.deque中的append()、pop()等方法的源码可以知道，他们都是原子操作，所以是GIL保护下的线程安全方法。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> PyObject *</span></span><br><span class="line"><span class="function"><span class="title">deque_append</span><span class="params">(dequeobject *<span class="built_in">deque</span>, PyObject *item)</span> </span>&#123; </span><br><span class="line">    Py_INCREF(item);</span><br><span class="line">    <span class="keyword">if</span> (deque_append_internal(<span class="built_in">deque</span>, item, <span class="built_in">deque</span>-&gt;maxlen) &lt; <span class="number">0</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    Py_RETURN_NONE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过dis方法可以看到，append是原子操作（一行字节码）。</p>
<p><img src="/upload/20180522_02.png"></p>
<p> 综上，collections.deque是一个可以方便实现队列的数据结构，具有线程安全的特性，并且有很高的性能。</p>
<h1 id="queue-Queue-amp-asyncio-Queue"><a href="#queue-Queue-amp-asyncio-Queue" class="headerlink" title="queue.Queue &amp; asyncio.Queue"></a>queue.Queue &amp; asyncio.Queue</h1><p>queue.Queue和asyncio.Queue都是支持多生产者、多消费者的队列，基于collections.deque，他们都提供了Queue（FIFO队列）、PriorityQueue（优先级队列）、LifoQueue（LIFO队列），接口方面也相同。</p>
<p>区别在于queue.Queue适用于多线程的场景，asyncio.Queue适用于协程场景下的通信，由于asyncio的加成，queue.Queue下的阻塞接口在asyncio.Queue中则是以返回协程对象的方式执行，具体差异如下表：</p>
<table>
<thead>
<tr>
<th></th>
<th>queue.Queue</th>
<th>asyncio.Queue</th>
</tr>
</thead>
<tbody><tr>
<td>介绍</td>
<td>同步队列</td>
<td>asyncio队列</td>
</tr>
<tr>
<td>线程安全</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>超时机制</td>
<td>通过timeout参数实现</td>
<td>通过asyncio.wait_for()方法实现</td>
</tr>
<tr>
<td>qsize()</td>
<td>预估的队列长度（获取qsize到下一个操作之间，queue有可能被其它的线程修改，导致qsize大小发生变化）</td>
<td>准确的队列长度（由于是单线程，所以queue不会被其它线程修改）</td>
</tr>
<tr>
<td>put() / set()</td>
<td>put(item, block=True, timeout=None)，可以通过设置block是否为True来配置put和set方法是否为阻塞，并且可以为阻塞操作设置最大时长timeout，block为False时行为和put_nowait()方法一致。</td>
<td>put()方法会返回一个协程对象，所以没有block参数和timeout参数，如果需要非阻塞方法，可以使用put_nowait()，如果需要对阻塞方法应用超时，可以使用coroutine asyncio.wait_for()。</td>
</tr>
</tbody></table>
<h1 id="multiprocessing-Queue"><a href="#multiprocessing-Queue" class="headerlink" title="multiprocessing.Queue"></a>multiprocessing.Queue</h1><p>multiprocessing提供了三种队列，分别是Queue、SimpleQueue、JoinableQueue。</p>
<p><img src="/upload/20180522_03.png"></p>
<p>multiprocessing.Queue既是线程安全也是进程安全的，相当于queue.Queue的多进程克隆版。和threading.Queue很像，multiprocessing.Queue支持put和get操作，底层结构是multiprocessing.Pipe。</p>
<p>multiprocessing.Queue底层是基于Pipe构建的，但是数据传递时并不是直接写入Pipe，而是写入进程本地buffer，通过一个feeder线程写入底层Pipe，这样做是为了实现超时控制和非阻塞put/get，所以Queue提供了join_thread、cancel_join_thread、close函数来控制feeder的行为，close函数用来关闭feeder线程、join_thread用来join feeder线程，cancel_join_thread用来在控制在进程退出时，不自动join feeder线程，使用cancel_join_thread有可能导致部分数据没有被feeder写入Pipe而导致的数据丢失。</p>
<p>和threading.Queue不同的是，multiprocessing.Queue默认不支持join()和task_done操作，这两个支持需要使用mp.JoinableQueue对象。</p>
<p>SimpleQueue是一个简化的队列，去掉了Queue中的buffer，没有了使用Queue可能出现的问题，但是put和get方法都是阻塞的并且没有超时控制。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过对比可以发现，上述四种结构都实现了队列，但是用处却各有偏重，collections.deque在数据结构层面实现了队列，但是并没有应用场景方面的支持，可以看做是一个基础的数据结构。queue模块实现了面向多生产线程、多消费线程的队列，asyncio.queue模块则实现了面向多生产协程、多消费协程的队列，而multiprocessing.queue模块实现了面向多成产进程、多消费进程的队列。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a target="_blank" rel="noopener" href="https://docs.python.org/3/library/collections.html#collections.deque">https://docs.python.org/3/library/collections.html#collections.deque</a><br><a target="_blank" rel="noopener" href="https://docs.python.org/3/library/queue.html?highlight=queue#module-queue">https://docs.python.org/3/library/queue.html</a><br><a target="_blank" rel="noopener" href="https://docs.python.org/3/library/asyncio-queue.html?highlight=queue">https://docs.python.org/3/library/asyncio-queue.html</a><br><a target="_blank" rel="noopener" href="https://docs.python.org/3/library/multiprocessing.html#multiprocessing.Queue">https://docs.python.org/3/library/multiprocessing.html#multiprocessing.Queue</a><br><a target="_blank" rel="noopener" href="https://bugs.python.org/issue15329">https://bugs.python.org/issue15329</a><br><a target="_blank" rel="noopener" href="http://blog.ftofficer.com/2009/12/python-multiprocessing-3-about-queue/">http://blog.ftofficer.com/2009/12/python-multiprocessing-3-about-queue/</a><br><a target="_blank" rel="noopener" href="http://cyrusin.github.io/2016/04/27/python-gil-implementaion/">http://cyrusin.github.io/2016/04/27/python-gil-implementaion/</a></p>

        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2018/05/07/right-way-to-use-assert-in-python/">你真的会正确使用断言吗？</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-05-07
        </span><span class="post-category">
            <a href="/categories/Python/">Python</a>
            </span>
        </div>
    </header>

    <div class="post-content"><p><img src="/upload/20180507_01.jpg"></p>
<h1 id="什么是断言"><a href="#什么是断言" class="headerlink" title="什么是断言"></a>什么是断言</h1><p>断言是作为一种调试工具被发明出来的，用来检查那些“代码写对了就肯定成立”的条件。例如我们要断言一个变量a必须要大于2，就可以这样写：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assert</span> a &gt; <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>当条件不满足时，就会抛出AssertionError异常，等同于如下代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> assert_condition:</span><br><span class="line">    <span class="keyword">raise</span> AssertionError</span><br></pre></td></tr></table></figure>

<p>由于断言是一个debug工具，Python的实现也符合这个设计哲学，在Python中assert语句的执行是依赖于<code>__debug__</code>变量的，当<code>__debug__</code>为true时，assert语句才会被执行。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="literal">__debug__</span> <span class="keyword">and</span> <span class="keyword">not</span> assert_condition:</span><br><span class="line">    <span class="keyword">raise</span> AssertionError</span><br></pre></td></tr></table></figure>

<p>默认情况下，当我们执行一个Python文件时，<code>__debug__</code>是会被设置为True的，只有加参数-O或-OO时，<code>__debug__</code>才会被设置为False。</p>
<p>新建一个assert.py文件，写下如下代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="literal">__debug__</span>)</span><br><span class="line"><span class="keyword">assert</span> <span class="number">2</span> &gt; <span class="number">5</span></span><br></pre></td></tr></table></figure>

<p>当使用python assert.py运行时，<code>__debug__</code>会输出True，assert 2 &gt; 5语句会抛出AssertionError异常。</p>
<p>当使用python -O assert.py运行时，<code>__debug__</code>会输出False，assert 2 &gt; 5语句由于没有执行不会报任何异常。</p>
<h1 id="断言-or-异常"><a href="#断言-or-异常" class="headerlink" title="断言 or 异常"></a>断言 or 异常</h1><p>我们思考这几个问题：断言应该用在哪些情境下？异常和断言的区别是什么？</p>
<p>用一句话来概括断言的使用场景和与异常的区别：</p>
<blockquote>
<p>检查先验条件使用断言，检查后验条件使用异常</p>
</blockquote>
<p>我们定义一个read_file函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_file</span>(<span class="params">file_path</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p>read_file函数要求在开始执行的时候满足一定条件：file_path必须是str类型，这个条件就是先验条件，如果不满足，就不能调用这个函数，如果真的出现了不满足条件的情况，证明代码中出现了bug，这时候我们就可以使用assert语句来对file_path的类型进行推断，提醒程序员修改代码，这样的推断在生产环境中是不需要的，也可以使用if + raise语句来实现assert，但是要繁琐很多。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_file</span>(<span class="params">file_path</span>):</span></span><br><span class="line">    <span class="keyword">assert</span> is_instance(file_path, <span class="built_in">str</span>)</span><br></pre></td></tr></table></figure>

<p>read_file函数在被调用执行后，依然需要满足一定条件，比如file_path所指定的文件需要是存在的，并且当前用户有权限读取该文件，这些条件称为后验条件，对于后验条件的检查，我们需要使用异常来处理。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_file</span>(<span class="params">file_path</span>):</span></span><br><span class="line">    <span class="keyword">assert</span> is_instance(file_path, <span class="built_in">str</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> check_exist(file_path):</span><br><span class="line">        <span class="keyword">raise</span> NotFoundError()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> has_privilege(file_path):</span><br><span class="line">        <span class="keyword">raise</span> PermissionError()</span><br></pre></td></tr></table></figure>

<p>文件不存在和没有权限，这两种情况并不属于代码bug，是代码逻辑的一部分，上层代码捕获异常后可能会执行其他逻辑，因此我们不能接受这部分代码在生产环境中被忽略。并且，相比于assert语句只能抛出AssertionError，使用异常可以抛出更细致的错误，方便上层代码针对不同错误执行不同的逻辑。</p>

        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2018/04/26/using-decorators-to-validate-form/">用装饰器封装Flask-WTF表单验证逻辑</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-04-26
        </span><span class="post-category">
            <a href="/categories/Python/">Python</a>
            </span>
        </div>
    </header>

    <div class="post-content"><blockquote>
<p>Don’t repeat yourself</p>
</blockquote>
<p>在使用Flask-WTF的时候，常会用下面这样的代码来验证表单数据的合法性：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span>, methods=[<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;POST&#x27;</span>]</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>():</span></span><br><span class="line">	form = TestForm()</span><br><span class="line">	<span class="comment"># 判断是否合法</span></span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> form.validate_on_submit():</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&#x27;err&#x27;</span>, <span class="number">400</span></span><br><span class="line">	<span class="comment"># 主要逻辑</span></span><br></pre></td></tr></table></figure>

<p>对于有很多提交接口的项目来说，需要在每个路由下写相同的的逻辑，造成了大量的代码重复。在Flask-Login中，要把一个路由设置为登录后才能访问，只需要在路由上加一个@login_required装饰器，不需要额外的代码。能不能像Flask-Login一样，用装饰器来封装对表单的验证逻辑呢？</p>
<h1 id="实现表单验证装饰器"><a href="#实现表单验证装饰器" class="headerlink" title="实现表单验证装饰器"></a>实现表单验证装饰器</h1><p>由于不同路由使用的表单类不一样，所以需要为装饰器传入一个表单类参数，并且在路由函数中需要用到表单中的值，所以还需要将验证通过的表单传给路由函数。</p>
<p>上代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">validate_form</span>(<span class="params">self, form_cls</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorator</span>(<span class="params">fn</span>):</span></span><br><span class="line"><span class="meta">        @wraps(<span class="params">fn</span>)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> form.validate_on_submit():</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&#x27;error&#x27;</span>, <span class="number">400</span></span><br><span class="line">            <span class="keyword">return</span> fn(form, *args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line">    <span class="keyword">return</span> decorator</span><br></pre></td></tr></table></figure>

<p>使用方式如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@validate_form(<span class="params">TestForm</span>)  </span><span class="comment"># 需要传入要验证的表单类</span></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/&#x27;</span>, methods=[<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;POST&#x27;</span>]</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>(<span class="params">form</span>):</span></span><br><span class="line">    <span class="comment"># 执行到这里说明表单验证通过</span></span><br></pre></td></tr></table></figure>

<p>经过在项目中的应用，发现装饰器还是有一些缺陷：</p>
<ul>
<li>无法自定义处理非法表单的逻辑</li>
<li>不支持get方式提交的表单（查看validate_on_submit()源码可知其只支持对post和put方式提交的表单进行验证）</li>
</ul>
<h1 id="丰富一下"><a href="#丰富一下" class="headerlink" title="丰富一下"></a>丰富一下</h1><p>要自定义处理非法表单的逻辑，需要增加一个可以传入自定义逻辑的接口。表单非法时接口的返回往往是一致的，所以我们为所有应用装饰器的路由传入一个统一的处理逻辑。将装饰器封装在一个类中，在类中添加一个配置处理逻辑的方法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> request</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FormValidator</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, error_handler=<span class="literal">None</span></span>):</span></span><br><span class="line">        self._error_handler = error_handler</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validate_form</span>(<span class="params">self, form_cls</span>):</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">decorator</span>(<span class="params">fn</span>):</span></span><br><span class="line"><span class="meta">            @wraps(<span class="params">fn</span>)</span></span><br><span class="line">            <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> form.validate_on_submit() <span class="keyword">and</span> self._error_handler:</span><br><span class="line">                    <span class="keyword">return</span> self._error_handler(form.errors)</span><br><span class="line">                <span class="keyword">return</span> fn(form, *args, **kwargs)</span><br><span class="line">            <span class="keyword">return</span> wrapper</span><br><span class="line">        <span class="keyword">return</span> decorator</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">error_handler</span>(<span class="params">self, fn</span>):</span></span><br><span class="line">        self._error_handler = fn</span><br><span class="line">        <span class="keyword">return</span> fn</span><br></pre></td></tr></table></figure>

<p>error_handler也是一个装饰器，被它修饰的方法就是处理非法表单的方法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@form_validator.error_handler</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">error_handler</span>(<span class="params">errors</span>):</span></span><br><span class="line">    <span class="keyword">return</span> jsonify(&#123;<span class="string">&#x27;errors&#x27;</span>: errors&#125;), <span class="number">400</span></span><br></pre></td></tr></table></figure>

<p>接下来支持get方法，在flask中，我们可以通过request.args来获取到get方法提交的参数。思路是用获取到的参数生成一个表单类的实例，然后就可以通过调用表单类的validate()方法来判断是否合法了。修改validate_form装饰器：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">validate_form</span>(<span class="params">self, form_cls</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorator</span>(<span class="params">fn</span>):</span></span><br><span class="line"><span class="meta">        @wraps(<span class="params">fn</span>)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">            <span class="keyword">if</span> request.method == <span class="string">&#x27;GET&#x27;</span>:</span><br><span class="line">                form = form_cls(formdata=request.args)</span><br><span class="line">            <span class="keyword">elif</span> request.method <span class="keyword">in</span> (<span class="string">&#x27;POST&#x27;</span>, <span class="string">&#x27;PUT&#x27;</span>):</span><br><span class="line">                form = form_cls()</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> fn(*args, **kwargs)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> form.validate() <span class="keyword">and</span> self._error_handler:</span><br><span class="line">                <span class="keyword">return</span> self._error_handler(form.errors)</span><br><span class="line">            <span class="keyword">return</span> fn(form, *args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line">    <span class="keyword">return</span> decorator</span><br></pre></td></tr></table></figure>

<p>大功告成！使用上面的装饰器，就可以免除在路由函数中重复写表单验证逻辑，并且同时支持put、post和get方法提交的表单。</p>
<h1 id="开箱即用"><a href="#开箱即用" class="headerlink" title="开箱即用"></a>开箱即用</h1><p>笔者已经把上面的代码封装成了一个库发布到了PyPI，想直接用的朋友可以使用<code>pip install flask-wtf-decorators</code>安装，项目源码也已经发布到Github。</p>
<p><a target="_blank" rel="noopener" href="https://pypi.org/project/Flask-WTF-Decorators/">查看PyPI</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/simpleapples/flask-wtf-decorators">查看Github</a></p>

        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2018/04/22/python-parameter-passing/">Python参数传递，既不是传值也不是传引用</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-04-22
        </span><span class="post-category">
            <a href="/categories/Python/">Python</a>
            </span>
        </div>
    </header>

    <div class="post-content"><p><img src="/upload/20180422_01.png"></p>
<p>面试的时候，有没有被问到Python传参是传引用还是传值这种问题？有没有听到过Python传参既不是传值也不是传引用这种说法？一个小小的参数默认值也可能让代码出现难以查找的bug？</p>
<p>如果你也遇到过上面的问题，不妨我们来探究下Python函数传递的种种。</p>
<h1 id="万物皆对象"><a href="#万物皆对象" class="headerlink" title="万物皆对象"></a>万物皆对象</h1><p>Python中有一个非常重要的概念——万物皆对象，无论是一个数字、字符串，还是数组、字典，在Python中都会以一个对象的形式存在。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">123</span></span><br></pre></td></tr></table></figure>

<p>对于上面这行代码，在Python看来就是创建一个PyObject对象，值为123，然后定义一个指针a，a指向这个PyObject对象。</p>
<h1 id="可变对象和不可变对象"><a href="#可变对象和不可变对象" class="headerlink" title="可变对象和不可变对象"></a>可变对象和不可变对象</h1><p>Python中的对象分为两种类型，可变对象和不可变对象，不可变对象指tuple、str、int等类型的对象，可变对象指的是dict、list、自定义对象等类型的对象，我们用一段代码说明他们的区别。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(a))  <span class="comment"># 2587116690248</span></span><br><span class="line">a += [<span class="number">4</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(a)) <span class="comment"># 2587116690248</span></span><br><span class="line"></span><br><span class="line">b = <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(b)) <span class="comment"># 2006430784</span></span><br><span class="line">b += <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(b)) <span class="comment"># 2006430816</span></span><br></pre></td></tr></table></figure>

<p>上面代码中我们分别定义了一个可变对象和一个不可变对象，并且对他们进行修改，打印修改前后的对象标识可以发现，对可变对象进行修改，变量对其引用不会发生变化，对不可变对象进行修改，变量引用发生了变化。</p>
<p><img src="/upload/20180422_02.png" alt="可变对象的引用"></p>
<p>上图是一个可变对象，当修改对象时，例如删除数组中的一个元素，实际上把其中一个元素从对象中移除，对象本身的标识是不发生变化的。</p>
<p><img src="/upload/20180422_03.png" alt="不可变对象的引用"></p>
<p>改变一个不可变对象时，例如给一个int型加2，语法上看上去是直接修改了i这个对象，但是如前面所说，i只是一个指向对象73的一个变量，Python会将这个变量指向的对象加2后，生成一个新的对象，然后再让i指向这个新的对象。</p>
<h1 id="参数传递时的表现"><a href="#参数传递时的表现" class="headerlink" title="参数传递时的表现"></a>参数传递时的表现</h1><p>了解了对象的原理后，我们就可以来尝试理解一下参数传递时他们的不同表现了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(a))  <span class="comment"># 1437494204232</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mutable</span>(<span class="params">a</span>):</span></span><br><span class="line">	<span class="built_in">print</span>(<span class="built_in">id</span>(a))  <span class="comment"># 1437494204232</span></span><br><span class="line">	a += [<span class="number">4</span>]</span><br><span class="line">	<span class="built_in">print</span>(<span class="built_in">id</span>(a))  <span class="comment"># 1437494204232</span></span><br><span class="line">mutable(a)</span><br><span class="line"></span><br><span class="line">b = <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(b))  <span class="comment"># 2006430784</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">immutable</span>(<span class="params">b</span>):</span></span><br><span class="line">	<span class="built_in">print</span>(<span class="built_in">id</span>(b))  <span class="comment"># 2006430784</span></span><br><span class="line">	b += <span class="number">1</span></span><br><span class="line">	<span class="built_in">print</span>(<span class="built_in">id</span>(b))  <span class="comment"># 2006430816</span></span><br><span class="line">immutable(b)</span><br></pre></td></tr></table></figure>

<p>通过上面的代码可以看出，修改传进的可变参数时，会对外部对象产生影响，修改不可变参数时则不会影响。</p>
<p><strong>概括地说，Python参数传递时，既不是传对象也不是传引用，之所以会有上述的区别，跟Python的对象机制有关，参数传递只是给对象绑定了一个新的变量（实际上是传递C中的指针）。</strong></p>
<h1 id="参数传递时的坑"><a href="#参数传递时的坑" class="headerlink" title="参数传递时的坑"></a>参数传递时的坑</h1><p>理解了参数传递的逻辑，我们需要注意一下这种逻辑可能引发的问题。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>(<span class="params">b=[]</span>):</span></span><br><span class="line">	b += [<span class="number">1</span>]</span><br><span class="line">	<span class="built_in">print</span>(b)</span><br><span class="line"></span><br><span class="line">test()  <span class="comment"># [1]</span></span><br><span class="line">test()  <span class="comment"># [1, 1]</span></span><br><span class="line">test()  <span class="comment"># [1, 1, 1]</span></span><br></pre></td></tr></table></figure>

<p>上面的代码的输出，按照可变对象传参的逻辑，应该每次调用都输出[1]才对，而实际输出看上去好像默认参数好像只生效了一次。原因在于Python的函数也是对象（万物皆对象），这个对象只初始化一次，加上参数又是不可变对象，所以每次调用实际上都修改的是一个对象。</p>
<p>解决这个问题，推荐再参数传递可变对象时，默认值设置为None，在函数内部对None进行判断后再赋予默认值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>(<span class="params">b=<span class="literal">None</span></span>):</span></span><br><span class="line">	b = b <span class="keyword">or</span> []</span><br><span class="line">	b += [<span class="number">1</span>]</span><br><span class="line">	<span class="built_in">print</span>(b)</span><br><span class="line"></span><br><span class="line">test()  <span class="comment"># [1]</span></span><br><span class="line">test()  <span class="comment"># [1]</span></span><br><span class="line">test()  <span class="comment"># [1]</span></span><br></pre></td></tr></table></figure>

<p>再看一段代码。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>(<span class="params">a=i</span>):</span></span><br><span class="line">	<span class="built_in">print</span>(a)</span><br><span class="line"></span><br><span class="line">i = <span class="number">2</span></span><br><span class="line">test()  <span class="comment"># 1</span></span><br></pre></td></tr></table></figure>

<p>由于参数默认值是在函数定义时而不是函数执行时确定的，所以这段代码test方法的参数默认值时1而不是2。</p>

        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2018/04/10/a-crawler-based-on-aiohttp-and-uvloop/">实战 | 用aiohttp和uvloop实现一个高性能爬虫</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-04-10
        </span><span class="post-category">
            <a href="/categories/Python/">Python</a>
            </span>
        </div>
    </header>

    <div class="post-content"><p>asyncio于Python3.4引入标准库，增加了对异步I/O的支持，asyncio基于事件循环，可以轻松实现异步I/O操作。接下来，我们用基于asyncio的库实现一个高性能爬虫。</p>
<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><p><a target="_blank" rel="noopener" href="https://chrome.google.com/webstore/detail/earth-view-from-google-ea/bhloflhklmhfpedakmangadcdofhnnoh">Earth View from Google Earth</a>是一款Chrome插件，会在打开新标签页时自动加载一张来自Google Earth的背景图片。</p>
<p><img src="/upload/20180410_01.png" alt="Earth View from Google Earth"></p>
<p>使用Chrome开发者工具观察插件的网络请求，我们发现插件会请求一个地址如<a target="_blank" rel="noopener" href="https://www.gstatic.com/prettyearth/assets/data/v2/1234.json">https://www.gstatic.com/prettyearth/assets/data/v2/1234.json</a>的JSON文件，文件中包含了经过Base64的图片内容，观察发现，图片的ID范围大致在1000-8000之间，我们的爬虫就要来爬取这些精美的背景图片。</p>
<h1 id="实现主要逻辑"><a href="#实现主要逻辑" class="headerlink" title="实现主要逻辑"></a>实现主要逻辑</h1><p>由于爬取目标是JSON文件，爬虫的主要逻辑就变成了<strong>爬取JSON–&gt;提取图片–&gt;保存图片</strong>。</p>
<p>requests是一个常用的http请求库，但是由于requests的请求都是同步的，我们使用<a target="_blank" rel="noopener" href="https://aiohttp.readthedocs.io/en/stable/">aiohttp</a>这个异步http请求库来代替。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">fetch_image_by_id</span>(<span class="params">item_id</span>):</span></span><br><span class="line">	url = <span class="string">f&#x27;https://www.gstatic.com/prettyearth/assets/data/v2/<span class="subst">&#123;item_id&#125;</span>.json&#x27;</span></span><br><span class="line">        <span class="comment"># 由于URL是https的，所以选择不验证SSL</span></span><br><span class="line">	<span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession(connector=aiohttp.TCPConnector(verify_ssl=<span class="literal">False</span>)) <span class="keyword">as</span> session:</span><br><span class="line">		<span class="keyword">async</span> <span class="keyword">with</span> session.get(url) <span class="keyword">as</span> response:</span><br><span class="line">            <span class="comment"># 获取后需要将JSON字符串转为对象</span></span><br><span class="line">			<span class="keyword">try</span>:</span><br><span class="line">				json_obj = json.loads(<span class="keyword">await</span> response.text())</span><br><span class="line">			<span class="keyword">except</span> json.decoder.JSONDecodeError <span class="keyword">as</span> e:</span><br><span class="line">				<span class="built_in">print</span>(<span class="string">f&#x27;Download failed - <span class="subst">&#123;item_id&#125;</span>.jpg&#x27;</span>)</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">            <span class="comment"># 获取JSON中的图片内容字段，经过Base64解码成二进制内容</span></span><br><span class="line">			image_str = json_obj[<span class="string">&#x27;dataUri&#x27;</span>].replace(<span class="string">&#x27;data:image/jpeg;base64,&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">			image_data = base64.b64decode(image_str)</span><br><span class="line">			save_folder = dir_path = os.path.dirname(</span><br><span class="line">				os.path.realpath(__file__)) + <span class="string">&#x27;/google_earth/&#x27;</span></span><br><span class="line">			<span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">f&#x27;<span class="subst">&#123;save_folder&#125;</span><span class="subst">&#123;item_id&#125;</span>.jpg&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">				f.write(image_data)</span><br><span class="line">			<span class="built_in">print</span>(<span class="string">f&#x27;Download complete - <span class="subst">&#123;item_id&#125;</span>.jpg&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>aiohttp基于asyncio，所以在调用时需要使用async/await语法糖，可以看到，由于aiohttp中提供了一个ClientSession上下文，代码中使用了async with的语法糖。</p>
<h1 id="加入并行逻辑"><a href="#加入并行逻辑" class="headerlink" title="加入并行逻辑"></a>加入并行逻辑</h1><p>上面的代码是抓取单张图片的逻辑，批量抓取图片，需要再嵌套一层方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">fetch_all_images</span>():</span></span><br><span class="line">    <span class="comment"># 使用Semaphore限制最大并发数</span></span><br><span class="line">	sem = asyncio.Semaphore(<span class="number">10</span>)</span><br><span class="line">	ids = [<span class="built_in">id</span> <span class="keyword">for</span> <span class="built_in">id</span> <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>, <span class="number">8000</span>)]</span><br><span class="line">	<span class="keyword">for</span> current_id <span class="keyword">in</span> ids:</span><br><span class="line">		<span class="keyword">async</span> <span class="keyword">with</span> sem:</span><br><span class="line">			<span class="keyword">await</span> fetch_image_by_id(current_id)</span><br></pre></td></tr></table></figure>

<p>接下来，将这个方法加入到asyncio的事件循环中。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">event_loop = asyncio.get_event_loop()</span><br><span class="line">future = asyncio.ensure_future(fetch_all_images())</span><br><span class="line">results = event_loop.run_until_complete(future)</span><br></pre></td></tr></table></figure>
<h1 id="使用uvloop加速"><a href="#使用uvloop加速" class="headerlink" title="使用uvloop加速"></a>使用uvloop加速</h1><p>uvloop基于libuv，libuv是一个使用C语言实现的高性能异步I/O库，uvloop用来代替asyncio默认事件循环，可以进一步加快异步I/O操作的速度。</p>
<p>uvloop的使用非常简单，只要在获取事件循环前，调用如下方法，将asyncio的事件循环策略设置为uvloop的事件循环策略。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">asyncio.set_event_loop_policy(uvloop.EventLoopPolicy())</span><br></pre></td></tr></table></figure>

<p>使用上面的代码，我们可以快速将大约1500张的图片爬取下来。</p>
<p><img src="/upload/20180410_02.png" alt="爬取下来的Google Earth图片"></p>
<h1 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h1><p>为了验证aiohttp和uvloop的性能，笔者使用requests+concurrent库实现了一个多进程版的爬虫，分别爬取20个id，消耗的时间如图。</p>
<p><img src="/upload/20180410_03.png"></p>
<p>可以看到，耗时相差了大概7倍，aiohttp+uvloop的组合在爬虫这种I/O密集型的场景下，可以说具有压倒性优势。相信在不远的将来，基于asyncio的库会将无数爬虫工程师从加班中拯救出来。</p>

        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2018/03/30/python-access-control/">与面试官谈笑风生 | Python面向对象之访问控制</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-03-30
        </span><span class="post-category">
            <a href="/categories/Python/">Python</a>
            </span>
        </div>
    </header>

    <div class="post-content"><p>Python从设计之初就是一门面向对象的语言，面向对象思想的第一个要素就是封装。所谓封装，通俗的讲就是类中的属性和方法，分为公有和私有，公有可以被外界访问，私有不能被外界访问，这就是封装中最关键的概念——访问控制。</p>
<p><img src="/upload/20180330_01.jpg" alt="面向对象编程"></p>
<p>访问控制有三种级别：私有、受保护、公有</p>
<p>私有（Private）：只有类自身可以访问<br>受保护（Protected）：只有类自身和子类可以访问<br>公有（Public）：任何类都可以访问</p>
<p>由于Python不像Java，有访问控制符（private / public / protected），所以Python的访问控制也是容易被应聘者忽视和搞错的。</p>
<h1 id="公有（Public）"><a href="#公有（Public）" class="headerlink" title="公有（Public）"></a>公有（Public）</h1><p>在Python的类中，默认情况下定义的属性都是公有的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">	bar = <span class="number">123</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, bob</span>):</span></span><br><span class="line">		self.bob = bob</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(Foo.bar)  <span class="comment"># 123</span></span><br><span class="line"></span><br><span class="line">foo = Foo(<span class="number">456</span>)</span><br><span class="line"><span class="built_in">print</span>(foo.bob)  <span class="comment"># 456</span></span><br></pre></td></tr></table></figure>

<p>上面类<code>Foo</code>中的<code>bar</code>属性就是类属性，<code>__init__</code>方法中定义的bob是实例属性，<code>bar</code>和<code>bob</code>都是公有的属性，外部可以访问，分别print类中的<code>bar</code>和实例中的<code>bob</code>，输出了对应的值。</p>
<h1 id="受保护（Protected）"><a href="#受保护（Protected）" class="headerlink" title="受保护（Protected）"></a>受保护（Protected）</h1><p>在Python中定义一个受保护的属性，只需要在其名字前加一个下划线<code>_</code>，我们将Foo方法中的<code>bob</code>和<code>bar</code>改为<code>_bob</code>和<code>_bar</code>，他们就变成了受保护的属性了，代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">	_bar = <span class="number">123</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, bob</span>):</span></span><br><span class="line">		self._bob = bob</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span>(<span class="params">Foo</span>):</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">print_bob</span>(<span class="params">self</span>):</span></span><br><span class="line">		<span class="built_in">print</span>(self._bob)</span><br><span class="line"></span><br><span class="line"><span class="meta">	@classmethod</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">print_bar</span>(<span class="params">cls</span>):</span></span><br><span class="line">		<span class="built_in">print</span>(cls._bar)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Son.print_bar()  <span class="comment"># 123</span></span><br><span class="line"></span><br><span class="line">son = Son(<span class="number">456</span>)</span><br><span class="line">son.print_bob()  <span class="comment"># 456</span></span><br></pre></td></tr></table></figure>

<p>定义一个类<code>Son</code>继承自<code>Foo</code>，由于受保护的对象只能在类的内部和子类中被访问，不能直接调用<code>print(Son._bar)</code>或<code>print(son._bob)</code>来输出这两个属性的值，所以定义了<code>print_bar</code>和<code>print_bob</code>方法，实现在子类中输出，这段代码也正常的输出了<code>_bar</code>和<code>_bob</code>的值。</p>
<p>接下来，试着反向验证一下，在类的外部，能不能访问其属性，将上面代码的输出部分修改如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(Son._bar)  <span class="comment"># 123</span></span><br><span class="line"></span><br><span class="line">son = Son(<span class="number">456</span>)</span><br><span class="line"><span class="built_in">print</span>(son._bob)  <span class="comment"># 456</span></span><br></pre></td></tr></table></figure>

<p>（假装）惊讶的发现，竟然没有报错，也输出了正确的值。</p>
<p>Python中用加下划线来定义受保护变量，是一种约定的规范，而不是语言层面真的实现了访问控制，所以，我们定义的保护变量，依然可以在外部被访问到（这是个feature，不是bug）。</p>
<h1 id="私有（private）"><a href="#私有（private）" class="headerlink" title="私有（private）"></a>私有（private）</h1><p>Python定义私有属性，需要在属性名前加两个下划线<code>__</code>，把上面的代码修改一下，运行一下会发现下面的代码中的任何一个print都会报错的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">	__bar = <span class="number">123</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, bob</span>):</span></span><br><span class="line">		self.__bob = bob</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span>(<span class="params">Foo</span>):</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">print_bob</span>(<span class="params">self</span>):</span></span><br><span class="line">		<span class="built_in">print</span>(self.__bob)  <span class="comment"># Error</span></span><br><span class="line"></span><br><span class="line"><span class="meta">	@classmethod</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">print_bar</span>(<span class="params">cls</span>):</span></span><br><span class="line">		<span class="built_in">print</span>(cls.__bar)  <span class="comment"># Error</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(Son.__bar)  <span class="comment"># Error</span></span><br><span class="line"></span><br><span class="line">son = Son(<span class="number">456</span>)</span><br><span class="line"><span class="built_in">print</span>(son._bob)  <span class="comment"># Error</span></span><br></pre></td></tr></table></figure>

<h2 id="深入一下——私有属性真的就访问不到了吗？"><a href="#深入一下——私有属性真的就访问不到了吗？" class="headerlink" title="深入一下——私有属性真的就访问不到了吗？"></a>深入一下——私有属性真的就访问不到了吗？</h2><p>要了解私有属性是否真的访问不到，需要从Python是如何实现私有属性入手。CPython中，会把双下划线的属性变为<code>_ClassName__PropertyName</code>的形式，用代码演示一下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">	__bar = <span class="number">123</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(Foo._Foo__bar)  <span class="comment"># 123</span></span><br></pre></td></tr></table></figure>

<p>运行一下可以知道，正常输出了<code>__bar</code>的值，但是不推荐这样去访问私有属性，因为不同的Python解释器对于私有属性的处理不一样。</p>
<h2 id="特例"><a href="#特例" class="headerlink" title="特例"></a>特例</h2><p>使用双下划线定义私有属性，有一种特殊情况，当属性后也有两个下划线的时候，这个属性会被Python解释器当做魔术方法，从而不做私有处理。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">	__bar__ = <span class="number">123</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(Foo.__bar__)  <span class="comment"># 123</span></span><br></pre></td></tr></table></figure>

<p>上面代码输出了123，证明Python解释器并没有把<code>__bar__</code>当做私有属性。当定义私有属性时，需要注意名字最后最多只能有一个下划线。</p>
<h2 id="另一个特例"><a href="#另一个特例" class="headerlink" title="另一个特例"></a>另一个特例</h2><p>假如定义的属性名就叫<code>__</code>呢？不妨直接试一下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">	__ = <span class="number">123</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(Foo.__)  <span class="comment"># 123</span></span><br></pre></td></tr></table></figure>

<p>可以发现名字叫<code>__</code>的属性也不会被认为是私有属性，名字是多个下划线的属性也不是私有属性（比如<code>_______</code>）。</p>
<h1 id="函数的访问控制"><a href="#函数的访问控制" class="headerlink" title="函数的访问控制"></a>函数的访问控制</h1><p>前面主要介绍了属性的访问控制，在Python中函数是一等公民，所谓一等公民，就是函数可以像变量一样使用，所以函数的访问控制和属性一样，一样应用上面的规则。</p>

        </div></article>
      <nav class="pagination"><a class="prev" href="/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text">上一页</span>
      </a>
    <a class="next" href="/page/3/">
        <span class="next-text">下一页</span>
        <i class="iconfont icon-right"></i>
      </a>
    </nav></section></div></div>
      </main>

      <footer id="footer" class="footer"><div class="social-links"><a href="mailto:zangzhiya@gmail.com" class="iconfont icon-email" title="email"></a>
        <a target="_blank" rel="noopener" href="https://github.com/simpleapples" class="iconfont icon-github" title="github"></a>
        <a target="_blank" rel="noopener" href="https://www.zhihu.com/people/simpleapples" class="iconfont icon-zhihu" title="zhihu"></a>
        <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
    </div><div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" target="_blank" rel="noopener" href="https://github.com/ahonn/hexo-theme-even">Even</a>
  </span>

  <span class="copyright-year">&copy;2012 - 2021<span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">simpleapples</span>
  </span>
</div>
</footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div><script type="text/javascript" src="/lib/jquery/jquery.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/src/even.js?v=2.11.0"></script>
</body>
</html>
