<!DOCTYPE html>
<html lang="zh-CN">
  <head><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<link rel="alternate" href="/default" title="simpleapples" ><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.11.0" />
<link rel="canonical" href="http://www.simpleapples.com/"/>

<link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css" />
<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.11.0" />

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-116134610-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-116134610-1');
</script><script id="baidu_push">
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
<script>
  window.config = {"leancloud":{"app_id":null,"app_key":null},"toc":true,"fancybox":true,"pjax":"","latex":false};
</script>

    <title>simpleapples</title>
  <meta name="generator" content="Hexo 5.4.0"></head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">simpleapples</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list"><a href="/">
        <li class="mobile-menu-item">首页
          </li>
      </a><a href="/archives/">
        <li class="mobile-menu-item">归档
          </li>
      </a><a href="/about/">
        <li class="mobile-menu-item">关于
          </li>
      </a></ul>
</nav>
<div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">simpleapples</a>
</div>

<nav class="site-navbar"><ul id="menu" class="menu"><li class="menu-item">
          <a class="menu-item-link" href="/">
            首页
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            归档
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/about/">
            关于
            </a>
        </li>
      </ul></nav>
</header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content"><section id="posts" class="posts"><article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2021/08/17/avoid-concurrency-bugs-in-go/">规避 Go 中的常见并发 bug</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2021-08-17
        </span><span class="post-category">
            <a href="/categories/Golang/">Golang</a>
            </span>
        </div>
    </header>

    <div class="post-content"><p>在<a target="_blank" rel="noopener" href="https://cseweb.ucsd.edu/~yiying/GoStudy-ASPLOS19.pdf">Understanding Real-World Concurrency Bugs in Go</a>这篇论文中，几名研究人员分析了常见的Go并发bug，并在最流行的几个Go开源项目中进行了验证。本文梳理了论文中提到的常见的bug并给出解决方法的分析。</p>
<p>论文中对bugs进行了分类，分为阻塞式和非阻塞式两种：<br>阻塞式：goroutine发生阻塞无法继续执行（例如死锁）<br>非阻塞式：不会阻塞执行，但存在潜在的数据冲突（例如并发写）</p>
<h1 id="阻塞式bug"><a href="#阻塞式bug" class="headerlink" title="阻塞式bug"></a>阻塞式bug</h1><p>阻塞式bug发生的根因有两种，一种是共享内存（例如卡在了意图保护共享内存的锁操作上），一种是消息传递（比如等待chan）。同时研究发现共享内存和消息传递导致的bug数量不想上下，但是共享这种方法的使用量比消息传递使用的更频繁，所以也得出了共享内存方式更不容易导致bug的结论。</p>
<h2 id="读写锁优先级导致的死锁"><a href="#读写锁优先级导致的死锁" class="headerlink" title="读写锁优先级导致的死锁"></a>读写锁优先级导致的死锁</h2><p>在Go中的写锁优先级高于读锁优先级，假设一个goroutine（goroutine A）连续获取两次读锁，而另一个goroutine（goroutine B）在gouroutine A两次获取读锁中间获取了写锁，就会导致死锁的发生。论文中没有针对这个bug给出示例代码，我写了一个简单的代码示意一下。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gouroutine1</span><span class="params">()</span></span> &#123;</span><br><span class="line">    m.RLock()</span><br><span class="line">    m.RLock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gouroutine2</span><span class="params">()</span></span> &#123;</span><br><span class="line">    m.WLock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>f1和f2都在goroutine中执行，当f1执行完第一个l.RLock()语句后，假设这时f2的m.WLock执行，由于写锁是排它的，WLock本身被f1的第一个m.RLock()阻塞，写锁操作本身又会阻塞f1中的第二个m.RLock</p>
<h2 id="WaitGroup误用导致的死锁"><a href="#WaitGroup误用导致的死锁" class="headerlink" title="WaitGroup误用导致的死锁"></a>WaitGroup误用导致的死锁</h2><p>这种情况就是比较典型的WaitGroup的误用了，提前执行group.Wait()会导致部分group.Done()无法执行到，进而导致程序被阻塞。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> group sync.WaitGroup</span><br><span class="line">group.Add(<span class="built_in">len</span>(pm.plugins))</span><br><span class="line"><span class="keyword">for</span> _, p := <span class="keyword">range</span> pm.plugins &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(p *plugin)</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> group.Done()</span><br><span class="line">    &#125;</span><br><span class="line">    group.Wait()  <span class="comment">// blocked</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// group.Wait() should be here</span></span><br></pre></td></tr></table></figure>

<p>for循环内的group.Wait()执行到的时候，循环内的部分goroutine还没有被创建出来，其中的group.Done()也就永远没法执行到，所以会导致永远阻塞在这一句，正确的写法是将group.Wait()移到for循环外。</p>
<h2 id="Channel的误用"><a href="#Channel的误用" class="headerlink" title="Channel的误用"></a>Channel的误用</h2><p>Channel是go支持并发的一个非常重要的特性，Channel虽然在很多场景下非常解决问题，但是误用也是不容易发现的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">goroutine1</span><span class="params">()</span></span> &#123;</span><br><span class="line">    m.Lock()</span><br><span class="line">    ch &lt;- request  <span class="comment">// blocked</span></span><br><span class="line">    m.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">goroutine2</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        m.Lock()  <span class="comment">// 阻塞</span></span><br><span class="line">        m.Unlock()</span><br><span class="line">        request &lt;- ch</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码的业务语义是goroutine1会通过ch接收goroutine2发送的消息，但是当goroutine1执行到ch &lt;- request时候会阻塞并等待ch，此时由于goroutine1没有释放锁，goroutine2的m.Lock()也会阻塞，形成死锁。</p>
<h2 id="特殊库的误用"><a href="#特殊库的误用" class="headerlink" title="特殊库的误用"></a>特殊库的误用</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hctx, hcancel := context.WithCancel(ctx)</span><br><span class="line"><span class="keyword">if</span> timeout &gt; <span class="number">0</span> &#123;</span><br><span class="line">    hctx, hcancel = context.WithTimeout(ctx, timeout)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了显式的使用channel，go提供了一些lib来在goroutine之间传递消息，上面代码在执行hctx, hcancel := context.WithCancel(ctx)时会创建一个goroutine出来，而当timeout&gt;0时又回创建新的channel赋给同一个变量hcancel，这会导致第一行创建出的channel不会被关闭，也不能再给这个channel发消息。</p>
<h1 id="非阻塞式bug"><a href="#非阻塞式bug" class="headerlink" title="非阻塞式bug"></a>非阻塞式bug</h1><p>和阻塞式bug类似，非阻塞式bug也由共享内存和消息传递引起：当试图保护一个共享变量失败时候，或消息传递使用不当时候，都可能造成非阻塞式的bug。</p>
<h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><p>虽然论文中将这一类错误归结为匿名函数的不正确使用，但实际上产生这类bug的原因是工程师忽略了实际上在跨goroutine共享的变量。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="number">17</span>; i &lt;= <span class="number">21</span>; i++ &#123; <span class="comment">// write</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="comment">/* Create a new goroutine */</span> </span><br><span class="line">        apiVersion := fmt.Sprintf(<span class="string">&quot;v1.%d&quot;</span>, i) <span class="comment">// read</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如这段代码（也经常出现在面试中），由于变量i在匿名函数构建出的goroutine和主goroutine共享，又不能保证goroutine什么时候执行，所以goroutine中拿到的i并不确定（大概率这几个循环创建出的goroutine拿到的都是21）。</p>
<h2 id="WaitGroup的误用"><a href="#WaitGroup的误用" class="headerlink" title="WaitGroup的误用"></a>WaitGroup的误用</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *peer)</span> <span class="title">send</span><span class="params">()</span></span> &#123;</span><br><span class="line">    p.mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> p.mu.Unlock()</span><br><span class="line">    <span class="keyword">switch</span> p.status &#123;</span><br><span class="line">        <span class="keyword">case</span> idle:</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            p.wg.Add(<span class="number">1</span>)</span><br><span class="line">            ...</span><br><span class="line">            p.wg.Done()</span><br><span class="line">        &#125;()</span><br><span class="line">        <span class="keyword">case</span> stopped:</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p * peer)</span> <span class="title">stop</span><span class="params">()</span></span> &#123;</span><br><span class="line">    p.mu.Lock()</span><br><span class="line">    p.status = stopped</span><br><span class="line">    p.mu.Unlock()</span><br><span class="line">    p.wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这段代码中，由于不能保证send方法的goroutine什么时候执行，所以可能导致stop函数的p.wg.Wait()在send函数的p.wg.Add(1)之前执行。</p>
<h2 id="特殊库的误用-1"><a href="#特殊库的误用-1" class="headerlink" title="特殊库的误用"></a>特殊库的误用</h2><p>诸如context这样被设计会在多个goroutine间传递数据的库，在使用时也需要特别注意，可能会导致数据竞争。</p>
<h2 id="Channel的误用-1"><a href="#Channel的误用-1" class="headerlink" title="Channel的误用"></a>Channel的误用</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;- c.closed:</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">close</span>(c.closed)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于default语句可能被多次触发，导致一个channel可能被多次关闭，进而造成panic。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ticker := time.NewTicker()</span><br><span class="line"><span class="keyword">for</span>&#123;</span><br><span class="line">    f()  <span class="comment">// heavy function</span></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;- stopCh: <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">case</span> &lt;- ticker:</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于上面这段代码，当f是一个耗时函数时，很可能出现一次for循环后stopCh和ticker两个case同时满足，这时是没法确认先进哪个case的。</p>
<h2 id="特殊库的误用-2"><a href="#特殊库的误用-2" class="headerlink" title="特殊库的误用"></a>特殊库的误用</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">timer := time.NewTimer(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> dur &gt; <span class="number">0</span> &#123;</span><br><span class="line">    timer = time.NewTimer(dur)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;- timer.C:</span><br><span class="line">    <span class="keyword">case</span> &lt;- ctx.Done():</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这段代码中，第一行创建的timer由于超时时间是0，所以会立刻触发select中的第一个case，导致和期望不符合的行为。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Go的特性使得线程的创建和数据传递都非常容易，但是容易的背后线程间通信的那些坑依然是存在的，论文认为go的消息传递机制会导致更多的bug出现。在我看来，go的消息传递机制相比于传统的共享内存机制，相当于多了一层逻辑层面的封装，这种特性有时会让传统的多线程编程经验不能直接发挥价值，但是只要把握住底层的机制，可以很快积累基于go的语言特性的并发编程经验。</p>

        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2021/07/29/orderby-invalid-in-subquery/">MySQL 子查询中order by不生效问题</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2021-07-29
        </span><span class="post-category">
            <a href="/categories/MySQL/">MySQL</a>
            </span>
        </div>
    </header>

    <div class="post-content"><p>一个偶然的机会，发现一条SQL语句在不同的MySQL实例上执行得到了不同的结果。</p>
<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>创建商品表product_tbl和商品操作记录表product_operation_tbl两个表，来模拟下业务场景，结构和数据如下：</p>
<p><img src="/upload/20210729_01.png"></p>
<p><img src="/upload/20210729_02.png"></p>
<p>接下来需要查询所有商品最新的修改时间，使用如下语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> t1.id, t1.name, t2.product_id, t2.created_at  <span class="keyword">from</span> product_tbl t1 <span class="keyword">left</span> <span class="keyword">join</span> (<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> product_operation_log_tbl <span class="keyword">order</span> <span class="keyword">by</span> created_at <span class="keyword">desc</span>) t2 <span class="keyword">on</span> t1.id <span class="operator">=</span> t2.product_id <span class="keyword">group</span> <span class="keyword">by</span> t1.id;</span><br></pre></td></tr></table></figure>

<p>通过结果可以看到，子查询先将product_operation_log_tbl里的所有记录按创建时间(created_at)逆序，然后和product_tbl进行join操作，进而查询出的商品的最新修改时间。</p>
<p><img src="/upload/20210729_03.png"></p>
<p>在区域A的MySQL实例上，查询商品最新修改时间可以得到正确结果，但是在区域B的MySQL实例上，得到的修改时间并不是最新的，而是最老的。通过对语句进行简化，发现是子查询中的order by created_at desc语句在区域B的实例上没有生效。</p>
<h1 id="排查过程"><a href="#排查过程" class="headerlink" title="排查过程"></a>排查过程</h1><p>难道区域会影响MySQL的行为？经过DBA排查，区域A的MySQL是5.6版，区域B的MySQL是5.7版，并且找到了这篇文章：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_42121058/article/details/113588551?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-3.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-3.control">mysql 5.7 5.6排序_mysql 5.6升级到5.7之后 子查询里面的order排序无效_火锅与理想的博客-CSDN博客</a></p>
<p>根据文章的描述，MySQL 5.7版会忽略掉子查询中的order by语句，可令人疑惑的是，我们模拟业务场景的MySQL是8.0版，并没有出现这个问题。使用docker分别启动MySQL 5.6、5.7、8.0三个实例，来重复上面的操作，结果如下：</p>
<p><img src="/upload/20210729_04.png"></p>
<p>可以看到，只有MySQL 5.7版忽略了子查询中的order by。有没有可能是5.7引入了bug，后续版本又修复了呢？</p>
<h1 id="问题根因"><a href="#问题根因" class="headerlink" title="问题根因"></a>问题根因</h1><p>继续搜索文档和资料，发现官方论坛中有这样一段描述：</p>
<blockquote>
<p>A “table” (and subquery in the FROM clause too) is - according to the SQL standard - an unordered set of rows. Rows in a table (or in a subquery in the FROM clause) do not come in any specific order. That’s why the optimizer can ignore the ORDER BY clause that you have specified. In fact, SQL standard does not even allow the ORDER BY clause to appear in this subquery (we allow it, because ORDER BY … LIMIT … changes the result, the set of rows, not only their order).<br>You need to treat the subquery in the FROM clause, as a set of rows in some unspecified and undefined order, and put the ORDER BY on the top-level SELECT.</p>
</blockquote>
<p>问题的原因清晰了，原来SQL标准中，table的定义是一个未排序的数据集合，而一个SQL子查询是一个临时的table，根据这个定义，子查询中的order by会被忽略。同时，官方回复也给出了解决方案：将子查询的order by移动到最外层的select语句中。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>在SQL标准中，子查询中的order by是不生效的</li>
<li>MySQL 5.7由于在这个点上遵循了SQL标准导致问题暴露，而在MySQL 5.6/8.0中这种写法依然是生效的</li>
</ul>
<h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/26372511/mysql-mariadb-order-by-inside-subquery">https://stackoverflow.com/questions/26372511/mysql-mariadb-order-by-inside-subquery</a></p>
<p><a target="_blank" rel="noopener" href="https://mariadb.com/kb/en/why-is-order-by-in-a-from-subquery-ignored/">https://mariadb.com/kb/en/why-is-order-by-in-a-from-subquery-ignored/</a></p>

        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2020/06/30/one-click-setting-proxy-for-wsl2/">为 WSL2 一键设置代理</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2020-06-30
        </span><span class="post-category">
            <a href="/categories/DevOps/">DevOps</a>
            </span>
        </div>
    </header>

    <div class="post-content"><p>在 WSL2 环境中 clone 一个很大的 git 项目，不走代理速度很慢，所以研究了一下怎么让 WSL2 走 Windows 的代理客户端。</p>
<h3 id="WSL1-和-WSL2-网络的区别"><a href="#WSL1-和-WSL2-网络的区别" class="headerlink" title="WSL1 和 WSL2 网络的区别"></a>WSL1 和 WSL2 网络的区别</h3><p>在 WSL1 时代，由于 Linux 子系统和 Windows 共享了网络端口，所以访问 Windows 的代理非常简单。例如 Windows 的代理客户端监听了 8000 端口，那么只需要在 Linux 子系统中执行如下命令，就可以让当前 session 中的请求通过代理访问互联网。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> ALL_PROXY=<span class="string">&quot;http://127.0.0.1:8000&quot;</span></span><br></pre></td></tr></table></figure>

<p>但是 WSL2 基于 Hyper-V 运行，导致 Linux 子系统和 Windows 在网络上是两台各自独立的机器，从 Linux 子系统访问 Windows 首先需要找到 Windows 的 IP。</p>
<h3 id="配置-WSL2-访问-Windows-上的代理"><a href="#配置-WSL2-访问-Windows-上的代理" class="headerlink" title="配置 WSL2 访问 Windows 上的代理"></a>配置 WSL2 访问 Windows 上的代理</h3><p>有两个关键步骤：</p>
<ol>
<li>WSL2 中配置的代理要指向 Windows 的 IP；</li>
<li>Windows 上的代理客户端需要允许来自本地局域网的请求；</li>
</ol>
<p>由于 Linux 子系统也是通过 Windows 访问网络，所以 Linux 子系统中的网关指向的是 Windows，DNS 服务器指向的也是 Windows，基于这两个特性，我们可以将 Windows 的 IP 读取出来。</p>
<p>例如，在 Ubuntu 子系统中，通过 <code>cat /etc/resolv.conf</code> 查看 DNS 服务器 IP。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># This file was automatically generated by WSL. To stop </span></span><br><span class="line">automatic generation of this file, add the following entry to /etc/wsl.conf:<span class="comment"># [network]# generateResolvConf = falsenameserver 172.19.80.1</span></span><br></pre></td></tr></table></figure>

<p>可以看到 DNS 服务器是 <code>172.19.80.1</code>，通过环境变量 <code>ALL_PROXY</code> 配置代理：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> ALL_PROXY=<span class="string">&quot;http://172.19.80.1:7890&quot;</span></span><br></pre></td></tr></table></figure>

<p>7890 是 Windows 上运行的代理客户端的端口，记得要在 Windows 代理客户端上配置允许本地局域网请求。</p>
<p><img src="/upload/20200630_01.jpg"></p>
<h3 id="一键配置脚本"><a href="#一键配置脚本" class="headerlink" title="一键配置脚本"></a>一键配置脚本</h3><p>将上面的过程写入一个 bash 脚本，可以轻松的实现一键配置代理：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">host_ip=$(cat /etc/resolv.conf |grep <span class="string">&quot;nameserver&quot;</span> |cut -f 2 -d <span class="string">&quot; &quot;</span>)</span><br><span class="line"><span class="built_in">export</span> ALL_PROXY=<span class="string">&quot;http://<span class="variable">$host_ip</span>:7890&quot;</span></span><br></pre></td></tr></table></figure>

<p>脚本通过 <code>cat /etc/resolv.conf</code> 来获取 DNS 服务器，也就是 Windows 的 IP，再将其中的 IP 部分截取出来，加上代理客户端的端口（我的是 7890，可以根据自己实际情况修改），使用 export 写入环境变量中。</p>
<p>脚本也可以从这里下载<a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/simpleapples/dotfiles/master/.proxyrc">.proxyrc</a>，使用时只需要 <code>source .proxyrc</code> 就可以生效。</p>

        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2020/06/01/wsl2-guideline-for-developers/">面向开发者的 WSL2 安装指南</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2020-06-01
        </span><span class="post-category">
            <a href="/categories/DevOps/">DevOps</a>
            </span>
        </div>
    </header>

    <div class="post-content"><h3 id="为什么要使用-Windows-做开发"><a href="#为什么要使用-Windows-做开发" class="headerlink" title="为什么要使用 Windows 做开发"></a>为什么要使用 Windows 做开发</h3><p>一直以来 macOS 以类 unix 的特性，获得了程序员的青睐，但是近几年 Apple 在硬件领域少有让人耳目一新的产品，加上取消 Esc、使用蝶式键盘、基本为0的硬件可升级性、系统权限的收紧等骚操作，让 Mac 从软件到硬件都不如以前适合编程。另一方面，PC 阵营在软件层面保持开放的基础上，硬件体验也逐步赶上甚至超越 Mac，我也不想在用 Mac 做开发，用 PC 玩游戏，希望用一台电脑兼顾游戏和开发，所以选择回到了 PC 阵营。</p>
<p>随着微软拥抱开源领域，Windows 也开始变得程序员友好。Windows 10 2004 发布后，WSL2 也可以在正式版 Windows 10 中使用，相比于 macOS，WSL2 是一个原生 Linux 环境而非类 unix 环境，甚至可以在 App 商店中选择所需要的发行版。而相比于 WSL1，WSL2 采用了 HyperV 虚拟机的方式，解决了 WSL1 不能安装 Docker 等问题。</p>
<h3 id="WSL1-和-WSL2"><a href="#WSL1-和-WSL2" class="headerlink" title="WSL1 和 WSL2"></a>WSL1 和 WSL2</h3><p>相比于 WSL1，WSL2 通过虚拟机的方式带来了更完整的 Linux 内核，但这种方式也引入了一些问题，微软给出了下面的图表来展示这些不同：</p>
<p><img src="/upload/20200601_01.png"></p>
<p>WSL2 不能和 VMWarework Station、VirtualBox 同时运行这一条已经过时了，VirtualBox 和 VMWare Workstation 都发布了支持 WSL2 和 Hyper-V 的新版。</p>
<p>WSL2 跨 OS 的磁盘性能的确低的令人发指，尤其是小文件，安装一个 Python 依赖可能需要等几分钟，安装一个 NodeJS 依赖…当我没说…相关 ISSUE 底下有无数吐槽，不过目前还没有人出来解决，在这里：<a target="_blank" rel="noopener" href="https://github.com/microsoft/WSL/issues/4197">https://github.com/microsoft/WSL/issues/4197</a>）。不过微软在文档里也说了，有很多方式可以避免跨 OS 使用文件系统，比如使用 VSCode 的 remote deployment 功能，我认为这也是更好的实践，并且也这么做了。当然，如果你必须跨 OS 使用文件系统，还是乖乖留在 WSL1 吧（WSL1 太渣了，还是留在 VirtualBox 吧）。</p>
<p>除了表格里说的，我认为 WSL2 最大的问题在于…资源占用太大了…我是一台 16G 内存的电脑，使用 WSL2 后开机就要吃掉 11G 的内存，虽然可以使用 <code>wsl --shutdown</code> 关闭虚拟机释放资源，但是相比于 VirtualBox 和 WSL1，WSL2 的资源占用可以说翻倍了。</p>
<blockquote>
<p>微软提供了限制 WSL2 资源的方式，参见<a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/wsl/release-notes#build-18945">https://docs.microsoft.com/en-us/windows/wsl/release-notes#build-18945</a></p>
</blockquote>
<h3 id="要做些什么"><a href="#要做些什么" class="headerlink" title="要做些什么"></a>要做些什么</h3><p>好了，搞清楚 WSL2 是什么之后接下来的问题就是怎么做了，这篇文章会指导你完成如下的安装流程：</p>
<ul>
<li>升级 Windows 10 到 2004</li>
<li>启用 WSL2 并安装 Linux</li>
</ul>
<p>以及一些最佳实践：</p>
<ul>
<li>网络互通</li>
<li>文件系统互通</li>
<li>使用 Docker</li>
</ul>
<p>最后会聊聊 WSL2 的未来。</p>
<h3 id="升级-Windows-10-2004"><a href="#升级-Windows-10-2004" class="headerlink" title="升级 Windows 10 2004"></a>升级 Windows 10 2004</h3><p>升级到 Windows 10 2004 有多种方法，最靠谱的还是从设置 - 更新和安全里进行 OTA 升级，但是 Windows 的更新是分批推送的，2004 更新有可能等到一两个月后才会出现在你的更新界面中。</p>
<p>另一种更快速的方法是从官方地址下载镜像升级，访问这个地址下载运行就可以升级到最新的版本 <a target="_blank" rel="noopener" href="https://www.microsoft.com/software-download/windows10">https://www.microsoft.com/software-download/windows10</a>，需要注意的是，发布初期可能 bug 含量会高一些，介意的还是再等等。</p>
<h3 id="启用-WSL2"><a href="#启用-WSL2" class="headerlink" title="启用 WSL2"></a>启用 WSL2</h3><p>升级 Windows 10 的过程不会碰到太多问题，升级后还需要进行一些配置才可以使用 WSL2，首先要启用 Windows 子系统功能，使用管理员权限打开一个 PowerShell 窗口，输入以下命令，并重启系统：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dism.exe /online /<span class="built_in">enable-feature</span> /featurename:Microsoft<span class="literal">-Windows</span><span class="literal">-Subsystem</span><span class="literal">-Linux</span> /all /norestart</span><br></pre></td></tr></table></figure>

<p>重启后，Windows 默认启用的是 WSL1，还需要再启用虚拟机平台功能，在 PowerShell 中输入以下命令，并再次重启系统：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dism.exe /online /<span class="built_in">enable-feature</span> /featurename:VirtualMachinePlatform /all /norestart</span><br></pre></td></tr></table></figure>

<p>重启后，在 PowerShell 中输入以下命令，将 WSL 默认版本改为 WSL2:</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl -<span class="literal">-set</span><span class="literal">-default</span><span class="literal">-version</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>接下来在 Microsoft Store 中找一个 Linux 发行版进行安装，安装后在 PowerShell 中执行 <code>wsl -l -v</code> 可以看到当前的发行版是否跑在 WSL2 中，如果显示版本是1…请重复上面的安装步骤。</p>
<blockquote>
<p>设置 WSL 版本为 WSL2 报错时，请访问 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/wsl/wsl2-kernel">https://docs.microsoft.com/en-us/windows/wsl/wsl2-kernel</a> 下载 WSL2 Kernel。</p>
</blockquote>
<h3 id="网络互通"><a href="#网络互通" class="headerlink" title="网络互通"></a>网络互通</h3><p>WSL2 不和 Windows 共享一个 localhost，所以不像 WSL1 中 Linux 和 Windows 有无感知的网络互通性。</p>
<p>Windows 访问 WSL2 启动的网络服务，可以直接使用 localhost，但是 Linux 访问 Windows 启动的网络服务这种方式就不行了，可以使用如下脚本获取 Windows 的 IP，并使用 IP 访问 Windows：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip route | grep default | awk <span class="string">&#x27;&#123;print $3&#125;&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="文件系统互通"><a href="#文件系统互通" class="headerlink" title="文件系统互通"></a>文件系统互通</h3><p>WSL2 访问 Windows 文件系统依然通过挂载分区的方式，Windows 下的磁盘会被挂载在 <code>/mnt</code> 下，例如 <code>/mnt/c</code>。</p>
<p>相比于 WSL1，这次增加了 Windows 访问 Linux 分区的能力，可以在资源管理器中输入 <code>\\wsl$\&lt;子系统名&gt;</code> 访问对应的子系统分区，为了方便也可以在资源管理器中把 Linux 分区挂载成一个磁盘。</p>
<p>更加方便的一个方式是，在 Terminal 中，使用 <code>explorer.exe .</code> 可以直接调用资源管理器打开当前目录，有点类似 Mac 下的 <code>open .</code>。</p>
<h3 id="使用-Docker"><a href="#使用-Docker" class="headerlink" title="使用 Docker"></a>使用 Docker</h3><p>WSL2 带来了完整的 Linux 内核，所以可以参照 Docker 在 Linux 上安装的过程安装 Docker，并且可以正常使用，但是会有一个小瑕疵。WSL2 的 systemd 吧…还不是原生的，也就是在 WSL1 上就有的无法启动服务守护进程的问题依然存在，Docker 服务自然也不能幸免。</p>
<p>解决这个问题有三种方案：</p>
<ul>
<li><p>可以让 Windows 执行开机脚本，通过脚本启动 WSL2 中的 Docker，参见<a target="_blank" rel="noopener" href="https://blog.csdn.net/XhyEax/article/details/105560377">https://blog.csdn.net/XhyEax/article/details/105560377</a>，这种方案在 WSL1 时代就有，我自己使用过没碰到过问题。</p>
</li>
<li><p>第二种方案是使用第三方工具运行 systemd，参见 <a target="_blank" rel="noopener" href="https://github.com/arkane-systems/genie">https://github.com/arkane-systems/genie</a>，原理是提供了一个单独的 namespace 跑 systemd。</p>
</li>
<li><p>第三种方案是使用 Docker Desktop，2.3.0.2 以上版本已经支持 WSL2 和 Hyper-V，免去一些折腾。</p>
</li>
</ul>
<h3 id="GPU-支持"><a href="#GPU-支持" class="headerlink" title="GPU 支持"></a>GPU 支持</h3><p>Build 2020 发出消息说 WSL2 要支持 GPU，Nvidia 也发出了 CUDA on WSL2 的预览版，在这里：<a target="_blank" rel="noopener" href="https://developer.nvidia.com/cuda/wsl">https://developer.nvidia.com/cuda/wsl</a>。</p>
<p>这意味着以后可以直接在 Windows 上使用 GPU 加速训练模型了，虽然支持成都还很有限，但是相比于 Mac 可领先了一个身位都不只了。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在体系结构上 WSL2 没有太大的创新，本质就是一台跑在 Hyper-V 上的虚拟机，你可以使用 VMWare Workstation 或 VirtualBox，经过简单的配置实现其 100% 的功能，并且会有更高的性能，更少的资源占用，但是毕竟 WSL2 是一项原生功能，其配置上的便利性和兼容性，大大减少了使用者花在配置上的精力，最大程度的实现开箱即用，这也是 Apple 一直以来吸引开发者的主要原因。在这个时间点，使用 Windows + WSL2 来构建开发环境已经可以满足大部分的需求。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a target="_blank" rel="noopener" href="https://github.com/microsoft/WSL/issues/4197">https://github.com/microsoft/WSL/issues/4197</a></p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/wsl/wsl2-kernel">https://docs.microsoft.com/en-us/windows/wsl/wsl2-kernel</a></p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/wsl/install-win10">https://docs.microsoft.com/en-us/windows/wsl/install-win10</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/arkane-systems/genie">https://github.com/arkane-systems/genie</a></p>
<p><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/windows/wsl/release-notes#build-18945">https://docs.microsoft.com/en-us/windows/wsl/release-notes#build-18945</a></p>
<p><a target="_blank" rel="noopener" href="https://developer.nvidia.com/cuda/wsl">https://developer.nvidia.com/cuda/wsl</a></p>
<p><a target="_blank" rel="noopener" href="https://devblogs.microsoft.com/directx/directx-heart-linux/">https://devblogs.microsoft.com/directx/directx-heart-linux/</a></p>

        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2020/04/23/grpc-fork-support/">gRPC 跨进程使用引发的问题</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2020-04-23
        </span><span class="post-category">
            <a href="/categories/Python/">Python</a>
            </span>
        </div>
    </header>

    <div class="post-content"><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>在 Python 项目中使用 gRPC 进行通信，跨进程使用时，会出现阻塞或报错的情况（根据 gRPC.io 的版本不同，现象不同）。下面代码展示了一个跨进程使用的 DEMO，主进程向 30001 端口上的 gRPC 服务器发送请求，子进程也向相同的服务器发送请求。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send</span>():</span></span><br><span class="line">    channel = grpc.insecure_channel(<span class="string">&#x27;localhost:30001&#x27;</span>)</span><br><span class="line">    stub = message_pb2_grpc.GreeterStub(channel)</span><br><span class="line">    response = stub.SayHello(message_pb2.HelloRequest(name=<span class="string">&#x27;you&#x27;</span>))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Greeter client received 1: &quot;</span> + response.message)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    channel = grpc.insecure_channel(<span class="string">&#x27;localhost:30001&#x27;</span>)</span><br><span class="line">    stub = message_pb2_grpc.GreeterStub(channel)</span><br><span class="line">    response = stub.SayHello2(message_pb2.HelloRequest(name=<span class="string">&#x27;you&#x27;</span>))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Greeter client received 2: &quot;</span> + response.message)</span><br><span class="line">    p = multiprocessing.Process(target=send)</span><br><span class="line">    p.start()</span><br><span class="line">    p.join()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>使用 gRPC.io 1.28.1 的情况下，会发生报错，主进程可以正常收到服务器的返回，但是子进程报 <code>Socket operation on non-socket</code>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">raise _InactiveRpcError(state)</span><br><span class="line">grpc._channel._InactiveRpcError: &lt;_InactiveRpcError of RPC that terminated with:</span><br><span class="line">        status = StatusCode.UNAVAILABLE</span><br><span class="line">        details = <span class="string">&quot;Socket operation on non-socket&quot;</span></span><br><span class="line">        debug_error_string = <span class="string">&quot;&#123;&quot;</span>created<span class="string">&quot;:&quot;</span>@1587481625.192071231<span class="string">&quot;,&quot;</span>description<span class="string">&quot;:&quot;</span>Error received from peer ipv6:[::1]:50051<span class="string">&quot;,&quot;</span>file<span class="string">&quot;:&quot;</span>src/core/lib/surface/call.cc<span class="string">&quot;,&quot;</span>file_line<span class="string">&quot;:1056,&quot;</span>grpc_message<span class="string">&quot;:&quot;</span>Socket operation on non-socket<span class="string">&quot;,&quot;</span>grpc_status<span class="string">&quot;:14&#125;&quot;</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>

<h3 id="排查过程"><a href="#排查过程" class="headerlink" title="排查过程"></a>排查过程</h3><p>根据代码，主进程和子进程分别创建了自己的 Channel，看上去逻辑没什么问题，没有什么思路，所以多尝试几种情况先测试一下吧。首先尝试了一下主进程和子进程请求不同的server，在 30001 和 30002 端口分别启动两个 gRPC Server，然后将客户端代码改为主进程请求 30001 端口，子进程请求 30002 端口，代码可以正常运行。测试到这里就更摸不着头脑了，代码明明写的是主进程子进程分别创建 Channel，现在的现象看上去<strong>像是在请求相同服务器的情况下，子进程复用了主进程的socket连接</strong>。gRPC 底层使用的是 HTTP2，而 HTTP2 使用了长连接，会不会是这个原因？</p>
<blockquote>
<p>有了新的分帧机制后，HTTP/2 不再依赖多个 TCP 连接去并行复用数据流；每个数据流都拆分成很多帧，而这些帧可以交错，还可以分别设定优先级。 因此，所有 HTTP/2 连接都是永久的，而且仅需要每个来源一个连接，随之带来诸多性能优势。 —— <a target="_blank" rel="noopener" href="https://developers.google.com/web/fundamentals/performance/http2?hl=zh-cn">HTTP/2 简介</a></p>
</blockquote>
<p>从 HTTP2 原理上来看还是说的过去的，恰好 gRPC 项目中有 Issue 提到了跨进程使用的问题，参见 <a target="_blank" rel="noopener" href="https://github.com/grpc/grpc/issues/18321">Failed to run grpc python on multiprocessing #18321</a>，开发者在其中说明了像 Demo 那样使用报错的原因。</p>
<blockquote>
<p><strong>gRPC Core’s API for fork support</strong><br>A process may fork after invoking grpc_init() and use gRPC in the child if and only if the child process first destroys all gRPC resources inherited from the parent process and invokes grpc_shutdown().<br>Subsequent to this, the child will be able to re-initialize and use gRPC. After fork, the parent process will be able to continue to use existing gRPC resources such as channels and calls without interference<br>from the child process.</p>
</blockquote>
<blockquote>
<p><strong>gRPC Python behavior at fork()</strong><br>To facilitate gRPC Python applications meeting the above constraints, gRPC Python will automatically destroy and shutdown all gRPC Core resources in the child’s post-fork handler, including cancelling in-flight calls. From the client’s perspective, the child process is now free to create new channels and use gRPC.</p>
</blockquote>
<p>简化的说，在 gRPC Core API 的层面，子进程使用 gRPC 需要先销毁掉从父进程 fork 过来的 gRPC 资源，重新创建连接才可以正常使用，否则可能陷入死锁。</p>
<p>同时，gRPC 对于 fork 行为的支持也有一个专门的文档。<a target="_blank" rel="noopener" href="https://github.com/grpc/grpc/blob/master/doc/fork_support.md">https://github.com/grpc/grpc/blob/master/doc/fork_support.md</a></p>
<blockquote>
<p>The background Python thread was removed entirely. This allows forking after creating a channel. However, the channel must not have issued any RPCs prior to the fork. Attempting to fork with an active channel that has been used can result in deadlocks/corrupted wire data.</p>
</blockquote>
<p>从文档和 Issue 的描述看，当主进程有活动状态的 gRPC 连接时，是不可以 fork 的，会引发死锁或者报错（可能和 HTTP2 的长连接机制有关系），如果要 fork，需要先关闭掉活动的连接，在 fork 出的子进程中重新建立 gRPC 连接（也就是主子进程各自持有各自的 HTTP2 连接）。</p>
<h3 id="实践方案"><a href="#实践方案" class="headerlink" title="实践方案"></a>实践方案</h3><p>综合文档和开发者在 Issue 中提到的方法，要想让 Demo 可以运行有如下三种方法。</p>
<ul>
<li><p>在环境变量中设置 <code>GRPC_ENABLE_FORK_SUPPORT=1</code>（参见<a target="_blank" rel="noopener" href="https://github.com/grpc/grpc/blob/master/doc/fork_support.md#111">https://github.com/grpc/grpc/blob/master/doc/fork_support.md#111</a>）</p>
</li>
<li><p>在 fork 子进程前使用 <code>channel.close()</code> 关闭活动的 gRPC 连接（参见<a target="_blank" rel="noopener" href="https://grpc.github.io/grpc/python/grpc.html#grpc.Channel.close">https://grpc.github.io/grpc/python/grpc.html#grpc.Channel.close</a>）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    channel = grpc.insecure_channel(<span class="string">&#x27;localhost:30001&#x27;</span>)</span><br><span class="line">    stub = message_pb2_grpc.GreeterStub(channel)</span><br><span class="line">    response = stub.SayHello2(message_pb2.HelloRequest(name=<span class="string">&#x27;you&#x27;</span>))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Greeter client received 2: &quot;</span> + response.message)</span><br><span class="line">    channel.close() <span class="comment"># 关闭 channel，再 fork</span></span><br><span class="line">    </span><br><span class="line">    p = multiprocessing.Process(target=send)</span><br><span class="line">    p.start()</span><br><span class="line">    p.join()</span><br></pre></td></tr></table></figure></li>
<li><p>使用 <code>with</code> 语句，语句结束后会自动关闭活动的 gRPC 连接（参见<a target="_blank" rel="noopener" href="https://github.com/grpc/grpc/blob/master/examples/python/helloworld/greeter_client.py#L29">https://github.com/grpc/grpc/blob/master/examples/python/helloworld/greeter_client.py#L29</a>)</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="comment"># 使用 with 语句</span></span><br><span class="line">    <span class="keyword">with</span> grpc.insecure_channel(<span class="string">&#x27;localhost:30001&#x27;</span>) <span class="keyword">as</span> channel:</span><br><span class="line">        stub = message_pb2_grpc.GreeterStub(channel)</span><br><span class="line">        response = stub.SayHello2(message_pb2.HelloRequest(name=<span class="string">&#x27;you&#x27;</span>))</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Greeter client received 2: &quot;</span> + response.message)</span><br><span class="line">   </span><br><span class="line">    p = multiprocessing.Process(target=send)</span><br><span class="line">    p.start()</span><br><span class="line">    p.join()</span><br></pre></td></tr></table></figure>

<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a target="_blank" rel="noopener" href="https://grpc.github.io/grpc/python/grpc.html#channel-object">https://grpc.github.io/grpc/python/grpc.html#channel-object</a></p>
<p><a target="_blank" rel="noopener" href="https://developers.google.com/web/fundamentals/performance/http2?hl=zh-cn">https://developers.google.com/web/fundamentals/performance/http2?hl=zh-cn</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/grpc/grpc/issues/18321">https://github.com/grpc/grpc/issues/18321</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/grpc/grpc/pull/16264">https://github.com/grpc/grpc/pull/16264</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/grpc/grpc/blob/master/doc/fork_support.md#111">https://github.com/grpc/grpc/blob/master/doc/fork_support.md#111</a></p>
<p><a target="_blank" rel="noopener" href="https://grpc.github.io/grpc/python/grpc.html#grpc.Channel.close">https://grpc.github.io/grpc/python/grpc.html#grpc.Channel.close</a></p>

        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2020/04/20/vscode-cant-run-go-project/">探究vscode debug流程，解决无法运行go程序的问题</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2020-04-20
        </span><span class="post-category">
            <a href="/categories/Golang/">Golang</a>
            </span>
        </div>
    </header>

    <div class="post-content"><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>vscode 无法以 <code>run</code> 模式运行 go 项目（只能以 <code>debug</code> 模式调试），并且有如下报错。</p>
<p><img src="/upload/20200420_01.png"></p>
<p>图中被遮盖的部分是项目内的 package，并非第三方 package，也就是说在以 <code>run</code> 模式运行 go 项目时无法找到其他的 go 文件，只能找到入口文件。</p>
<h3 id="初步排查"><a href="#初步排查" class="headerlink" title="初步排查"></a>初步排查</h3><p>找不到其他文件，首先想到的是 GO_PATH 的问题，但是项目使用了 go mod，允许在 GO_PATH 之外的路径创建项目，所以这个怀疑点排除。接下来怀疑 vscode 的配置有问题，每个 vscode 项目中都有 .launch.json 文件，配置运行代码时的环境，下面是项目中的 .launch.json。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Use IntelliSense to learn about possible attributes.</span></span><br><span class="line">    <span class="comment">// Hover to view descriptions of existing attributes.</span></span><br><span class="line">    <span class="comment">// For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;0.2.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Launch&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;go&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;request&quot;</span>: <span class="string">&quot;launch&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;mode&quot;</span>: <span class="string">&quot;auto&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;program&quot;</span>: <span class="string">&quot;$&#123;workspaceRoot&#125;/src/main.go&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;env&quot;</span>: &#123;&#125;,</span><br><span class="line">            <span class="attr">&quot;args&quot;</span>: []</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到 .launch.json 里没有指定程序的工作目录，<code>debug</code> 模式和 <code>run</code> 模式会不会默认的工作路径不同呢？于是在 main 函数里使用 <code>os.Getwd()</code> 打印一下当前的路径，结果如下：</p>
<ul>
<li><code>debug</code> 模式：项目所在目录</li>
<li><code>run</code> 模式：用户目录</li>
</ul>
<p>基本可以确认，<code>run</code> 模式下的工作路径设置不正确，导致找不到路径。在 .launch.json 中加入 <code>cwd</code> 参数，手动填入项目路径。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Use IntelliSense to learn about possible attributes.</span></span><br><span class="line">    <span class="comment">// Hover to view descriptions of existing attributes.</span></span><br><span class="line">    <span class="comment">// For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;0.2.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Launch&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;go&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;request&quot;</span>: <span class="string">&quot;launch&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;mode&quot;</span>: <span class="string">&quot;auto&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;program&quot;</span>: <span class="string">&quot;$&#123;workspaceRoot&#125;/src/main.go&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;cwd&quot;</span>: <span class="string">&quot;$&#123;workspaceRoot&#125;&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;env&quot;</span>: &#123;&#125;,</span><br><span class="line">            <span class="attr">&quot;args&quot;</span>: []</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是修改 .launch.json 后运行程序，输出的工作目录仍然是用户目录，<code>cwd</code> 参数并没有生效。</p>
<h3 id="探究-vscode-的-debug-流程"><a href="#探究-vscode-的-debug-流程" class="headerlink" title="探究 vscode 的 debug 流程"></a>探究 vscode 的 debug 流程</h3><p>至此，bug 的气息越来越浓厚，<code>cwd</code> 参数没有生效，肯定有问题！</p>
<p>一不做二不休，索性看看 vscode 的调试流程吧，用一个很暴力的方式，看看点击运行按钮后，vscode 到底是如何运行 go 程序的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;time&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    time.Sleep(<span class="number">10000000000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行程序后，使用 <code>ps -ef|grep go</code> 查看进程。</p>
<p><img src="/upload/20200420_02.jpg"></p>
<p>截图中三个进程从上到下均是父子关系，也就是说在 vscode 中即便使用 <code>run</code> 模式运行，也不是直接执行 <code>go run xxxx.go</code>，这与 Goland 等其他 IDE 的行为是不同的。vscode 首先调用了 language server 中的 node，执行了 go extention（vscode 的 go 扩展，安装后才支持 go 语言项目）中的一个 <code>goDebug.js</code>，而后 <code>goDebug.js</code> 中调用了 <code>go run xxxx.go</code>。（图中 /tmp  路径下的 main 文件是 go run 执行过程中生成的二进制文件）</p>
<p>接下来查看 <code>goDebug.js</code> 的逻辑，找到了调用 <code>go run</code> 的代码。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.debugProcess = spawn(getBinPathWithPreferredGopath(<span class="string">&#x27;go&#x27;</span>, []), runArgs, &#123; env &#125;);</span><br></pre></td></tr></table></figure>
<p>查看代码上面几行的逻辑，根据参数的命名，可以猜测出来，.launch.json 中的配置在这里是可以获取到的。接下来直接修改 js 文件，进行调试，证实上述的猜测，由于我们无法直接看到 node goDebug.js 的输出，所以通过写入文件的方式进行调试。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fs.writeFile(<span class="string">&#x27;test.log&#x27;</span>, <span class="built_in">this</span>.debugProcess.cwd(), <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>加入这句后再次运行，我们可以看到 test.log 文件中已经打印出了这个进程的工作路径，也就是 go run 的工作路径，是用户目录。至此，可以将问题缩小到：在 node 调用 go run 时没有将 .launch.json 文件中的 cwd 传给子进程（go run）。</p>
<p><code>spawn</code> 是 nodejs 中的函数，看一下 spawn 的文档可以发现，spawn 有三个参数 <code>child_process.spawn(command[, args][, options])</code> 第三个参数 options 中可以指定 cwd 工作路径。而 <code>goDebug.js</code> 这段启动子进程的代码并没有设置 cwd，只设置了<code>env</code> 参数，这就是 <code>run</code> 模式无法运行 go 程序的原因。</p>
<p><img src="/upload/20200420_03.jpg"></p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>在发现这个问题时，vscode go extention的最新版本是0.13，这个问题暂时只能通过修改 goDebug.js 的源码解决，如下图所示加入注释中的代码，将 <code>cwd</code> 参数传入子进程，就可以解决问题。</p>
<p><img src="/upload/20200420_04.png"></p>
<p>同时，这个 bug 已经被解决，可以参考 <a target="_blank" rel="noopener" href="https://github.com/microsoft/vscode-go/issues/3096">ISSUE #3096</a>，程序员在解决另一个问题这个 ISSUE 的问题时，“顺手”把 <code>cwd</code>  的问题修复了。在 vscode go extention 0.14版发布后（已发布），将 go extension 更新到最新版就可以正常运行和调试 go 项目了。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a target="_blank" rel="noopener" href="https://code.visualstudio.com/docs/editor/debugging">Debugging in Visual Studio Code</a></p>
<p><a target="_blank" rel="noopener" href="https://nodejs.org/api/child_process.html#child_process_child_process_spawn_command_args_options">Node.js v13.13.0 Documentation</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/microsoft/vscode-go/issues/3096">Debug: add “go run .” support #3096</a></p>

        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2020/04/16/viper-read-from-etcd-failed/">viper从etcd读取配置失败的问题</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2020-04-16
        </span><span class="post-category">
            <a href="/categories/Golang/">Golang</a>
            </span>
        </div>
    </header>

    <div class="post-content"><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p><a target="_blank" rel="noopener" href="https://github.com/spf13/viper">Viper</a> （本文环境是Viper 1.1.0）是Go应用程序的完整配置解决方案，在很多项目中都有应用。<a target="_blank" rel="noopener" href="https://github.com/etcd-io/etcd">etcd</a>是一个分布式KV存储，最直接的应用是配置中心。</p>
<p>Viper除了支持从文件中读取配置，还支持从远程的配置中心读取配置，使用下面的代码进行配置。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">viper.AddRemoteProvider(<span class="string">&quot;etcd&quot;</span>,</span><br><span class="line">        <span class="string">&quot;http://127.0.0.1:2379&quot;</span>,</span><br><span class="line">        <span class="string">&quot;conf.toml&quot;</span>)</span><br><span class="line">viper.SetConfigType(<span class="string">&quot;toml&quot;</span>)</span><br><span class="line">err := viper.ReadRemoteConfig()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行后报错<code>panic: Remote Configurations Error: No Files Found</code>，检查后发现etcd开启了tls，所以需要用https协议访问etcd的API，更新代码如下。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">viper.AddSecureRemoteProvider(<span class="string">&quot;etcd&quot;</span>,</span><br><span class="line">        <span class="string">&quot;https://127.0.0.1:2379&quot;</span>,</span><br><span class="line">        <span class="string">&quot;conf.toml&quot;</span>,</span><br><span class="line">        <span class="string">&quot;key_path&quot;</span>)</span><br><span class="line">viper.SetConfigType(<span class="string">&quot;toml&quot;</span>)</span><br><span class="line">err := viper.ReadRemoteConfig()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用<code>AddSecureRemoteProvider</code>方法替换<code>AddRemoteProvider</code>方法，问题依旧。</p>
<h3 id="定位问题"><a href="#定位问题" class="headerlink" title="定位问题"></a>定位问题</h3><p>跟踪源码发现，最终像etcd发送请求的是<a target="_blank" rel="noopener" href="https://github.com/coreos/go-etcd/">go-etcd</a>包（目前go-etcd已经不维护），在go-etcd的requests.go文件中找到了相关的源码，go-etcd调用了net/http包向etcd发送请求。</p>
<p><img src="/upload/20200416_01.jpg"></p>
<p>这个时候忽然想到etcd的证书是自签名的，访问自签名证书的https接口应该会报错啊，怎么会请求到内容呢？如下图，在Chrome中访问etcd的自签名https接口，会提示证书无效。</p>
<p><img src="/upload/20200416_02.jpg"></p>
<p>我们自己使用go实现一段请求etcd https接口的代码，看看到底是什么回事，代码如下。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">resp, err := http.Get(<span class="string">&quot;https://127.0.0.1:2379/v2/keys/conf.toml?quorum=false&amp;recursive=false&amp;sorted=false&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// handle error</span></span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line">    body, err := ioutil.ReadAll(resp.Body)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="keyword">string</span>(body))</span><br></pre></td></tr></table></figure>

<p>果然不一样，我们的代码会报错<code>x509: certificate signed by unknown authority</code>，因为是自签名证书，客户端无法验证证书真假，所以这个报错是可以理解的，go-etcd代码和我们的测试代码表现不一致，一定是我们落下了什么，重新梳理go-etcd源码终于发现了原因。</p>
<p><img src="/upload/20200416_03.jpg"></p>
<p>在client.go文件的initHTTPSClient方法中，发现允许绕过证书验证，这就可以解释为什么证书无效也能获取到数据了，绕过了证书的验证环节，相当于不管证书真假都拿来用。现在可以解释使用<code>AddRemoteProvider</code>方法访问https接口为什么可以获取到内容，但是无法解释<code>AddSecureRemoteProvider</code>方法为什么无法从https接口获取内容，因为两个方法在发送http请求阶段的代码是一致的，都忽略了证书验证。</p>
<p>查看<code>AddSecureRemoteProvider</code>的注释，发现了原因。</p>
<p><img src="/upload/20200416_04.jpg"></p>
<p>原来…<code>AddSecureRemoteProvider</code>这个Secure指的并不是使用安全链接https，而是在请求到内容后加了一个解密的步骤（Secure指请求的是加密过的内容，而不是使用加密链接请求），最后一个参数接收的也并不是客户端证书，而是解密的gpg key… 根据viper的文档，这个gpg key是可选的，我们这个例子中，如果给gpg key传入一个空字符串，也是可以正常执行的…</p>
<p>必须吐槽一下viper的命名，哪里是<code>AddSecureRemoteProvider</code>，明明应该叫<code>AddEncryptedRemoteProvider</code></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>出现这个问题，主要是误会了<code>AddSecureRemoteProvider</code>接口表达的意思，并且go-etcd允许忽略证书验证，也让问题变得更加离奇。</p>
<p>当然go-etcd的这种配置是非常合理的，内部系统使用自签名证书是一个很正常的行为。</p>

        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2020/03/31/use-pipfile-instead-of-requirements/">使用Pipfile代替reqirements.txt</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2020-03-31
        </span><span class="post-category">
            <a href="/categories/Python/">Python</a>
            </span>
        </div>
    </header>

    <div class="post-content"><p>很多语言都提供了环境隔离的支持，例如nodejs的node_module，golang的go mod，python也有virtualenv和pyvenv等机制。为了建立依赖快照，通常会用<code>pip freeze &gt; requirements.txt</code> 命令生成一个requirements.txt文件，在一些场景下这种方式就可以满足需求，但是在复杂场景下requirements.txt就力不从心了。</p>
<h3 id="requirements-txt"><a href="#requirements-txt" class="headerlink" title="requirements.txt"></a>requirements.txt</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">appdirs</span>==<span class="number">1</span>.<span class="number">4</span>.<span class="number">3</span></span><br><span class="line"><span class="attribute">astroid</span>==<span class="number">2</span>.<span class="number">3</span>.<span class="number">3</span></span><br><span class="line"><span class="attribute">attrs</span>==<span class="number">19</span>.<span class="number">3</span>.<span class="number">0</span></span><br><span class="line"><span class="attribute">black</span>==<span class="number">19</span>.<span class="number">3</span>b<span class="number">0</span></span><br><span class="line"><span class="attribute">certifi</span>==<span class="number">2019</span>.<span class="number">11</span>.<span class="number">28</span></span><br><span class="line"><span class="attribute">chardet</span>==<span class="number">3</span>.<span class="number">0</span>.<span class="number">4</span></span><br><span class="line"><span class="attribute">click</span>==<span class="number">7</span>.<span class="number">1</span>.<span class="number">1</span></span><br><span class="line"><span class="attribute">et</span>-xmlfile==<span class="number">1</span>.<span class="number">0</span>.<span class="number">1</span></span><br><span class="line"><span class="attribute">Flask</span>==<span class="number">1</span>.<span class="number">1</span>.<span class="number">1</span></span><br><span class="line"><span class="attribute">gevent</span>==<span class="number">1</span>.<span class="number">4</span>.<span class="number">0</span></span><br><span class="line"><span class="attribute">greenlet</span>==<span class="number">0</span>.<span class="number">4</span>.<span class="number">15</span></span><br><span class="line"><span class="attribute">idna</span>==<span class="number">2</span>.<span class="number">9</span></span><br><span class="line"><span class="attribute">isort</span>==<span class="number">4</span>.<span class="number">3</span>.<span class="number">21</span></span><br><span class="line"><span class="attribute">itsdangerous</span>==<span class="number">1</span>.<span class="number">1</span>.<span class="number">0</span></span><br><span class="line"><span class="attribute">jdcal</span>==<span class="number">1</span>.<span class="number">4</span>.<span class="number">1</span></span><br><span class="line"><span class="attribute">Jinja2</span>==<span class="number">2</span>.<span class="number">11</span>.<span class="number">1</span></span><br><span class="line"><span class="attribute">lazy</span>-object-proxy==<span class="number">1</span>.<span class="number">4</span>.<span class="number">3</span></span><br><span class="line"><span class="attribute">MarkupSafe</span>==<span class="number">1</span>.<span class="number">1</span>.<span class="number">1</span></span><br><span class="line"><span class="attribute">mccabe</span>==<span class="number">0</span>.<span class="number">6</span>.<span class="number">1</span></span><br><span class="line"><span class="attribute">numpy</span>==<span class="number">1</span>.<span class="number">18</span>.<span class="number">2</span></span><br><span class="line"><span class="attribute">openpyxl</span>==<span class="number">3</span>.<span class="number">0</span>.<span class="number">3</span></span><br><span class="line"><span class="attribute">pandas</span>==<span class="number">1</span>.<span class="number">0</span>.<span class="number">3</span></span><br><span class="line"><span class="attribute">pylint</span>==<span class="number">2</span>.<span class="number">4</span>.<span class="number">4</span></span><br><span class="line"><span class="attribute">python</span>-dateutil==<span class="number">2</span>.<span class="number">8</span>.<span class="number">1</span></span><br><span class="line"><span class="attribute">pytz</span>==<span class="number">2019</span>.<span class="number">3</span></span><br><span class="line"><span class="attribute">requests</span>==<span class="number">2</span>.<span class="number">23</span>.<span class="number">0</span></span><br><span class="line"><span class="attribute">six</span>==<span class="number">1</span>.<span class="number">14</span>.<span class="number">0</span></span><br><span class="line"><span class="attribute">tinydb</span>==<span class="number">3</span>.<span class="number">15</span>.<span class="number">2</span></span><br><span class="line"><span class="attribute">toml</span>==<span class="number">0</span>.<span class="number">10</span>.<span class="number">0</span></span><br><span class="line"><span class="attribute">typed</span>-ast==<span class="number">1</span>.<span class="number">4</span>.<span class="number">1</span></span><br><span class="line"><span class="attribute">urllib3</span>==<span class="number">1</span>.<span class="number">25</span>.<span class="number">8</span></span><br><span class="line"><span class="attribute">Werkzeug</span>==<span class="number">1</span>.<span class="number">0</span>.<span class="number">0</span></span><br><span class="line"><span class="attribute">wrapt</span>==<span class="number">1</span>.<span class="number">11</span>.<span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>requirements.txt文件中只记录了依赖的版本，所以如果遇到官方的pypi源下载速度慢，需要使用更快的国内镜像下载，通常只能使用<code>pip install -i</code>安装或者修改全局的pip.conf文件。</p>
<p>当某个项目使用确定的python版本，这个版本也并不能在requirements.txt中体现，只能通过readme或者文档来记录，并且需要在创建虚拟环境时手动调用正确的python版本。</p>
<p>项目需要使用flake8、pylint、black等代码优化工具时，这些依赖也会被<code>pip freeze</code>命令写入requirements.txt中，然而这些依赖是不需要出现在生产环境的。</p>
<h3 id="Pipfile"><a href="#Pipfile" class="headerlink" title="Pipfile"></a>Pipfile</h3><p>Pipenv的出现，一举解决了上面的问题，Pipenv是Kenneth Reitz在2017年1月发布的Python依赖管理工具，他所基于的Pipfile则用来替代requirements.txt。</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[[source]]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">&quot;pypi&quot;</span></span><br><span class="line"><span class="attr">url</span> = <span class="string">&quot;https://pypi.doubanio.com/simple&quot;</span></span><br><span class="line"><span class="attr">verify_ssl</span> = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="section">[dev-packages]</span></span><br><span class="line"><span class="attr">isort</span> = <span class="string">&quot;*&quot;</span></span><br><span class="line"><span class="attr">black</span> = <span class="string">&quot;==19.3b0&quot;</span></span><br><span class="line"><span class="attr">pylint</span> = <span class="string">&quot;*&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="section">[packages]</span></span><br><span class="line"><span class="attr">flask</span> = <span class="string">&quot;*&quot;</span></span><br><span class="line"><span class="attr">tinydb</span> = <span class="string">&quot;*&quot;</span></span><br><span class="line"><span class="attr">pandas</span> = <span class="string">&quot;*&quot;</span></span><br><span class="line"><span class="attr">requests</span> = <span class="string">&quot;*&quot;</span></span><br><span class="line"><span class="attr">gevent</span> = <span class="string">&quot;*&quot;</span></span><br><span class="line"><span class="attr">openpyxl</span> = <span class="string">&quot;*&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="section">[requires]</span></span><br><span class="line"><span class="attr">python_version</span> = <span class="string">&quot;3.6&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="好处1：记录内容更详细"><a href="#好处1：记录内容更详细" class="headerlink" title="好处1：记录内容更详细"></a>好处1：记录内容更详细</h4><p>相比于requirements.txt，Pipfile多了pip源的设置，可以针对不同项目使用不同环境。并且将依赖分为dev和默认环境，例如pylint、flake8、black等依赖，可以将他们放入dev依赖中。</p>
<h4 id="好处2：减少手动激活虚拟环境次数"><a href="#好处2：减少手动激活虚拟环境次数" class="headerlink" title="好处2：减少手动激活虚拟环境次数"></a>好处2：减少手动激活虚拟环境次数</h4><p>pipenv将virtualenv、pyvenv和pip命令整合使用，pipenv减少了手动激活虚拟环境的次数，使用pyvenv模块运行main.py，需要先执行<code>source venv/bin/activate</code>激活虚拟环境，然后再执行<code>python main.py</code>，而pipenv只需要在项目根目录执行<code>pipenv run main.py</code> ，就可以自动激活当前虚拟环境并执行main.py。如果需要安装依赖的，直接执行<code>pipenv install xxx</code>，也不需要先激活虚拟环境，再使用<code>pip install xxx</code>安装。</p>
<h4 id="好处3：锁机制"><a href="#好处3：锁机制" class="headerlink" title="好处3：锁机制"></a>好处3：锁机制</h4><p>从Pipfile文件添加或删除安装的包，会生成Pipfile.lock来锁定安装包的版本和依赖信息，通过pipfile.lock文件，可以精确恢复以来的版本。</p>
<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 初始化虚拟环境（可自己指定python版本）</span></span><br><span class="line"><span class="variable">$ </span>pipenv --python <span class="number">3.6</span>.<span class="number">9</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 激活当前项目虚拟环境</span></span><br><span class="line"><span class="variable">$ </span>pipenv shell</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装开发依赖包</span></span><br><span class="line"><span class="variable">$ </span>pipenv install black --dev</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成lock文件</span></span><br><span class="line"><span class="variable">$ </span>pipenv lock</span><br></pre></td></tr></table></figure>

        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2019/10/28/dockers-creepy-behaviour-in-copying-folders/">Docker COPY 复制文件夹的诡异行为</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2019-10-28
        </span><span class="post-category">
            <a href="/categories/DevOps/">DevOps</a>
            </span>
        </div>
    </header>

    <div class="post-content"><h3 id="问题现象"><a href="#问题现象" class="headerlink" title="问题现象"></a>问题现象</h3><p>在制作 docker 镜像时，有复制某一个路径下所有文件和文件夹到镜像的需求，写下了如下 dockerfile：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> alpine</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /root/test_docker_proj</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> * ./</span></span><br></pre></td></tr></table></figure>

<p>原始目录结构是这样的：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/projects/test_docker_proj</span><br><span class="line">├── Dockerfile</span><br><span class="line">├── dir1</span><br><span class="line">│   ├── dir11</span><br><span class="line">│   │   └── file11</span><br><span class="line">│   └── file1</span><br><span class="line">└── file2</span><br></pre></td></tr></table></figure>

<p>然而复制到 docker 镜像里的目录结构变成了这样：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/root/test_docker_proj</span><br><span class="line">├── Dockerfile</span><br><span class="line">├── dir11</span><br><span class="line">│   └── file11</span><br><span class="line">├── file1</span><br><span class="line">└── file2</span><br></pre></td></tr></table></figure>
          <div class="read-more">
            <a href="/2019/10/28/dockers-creepy-behaviour-in-copying-folders/" class="read-more-link">阅读更多</a>
          </div>
        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2019/08/22/solution-for-pandas-assertion-error-while-reading-an-excel-file/">探究 Pandas 读取 Excel 文件报错问题</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2019-08-22
        </span><span class="post-category">
            <a href="/categories/Python/">Python</a>
            </span>
        </div>
    </header>

    <div class="post-content"><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>使用 Pandas 的 <code>read_excel</code> 方法读取一个 16 万行的 Excel 文件报 <code>AssertionError</code> 错误：</p>
<figure class="highlight hsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  <span class="string">&quot;/Users/XXX/excel_test/venv/lib/python3.7/site-packages/xlrd/xlsx.py&quot;</span>, <span class="keyword">line</span> <span class="number">637</span>, in do_row</span><br><span class="line">    <span class="keyword">assert</span> <span class="number">0</span> &lt;= self.rowx &lt; X12_MAX_ROWS</span><br><span class="line">AssertionError</span><br></pre></td></tr></table></figure>
          <div class="read-more">
            <a href="/2019/08/22/solution-for-pandas-assertion-error-while-reading-an-excel-file/" class="read-more-link">阅读更多</a>
          </div>
        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2019/04/18/building-docker-image-behind-proxy/">使用代理进行 docker build 问题的解决思路</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2019-04-18
        </span><span class="post-category">
            <a href="/categories/DevOps/">DevOps</a>
            </span>
        </div>
    </header>

    <div class="post-content"><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>在使用 docker build 打包镜像时，遇到了需要使用代理访问网络的需求。使用如下的 Dockerfile 来模拟这个场景：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> golang:<span class="number">1.12</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> curl www.google.com --max-time 3</span></span><br></pre></td></tr></table></figure>

<p>国内一般网络环境下，curl <a target="_blank" rel="noopener" href="http://www.google.com/">www.google.com</a> 是无法正常返回的，加入 –max-time 让 curl 的耗时不要太长。</p>
          <div class="read-more">
            <a href="/2019/04/18/building-docker-image-behind-proxy/" class="read-more-link">阅读更多</a>
          </div>
        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2019/04/16/understanding-postgres-count-function/">理解 PostgreSQL 的 count 函数的行为</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2019-04-16
        </span><span class="post-category">
            <a href="/categories/DevOps/">DevOps</a>
            </span>
        </div>
    </header>

    <div class="post-content"><p>关于 count 函数的使用一直存在争议，尤其是在 MySQL 中，作为流行度越来越高的 PostgreSQL 是否也有类似的问题呢，我们通过实践来理解一下 PostgreSQL 中 count 函数的行为。</p>
          <div class="read-more">
            <a href="/2019/04/16/understanding-postgres-count-function/" class="read-more-link">阅读更多</a>
          </div>
        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2019/03/26/solution-to-problem-of-jwt-token-invalidation/">JWT 避坑指南：nbf 验签失效问题的解决</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2019-03-26
        </span><span class="post-category">
            <a href="/categories/Tech/">Tech</a>
            </span>
        </div>
    </header>

    <div class="post-content"><h3 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h3><p>刚签发的 JWT，在下一个请求使用时候会失效，请求会报 422 错误。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;msg&quot;</span>: <span class="string">&quot;The token is not yet valid (nbf)&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果隔几秒再请求（例如使用 Chrome 开发者工具中的 Replay XHR），就会成功。</p>
          <div class="read-more">
            <a href="/2019/03/26/solution-to-problem-of-jwt-token-invalidation/" class="read-more-link">阅读更多</a>
          </div>
        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2019/02/28/update-error-on-nginx-ingress-gunicorn-environment/">nginx + ingress + gunicorn 环境上传大文件报错问题的解决思路</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2019-02-28
        </span><span class="post-category">
            <a href="/categories/DevOps/">DevOps</a>
            </span>
        </div>
    </header>

    <div class="post-content"><p><img src="/upload/20190228_01.jpeg"></p>
<p>在基于 Kubernetes 部署，使用 Gunicorn 运行的 Python Web 应用中，上传大文件时出现了一系列的错误，现在将解决问题的思路记录如下。</p>
          <div class="read-more">
            <a href="/2019/02/28/update-error-on-nginx-ingress-gunicorn-environment/" class="read-more-link">阅读更多</a>
          </div>
        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2019/01/25/practice-on-python-logging/">Python 日志库 logging 的理解和实践经验</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2019-01-25
        </span><span class="post-category">
            <a href="/categories/Python/">Python</a>
            </span>
        </div>
    </header>

    <div class="post-content"><p><img src="/upload/20190125_01.jpg"></p>
<p>本文从 Python logging 库的基础概念入手，理解 logging 库的执行流程，以及可能忽视的一些细节。</p>
          <div class="read-more">
            <a href="/2019/01/25/practice-on-python-logging/" class="read-more-link">阅读更多</a>
          </div>
        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2018/12/24/practice-in-json-with-go/">go json 实践中遇到的坑</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-12-24
        </span><span class="post-category">
            <a href="/categories/Golang/">Golang</a>
            </span>
        </div>
    </header>

    <div class="post-content"><p><img src="/upload/20181224_01.png"></p>
<p>在使用 go 语言开发过程中，经常需要使用到 json 包来进行 json 和 struct 的互相转换，在使用过程中，遇到了一些需要额外注意的地方，记录如下。</p>
          <div class="read-more">
            <a href="/2018/12/24/practice-in-json-with-go/" class="read-more-link">阅读更多</a>
          </div>
        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2018/12/13/combining-jwt-with-refresh-token/">基于 JWT + Refresh Token 的用户认证实践</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-12-13
        </span><span class="post-category">
            <a href="/categories/Tech/">Tech</a>
            </span>
        </div>
    </header>

    <div class="post-content"><p><img src="/upload/20181213_01.jpg"></p>
<p>HTTP 是一个无状态的协议，一次请求结束后，下次在发送服务器就不知道这个请求是谁发来的了（同一个 IP 不代表同一个用户），在 Web 应用中，用户的认证和鉴权是非常重要的一环，实践中有多种可用方案，并且各有千秋。</p>
          <div class="read-more">
            <a href="/2018/12/13/combining-jwt-with-refresh-token/" class="read-more-link">阅读更多</a>
          </div>
        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2018/12/10/ssh-via-ngrok/">通过 ngrok 实现 ssh 内网穿透</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-12-10
        </span><span class="post-category">
            <a href="/categories/Tech/">Tech</a>
            </span>
        </div>
    </header>

    <div class="post-content"><h3 id="ngrok"><a href="#ngrok" class="headerlink" title="ngrok"></a>ngrok</h3><p>用 ssh 访问一台主机，如果和主机在一个局域网中或者主机拥有公网 IP，就可以使用 ssh 命令直接连接主机的 IP 地址，但是大部分公司和家庭内部都是局域网，并不能给局域网内的每一台主机都分配一个公网 IP，这时候就需要进行内网穿透，才能从外部连接到局域网内的主机。</p>
<p>ngrok 是一个反向代理工具，可以实现将内网的端口暴露到公网，通过 ngrok，也能将 ssh 使用的端口暴露出去，以此实现 ssh 的内网穿透。</p>
          <div class="read-more">
            <a href="/2018/12/10/ssh-via-ngrok/" class="read-more-link">阅读更多</a>
          </div>
        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2018/12/07/unicode-and-utf-8/">Unicode 和 UTF-8</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-12-07
        </span><span class="post-category">
            <a href="/categories/Tech/">Tech</a>
            </span>
        </div>
    </header>

    <div class="post-content"><p><img src="/upload/20181207_01.jpg"></p>
<p>Unicode 和 UTF-8 的概念是一个非常基础和重要，但是却容易被忽略的问题。</p>
          <div class="read-more">
            <a href="/2018/12/07/unicode-and-utf-8/" class="read-more-link">阅读更多</a>
          </div>
        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2018/10/26/understand-time-struct-in-go/">理解Golang的Time结构</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-10-26
        </span><span class="post-category">
            <a href="/categories/Golang/">Golang</a>
            </span>
        </div>
    </header>

    <div class="post-content"><p><img src="/upload/20181026_01.png"></p>
<p>在golang中创建并打印一个时间对象，会看到如下输出</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">2018</span>-<span class="number">10</span>-<span class="number">26</span> <span class="number">14</span>:<span class="number">15</span>:<span class="number">50</span>.<span class="number">306558969</span> +<span class="number">0800</span> CST m=+<span class="number">0</span>.<span class="number">000401093</span></span><br></pre></td></tr></table></figure>

<p>前面表示的意义好理解，分别是年月日和时间时区，最后的m=+xxxx这部分代表什么呢？</p>
          <div class="read-more">
            <a href="/2018/10/26/understand-time-struct-in-go/" class="read-more-link">阅读更多</a>
          </div>
        </div></article>
      <nav class="pagination"><a class="next" href="/page/2/">
        <span class="next-text">下一页</span>
        <i class="iconfont icon-right"></i>
      </a>
    </nav></section></div></div>
      </main>

      <footer id="footer" class="footer"><div class="social-links"><a href="mailto:zangzhiya@gmail.com" class="iconfont icon-email" title="email"></a>
        <a target="_blank" rel="noopener" href="https://github.com/simpleapples" class="iconfont icon-github" title="github"></a>
        <a target="_blank" rel="noopener" href="https://www.zhihu.com/people/simpleapples" class="iconfont icon-zhihu" title="zhihu"></a>
        <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
    </div><div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" target="_blank" rel="noopener" href="https://github.com/ahonn/hexo-theme-even">Even</a>
  </span>

  <span class="copyright-year">&copy;2012 - 2021<span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">simpleapples</span>
  </span>
</div>
</footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div><script type="text/javascript" src="/lib/jquery/jquery.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/src/even.js?v=2.11.0"></script>
</body>
</html>
