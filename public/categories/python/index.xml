<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Python on Zhiya&#39;s Blog</title>
    <link>http://localhost:1313/categories/python/</link>
    <description>Recent content in Python on Zhiya&#39;s Blog</description>
    <generator>Hugo -- 0.147.8</generator>
    <language>cn</language>
    <lastBuildDate>Sat, 06 Nov 2021 08:25:00 +0000</lastBuildDate>
    <atom:link href="http://localhost:1313/categories/python/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Python跨服务传递作用域的坑</title>
      <link>http://localhost:1313/posts/python-cross-scope-issue/</link>
      <pubDate>Sat, 06 Nov 2021 08:25:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/python-cross-scope-issue/</guid>
      <description>&lt;h1 id=&#34;背景&#34;&gt;背景&lt;/h1&gt;
&lt;p&gt;在一个古老的系统中，有这样一段代码：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;scope &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; dict(globals(), &lt;span style=&#34;color:#f92672&#34;&gt;**&lt;/span&gt;locals())
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;exec(
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;#34;&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;global_a = 123
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;def func_a():
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;    print(global_a)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;#34;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;, scope)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;exec(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;func_a()&amp;#34;&lt;/span&gt;, scope)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;第一段用户代码定义了函数，第二段用户代码执行函数（不要问为什么这么做，因为用户永远是正确的）。第一个代码段执行后，func_a 和 global_a 都会被加入作用域 scope，由于第二个代码段也使用同一个 scope，所以第二个代码段调用 func_a 是可以正确输出 123 的。&lt;/p&gt;
&lt;p&gt;但是使用 exec 执行用户代码毕竟不优雅，也很危险，于是把 exec 函数封装在了一个 Python 沙箱环境中（简单理解就是另一个 Python 服务，将 code 和 scope 传给这个服务后，服务会在沙箱环境调用 exec(code,scope)执行代码），相当于每一次对 exec 调用都替换成了对沙箱服务的 RPC 请求。&lt;/p&gt;
&lt;p&gt;于是代码变成了这个样子：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;scope &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; dict(globals(), &lt;span style=&#34;color:#f92672&#34;&gt;**&lt;/span&gt;locals())
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;scope &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; call_sandbox(
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;#34;&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;global_a = 123
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;def func_a():
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;    print(global_a)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;#34;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;, scope)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;call_sandbox(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;func_a()&amp;#34;&lt;/span&gt;, scope)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h1 id=&#34;作用域跨服务传递问题&#34;&gt;作用域跨服务传递问题&lt;/h1&gt;
&lt;p&gt;由于多次 RPC 调用需要使用同一个作用域，所以沙箱服务返回了新的 scope，以保证下次调用时作用域不会丢失。但是执行代码会发现第二次 call_sandbox 调用时候，会返回错误：&lt;/p&gt;</description>
    </item>
    <item>
      <title>利用AWS Lambda和iOS捷径实现手机一键开小区门禁</title>
      <link>http://localhost:1313/posts/one-click-open-door-based-on-aws-lambda-and-ios-shortcut/</link>
      <pubDate>Tue, 19 Oct 2021 22:30:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/one-click-open-door-based-on-aws-lambda-and-ios-shortcut/</guid>
      <description>&lt;p&gt;我住的小区使用了一个叫守望领域的智能门禁系统，可以通过手机 App 开小区门禁和单元门，但是用 App 开门需要经过四五步：打开 App→ 进入开门界面 → 找到需要开的门 → 点击开门。&lt;/p&gt;
&lt;center&gt;&lt;img style=&#34;margin: 0 10px&#34; src=&#34;http://localhost:1313/images/20211019_01.png&#34; width=&#34;200&#34;/&gt;&lt;img style=&#34;margin: 0 10px&#34; src=&#34;http://localhost:1313/images/20211019_02.png&#34; width=&#34;200&#34;/&gt;&lt;img style=&#34;margin: 0 10px&#34; src=&#34;http://localhost:1313/images/20211019_03.png&#34; width=&#34;200&#34;/&gt;&lt;/center&gt;
&lt;p&gt;加上戴口罩时候解锁手机需要输入密码，导致整个流程非常耗时，经常需要站在小区门口和单元门口操作半天，有一段时间我甚至养成了携带实体门禁卡的习惯，实体门禁卡开门要快很多。&lt;/p&gt;
&lt;p&gt;最近又开始忘带门禁卡，苦恼之余发现 iOS 在锁屏界面右划可以免解锁直接进入 spotlight 界面，这个界面可以添加捷径，如果能写一个捷径去调用守望领域 App 的 API 开门，就可以实现手机免解锁一键开门。&lt;/p&gt;
&lt;center&gt;&lt;img src=&#34;http://localhost:1313/images/20211019_04.gif&#34; width=&#34;300&#34;/&gt;&lt;/center&gt;
&lt;h1 id=&#34;查找-api&#34;&gt;查找 API&lt;/h1&gt;
&lt;p&gt;首先需要通过 Charles 之类的软件查找 App 调用的 API，配置 Charles 查看 App 请求的方式不再赘述，Google 一下可以看到很多教程。直接看结果 Charles 的结果，可以看到 api.lookdoor.cn 是这个软件所请求的 API 域名。&lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/20211019_05.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;打开软件发的请求非常多，经过操作和请求的对比可以看到，发送开门指令调用的 API 是：/func/hjapp/house/v1/pushOpenDoorBySn.json?equipmentId=xxxxxx 这个路径。&lt;/p&gt;
&lt;p&gt;详细查看这个请求可以发现，equipmentId 指的就是小区门的 Id，接口使用 cookie 做认证，只要将 cookie 带上就可以模拟开门指令。&lt;/p&gt;
&lt;h1 id=&#34;第一次尝试&#34;&gt;第一次尝试&lt;/h1&gt;
&lt;p&gt;打开 iOS 捷径 App，创建一个新捷径，App 调用 API 使用了 POST 请求，搜索 Get contents of 这个动作来实现发送 POST 请求。&lt;/p&gt;</description>
    </item>
    <item>
      <title>gRPC 跨进程使用引发的问题</title>
      <link>http://localhost:1313/posts/grpc-fork-support/</link>
      <pubDate>Thu, 23 Apr 2020 14:30:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/grpc-fork-support/</guid>
      <description>&lt;h3 id=&#34;问题描述&#34;&gt;问题描述&lt;/h3&gt;
&lt;p&gt;在 Python 项目中使用 gRPC 进行通信，跨进程使用时，会出现阻塞或报错的情况（根据 gRPC.io 的版本不同，现象不同）。下面代码展示了一个跨进程使用的 DEMO，主进程向 30001 端口上的 gRPC 服务器发送请求，子进程也向相同的服务器发送请求。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;send&lt;/span&gt;():
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    channel &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; grpc&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;insecure_channel(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;localhost:30001&amp;#39;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    stub &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; message_pb2_grpc&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;GreeterStub(channel)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    response &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; stub&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;SayHello(message_pb2&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;HelloRequest(name&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;you&amp;#39;&lt;/span&gt;))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    print(&lt;span style=&#34;color:#e6db74&#34;&gt;f&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Greeter client received 1: &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; response&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;message)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;():
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    channel &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; grpc&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;insecure_channel(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;localhost:30001&amp;#39;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    stub &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; message_pb2_grpc&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;GreeterStub(channel)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    response &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; stub&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;SayHello2(message_pb2&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;HelloRequest(name&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;you&amp;#39;&lt;/span&gt;))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    print(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Greeter client received 2: &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; response&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;message)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    p &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; multiprocessing&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;Process(target&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;send)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    p&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;start()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    p&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;join()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; __name__ &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;__main__&amp;#39;&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    main()
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;使用 gRPC.io 1.28.1 的情况下，会发生报错，主进程可以正常收到服务器的返回，但是子进程报 &lt;code&gt;Socket operation on non-socket&lt;/code&gt;。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;raise _InactiveRpcError&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;state&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;grpc._channel._InactiveRpcError: &amp;lt;_InactiveRpcError of RPC that terminated with:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        status &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; StatusCode.UNAVAILABLE
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        details &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Socket operation on non-socket&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        debug_error_string &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;{&amp;#34;&lt;/span&gt;created&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;:&amp;#34;&lt;/span&gt;@1587481625.192071231&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;,&amp;#34;&lt;/span&gt;description&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;:&amp;#34;&lt;/span&gt;Error received from peer ipv6:&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;::1&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;:50051&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;,&amp;#34;&lt;/span&gt;file&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;:&amp;#34;&lt;/span&gt;src/core/lib/surface/call.cc&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;,&amp;#34;&lt;/span&gt;file_line&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;:1056,&amp;#34;&lt;/span&gt;grpc_message&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;:&amp;#34;&lt;/span&gt;Socket operation on non-socket&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;,&amp;#34;&lt;/span&gt;grpc_status&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;:14}&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;排查过程&#34;&gt;排查过程&lt;/h3&gt;
&lt;p&gt;根据代码，主进程和子进程分别创建了自己的 Channel，看上去逻辑没什么问题，没有什么思路，所以多尝试几种情况先测试一下吧。首先尝试了一下主进程和子进程请求不同的server，在 30001 和 30002 端口分别启动两个 gRPC Server，然后将客户端代码改为主进程请求 30001 端口，子进程请求 30002 端口，代码可以正常运行。测试到这里就更摸不着头脑了，代码明明写的是主进程子进程分别创建 Channel，现在的现象看上去&lt;strong&gt;像是在请求相同服务器的情况下，子进程复用了主进程的socket连接&lt;/strong&gt;。gRPC 底层使用的是 HTTP2，而 HTTP2 使用了长连接，会不会是这个原因？&lt;/p&gt;</description>
    </item>
    <item>
      <title>使用Pipfile代替reqirements.txt</title>
      <link>http://localhost:1313/posts/use-pipfile-instead-of-requirements/</link>
      <pubDate>Tue, 31 Mar 2020 12:50:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/use-pipfile-instead-of-requirements/</guid>
      <description>&lt;p&gt;很多语言都提供了环境隔离的支持，例如nodejs的node_module，golang的go mod，python也有virtualenv和pyvenv等机制。为了建立依赖快照，通常会用&lt;code&gt;pip freeze &amp;gt; requirements.txt&lt;/code&gt; 命令生成一个requirements.txt文件，在一些场景下这种方式就可以满足需求，但是在复杂场景下requirements.txt就力不从心了。&lt;/p&gt;
&lt;h3 id=&#34;requirementstxt&#34;&gt;requirements.txt&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;appdirs==1.4.3
astroid==2.3.3
attrs==19.3.0
black==19.3b0
certifi==2019.11.28
chardet==3.0.4
click==7.1.1
et-xmlfile==1.0.1
Flask==1.1.1
gevent==1.4.0
greenlet==0.4.15
idna==2.9
isort==4.3.21
itsdangerous==1.1.0
jdcal==1.4.1
Jinja2==2.11.1
lazy-object-proxy==1.4.3
MarkupSafe==1.1.1
mccabe==0.6.1
numpy==1.18.2
openpyxl==3.0.3
pandas==1.0.3
pylint==2.4.4
python-dateutil==2.8.1
pytz==2019.3
requests==2.23.0
six==1.14.0
tinydb==3.15.2
toml==0.10.0
typed-ast==1.4.1
urllib3==1.25.8
Werkzeug==1.0.0
wrapt==1.11.2
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;requirements.txt文件中只记录了依赖的版本，所以如果遇到官方的pypi源下载速度慢，需要使用更快的国内镜像下载，通常只能使用&lt;code&gt;pip install -i&lt;/code&gt;安装或者修改全局的pip.conf文件。&lt;/p&gt;
&lt;p&gt;当某个项目使用确定的python版本，这个版本也并不能在requirements.txt中体现，只能通过readme或者文档来记录，并且需要在创建虚拟环境时手动调用正确的python版本。&lt;/p&gt;
&lt;p&gt;项目需要使用flake8、pylint、black等代码优化工具时，这些依赖也会被&lt;code&gt;pip freeze&lt;/code&gt;命令写入requirements.txt中，然而这些依赖是不需要出现在生产环境的。&lt;/p&gt;
&lt;h3 id=&#34;pipfile&#34;&gt;Pipfile&lt;/h3&gt;
&lt;p&gt;Pipenv的出现，一举解决了上面的问题，Pipenv是Kenneth Reitz在2017年1月发布的Python依赖管理工具，他所基于的Pipfile则用来替代requirements.txt。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;[[source]]
name = &amp;#34;pypi&amp;#34;
url = &amp;#34;https://pypi.doubanio.com/simple&amp;#34;
verify_ssl = false

[dev-packages]
isort = &amp;#34;*&amp;#34;
black = &amp;#34;==19.3b0&amp;#34;
pylint = &amp;#34;*&amp;#34;

[packages]
flask = &amp;#34;*&amp;#34;
tinydb = &amp;#34;*&amp;#34;
pandas = &amp;#34;*&amp;#34;
requests = &amp;#34;*&amp;#34;
gevent = &amp;#34;*&amp;#34;
openpyxl = &amp;#34;*&amp;#34;

[requires]
python_version = &amp;#34;3.6&amp;#34;
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;好处1记录内容更详细&#34;&gt;好处1：记录内容更详细&lt;/h4&gt;
&lt;p&gt;相比于requirements.txt，Pipfile多了pip源的设置，可以针对不同项目使用不同环境。并且将依赖分为dev和默认环境，例如pylint、flake8、black等依赖，可以将他们放入dev依赖中。&lt;/p&gt;</description>
    </item>
    <item>
      <title>探究 Pandas 读取 Excel 文件报错问题</title>
      <link>http://localhost:1313/posts/solution-for-pandas-assertion-error-while-reading-an-excel-file/</link>
      <pubDate>Thu, 22 Aug 2019 15:50:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/solution-for-pandas-assertion-error-while-reading-an-excel-file/</guid>
      <description>&lt;h3 id=&#34;问题描述&#34;&gt;问题描述&lt;/h3&gt;
&lt;p&gt;使用 Pandas 的 &lt;code&gt;read_excel&lt;/code&gt; 方法读取一个 16 万行的 Excel 文件报 &lt;code&gt;AssertionError&lt;/code&gt; 错误：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;  &amp;#34;/Users/XXX/excel_test/venv/lib/python3.7/site-packages/xlrd/xlsx.py&amp;#34;, line 637, in do_row
    assert 0 &amp;lt;= self.rowx &amp;lt; X12_MAX_ROWS
AssertionError
&lt;/code&gt;&lt;/pre&gt;&lt;!-- more --&gt; 
&lt;h3 id=&#34;背后原理&#34;&gt;背后原理&lt;/h3&gt;
&lt;p&gt;Excel 文件有两种默认格式，在 Excel 2007 以前，使用扩展名为 &lt;code&gt;.xls&lt;/code&gt; 格式的文件，这种文件格式是一种特定的二进制格式，最多支持 65,536 行（在 Excel 97 之前支持的最大行数是 16,384），256 列表格。从 Excel 2007 版开始，默认采用了基于 XML 的新的文件格式 &lt;code&gt;.xlsx&lt;/code&gt;，支持的表格行数达到了 1,048,576，列数达到了 16,384。需要注意的是，将 &lt;code&gt;.xlsx&lt;/code&gt; 格式的文件转换为 &lt;code&gt;.xls&lt;/code&gt; 格式的文件时，65,536 行和 256 列之后的数据都会被丢弃。&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;版本&lt;/th&gt;
          &lt;th&gt;最大行数&lt;/th&gt;
          &lt;th&gt;最大列数&lt;/th&gt;
          &lt;th&gt;文件格式&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;Excel 97 之前&lt;/td&gt;
          &lt;td&gt;16,384&lt;/td&gt;
          &lt;td&gt;256&lt;/td&gt;
          &lt;td&gt;.xls&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Excel 97 到 Excel 2003&lt;/td&gt;
          &lt;td&gt;65,536&lt;/td&gt;
          &lt;td&gt;256&lt;/td&gt;
          &lt;td&gt;.xls&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Excel 2007 及以后版本&lt;/td&gt;
          &lt;td&gt;1,048,576&lt;/td&gt;
          &lt;td&gt;16,384&lt;/td&gt;
          &lt;td&gt;.xlsx&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Pandas 读取 Excel 文件的引擎是 &lt;code&gt;xlrd&lt;/code&gt;，&lt;code&gt;xlrd&lt;/code&gt; 在读取 Excel 文件时，&lt;a href=&#34;https://github.com/python-excel/xlrd/blob/master/xlrd/xlsx.py&#34;&gt;&lt;code&gt;xlrd/xlsx.py&lt;/code&gt;&lt;/a&gt; 文件的 637 行会对行号做断言，判断行号是否在 0 - 1,048,576（Excel支持的最大行数） 的范围内。这段代码是这样的：&lt;/p&gt;</description>
    </item>
    <item>
      <title>Python 日志库 logging 的理解和实践经验</title>
      <link>http://localhost:1313/posts/practice-on-python-logging/</link>
      <pubDate>Fri, 25 Jan 2019 15:18:16 +0000</pubDate>
      <guid>http://localhost:1313/posts/practice-on-python-logging/</guid>
      <description>&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/20190125_01.jpg&#34;&gt;&lt;/p&gt;
&lt;p&gt;本文从 Python logging 库的基础概念入手，理解 logging 库的执行流程，以及可能忽视的一些细节。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h3 id=&#34;日志级别&#34;&gt;日志级别&lt;/h3&gt;
&lt;p&gt;logging 库预置了 5 个错误级别，还有一个 &lt;code&gt;NOTSET&lt;/code&gt; 级别，作为 logger 的默认值。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;CRITICAL &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;50&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;ERROR &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;40&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;WARNING &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;30&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;INFO &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;20&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;DEBUG &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;NOTSET &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;logging 库也支持自定义错误级别，通过上面的源码可以看到，在不同级别的错误中间预留了 10 个数字的位置，方便我们在预置错误级别的基础上添加更细致的错误级别。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; logging
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;logging&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;addLevelName(&lt;span style=&#34;color:#ae81ff&#34;&gt;31&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;SERIOUS WARNING&amp;#39;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;logger &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; logging&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;getLogger(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;log&amp;#39;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;logger&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;warn(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;warn info&amp;#39;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;logger&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;log(logging&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;getLevelName(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;SERIOUS_WARNING&amp;#39;&lt;/span&gt;), &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;serious warn&amp;#39;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;例如添加一个 SERIOUS WARNING 类型的错误，值为 31，就可以用 log 方法输出该级别的错误。&lt;/p&gt;
&lt;p&gt;也可以覆盖 logging 预置的错误级别，例如将 WARNING 修改为 SERIOUS WARNING。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;logging&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;addLevelName(&lt;span style=&#34;color:#ae81ff&#34;&gt;30&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;SERIOUS WARNING&amp;#39;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;logger &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; logging&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;getLogger(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;log&amp;#39;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;print(logging&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;getLevelName(&lt;span style=&#34;color:#ae81ff&#34;&gt;30&lt;/span&gt;))  &lt;span style=&#34;color:#75715e&#34;&gt;# SERIOUS WARNING&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;logrecordformatter&#34;&gt;LogRecord、Formatter&lt;/h3&gt;
&lt;p&gt;logging 库中的每一条 log 都以 LogRecord 的形式存在，当调用 logger 打印 log 时候，都会有一条 LogRecord 被自动创建出来，LogRecord 中包含了大量的和该条日志相关的属性，也包含用户传入的 message。&lt;/p&gt;</description>
    </item>
    <item>
      <title>翻译 | 更快的Python（二）</title>
      <link>http://localhost:1313/posts/faster-python-part-2/</link>
      <pubDate>Thu, 25 Oct 2018 18:20:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/faster-python-part-2/</guid>
      <description>&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/20181025_11.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;更快的 Python（&lt;a href=&#34;http://pythonfasterway.org&#34;&gt;Python Faster Way&lt;/a&gt;）使用代码示例来说明如何书写 Python 代码能带来更高的性能。本文对代码进行了讲解，从性能和可读性等角度来选择出最适合的写法。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h3 id=&#34;例子-11字符串连接&#34;&gt;例子 11：字符串连接&lt;/h3&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/20181025_01.png&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最差/最优时间比：&lt;strong&gt;1.15&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;使用建议：一次性连接多个（3 个以上）的字符串的时候，使用 join，其他情况使用加号或 f-string。&lt;/li&gt;
&lt;li&gt;说明：又是一个字符串连接的问题，不过这个例子举的不好，join 适用的场景是一次连接多个字符串，会比加号连接多个字符串要快很多（加号相当于一个一个连接）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;例子-12数字的格式化&#34;&gt;例子 12：数字的格式化&lt;/h3&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/20181025_02.png&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最差/最优时间比：&lt;strong&gt;1.29&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;使用建议：需要复杂格式，推荐使用 format 方法；将数字转换为字符串，直接使用 str 方法。&lt;/li&gt;
&lt;li&gt;说明：将数字转为字符串，使用 str 方法要快于 format 方法，因为 format 方法支持在转换过程中增加规则，例如将数字转为货币形式（每三位加一个逗号分隔符）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;例子-13获取内置列表类型的长度&#34;&gt;例子 13：获取内置列表类型的长度&lt;/h3&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/20181025_03.png&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最差/最优时间比：&lt;strong&gt;1.20&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;使用建议：使用 len()方法。&lt;/li&gt;
&lt;li&gt;说明：当调用 len()方法时，系统实际上是调用了对象内置的&lt;strong&gt;len&lt;/strong&gt;方法，从这个层面理解，直接调用&lt;strong&gt;len&lt;/strong&gt;应该比 len()方法更快。但是当 len()内置的列表方法时，Python 解释器做了优化，直接返回了列表对象中存储长度信息的变量，并不会调用&lt;strong&gt;len&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;例子-14整数类型的运算&#34;&gt;例子 14：整数类型的运算&lt;/h3&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/20181025_04.png&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最差/最优时间比：&lt;strong&gt;2.63&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;使用建议：不要直接调用&lt;strong&gt;add&lt;/strong&gt;等魔术方法。&lt;/li&gt;
&lt;li&gt;说明：对于整数类型，调用魔术方法完成运算的速度远远慢于直接使用运算符，使用运算符时，Python 解释器直接调用 C 实现的 operaotr 包中的运算方法，所以速度很快；而使用调用魔术方法，在 Python 层面多出了调用&lt;strong&gt;add&lt;/strong&gt;等魔术方法的额外操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;例子-15自定义类型的运算符重载&#34;&gt;例子 15：自定义类型的运算符重载&lt;/h3&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/20181025_05.png&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最差/最优时间比：&lt;strong&gt;1.06&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;使用建议：不要直接调用&lt;strong&gt;add&lt;/strong&gt;等魔术方法。&lt;/li&gt;
&lt;li&gt;说明：对于重载了运算符的对象，没有对应的 C 实现运算方法，所以直接直接调用魔术方法速度会更快。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;例子-16对-range-结果求和&#34;&gt;例子 16：对 range 结果求和&lt;/h3&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/20181025_06.png&#34;&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>翻译 | 更快的Python（一）</title>
      <link>http://localhost:1313/posts/faster-python-part-1/</link>
      <pubDate>Mon, 08 Oct 2018 18:15:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/faster-python-part-1/</guid>
      <description>&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/20181008_11.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;更快的 Python（&lt;a href=&#34;http://pythonfasterway.org&#34;&gt;Python Faster Way&lt;/a&gt;）使用代码示例来说明如何书写 Python 代码能带来更高的性能。本文对代码进行了讲解，从性能和可读性等角度来选择出最适合的写法。&lt;/p&gt;
&lt;h3 id=&#34;例子-1字符串格式化&#34;&gt;例子 1：字符串格式化&lt;/h3&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/20181008_01.png&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最差/最优时间比：&lt;strong&gt;1.95&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;使用建议：Python 3.7 或以上推荐使用 f-string，其他版本推荐使用 format 方法。&lt;/li&gt;
&lt;li&gt;说明：字符串格式化是代码中最常遇到的情况，虽然在连接少量字符串的情景中，使用+号的性能最优，但是使用+号的代码可读性最差。如果使用 Python 3.7 或优以上版本，可以使用 f-string 来解决这个问题，f-string 的性能比 format 方法和%操作符的性能都要高，可读性也比+号好。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;例子-2字典的初始化&#34;&gt;例子 2：字典的初始化&lt;/h3&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/20181008_02.png&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最差/最优时间比：&lt;strong&gt;1.83&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;使用建议：使用字面量初始化字典（以及其他集合类型）。&lt;/li&gt;
&lt;li&gt;说明：Python 中初始化集合类型时使用字面量的方式，解释器会直接调用 BUILD_MAP 等字节码来创建，如果用构造函数的方式来创建，则需要先查询构造方法，再执行构造方法。使用字面量初始化，Python 代码也更简洁。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;例子-3内置排序方法&#34;&gt;例子 3：内置排序方法&lt;/h3&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/20181008_03.png&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最差/最优时间比：&lt;strong&gt;1.26&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;使用建议：根据是否需要修改原始值来决定使用哪个方法。&lt;/li&gt;
&lt;li&gt;说明：sorted 和 list.sort 方法是 Python 中内置的排序方法，sorted 方法不会修改原始值，list.sort 方法在原始值上直接排序，会修改原始值。比较这两个方法的性能差异，意义不大。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;例子-4初始化多个变量&#34;&gt;例子 4：初始化多个变量&lt;/h3&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/20181008_04.png&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最差/最优时间比：&lt;strong&gt;1.01&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;使用建议：推荐使用第二种。&lt;/li&gt;
&lt;li&gt;说明：从字节码中可以看出两种方式出了执行顺序之外，基本一致，所以性能上也非常接近。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;例子-5多个变量的比较&#34;&gt;例子 5：多个变量的比较&lt;/h3&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/20181008_05.png&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最差/最优时间比：&lt;strong&gt;1.11&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;使用建议：推荐使用第二种。&lt;/li&gt;
&lt;li&gt;说明：使用第一种方法能带来一定的性能提升，但是提升有限，在实际情况中也很少出现多个变量连续比较大小的情况，并且第一种方法非常不 Pythonic，所以推荐使用第二种。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;例子-6if-true-的条件判断&#34;&gt;例子 6：if true 的条件判断&lt;/h3&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/20181008_06.png&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最差/最优时间比：&lt;strong&gt;1.17&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;使用建议：推荐使用第一种。&lt;/li&gt;
&lt;li&gt;说明：从字节码上看，第一种方法的性能最高，并且语法上也更加简洁。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;例子-7if-false-的条件判断&#34;&gt;例子 7：if false 的条件判断&lt;/h3&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/20181008_07.png&#34;&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>用Python写算法 | 蓄水池算法实现随机抽样</title>
      <link>http://localhost:1313/posts/implementation-of-reservoir-sample-in-python/</link>
      <pubDate>Sun, 05 Aug 2018 00:02:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/implementation-of-reservoir-sample-in-python/</guid>
      <description>&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/20180805_01.jpg&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;现在有一组数，不知道这组数的总量有多少，请描述一种算法能够在这组数据中随机抽取 k 个数，使得每个数被取出来的概率相等。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;如果这组数有 n 个，那么每个数字取到的概率就是 k/n，但是这个问题的难点在于不知道这组数的总数，也就是不知道 n，那么该怎么计算每个数取到的概率呢？&lt;/p&gt;
&lt;h1 id=&#34;蓄水池算法&#34;&gt;蓄水池算法&lt;/h1&gt;
&lt;p&gt;游泳池（蓄水池）大家都不陌生，有些游泳池中的水是活的，有入水管也有出水管，那么和泳池体积相当的水流过之后，是不是泳池中所有的水都会被替换呢？当然不是，有的水在泳池中可能会存留很久，有的可能刚进去就流走了。仿照这种现象，蓄水池抽样算法诞生了，蓄水池算法的关键在于保证流入蓄水池的水和已经在池中的水以相同的概率留存在蓄水池中。并且蓄水池算法可以在不预先知道总量的情况下，在时间复杂度 O(N)的情况下，来解决这类采样问题。&lt;/p&gt;
&lt;h1 id=&#34;核心原理&#34;&gt;核心原理&lt;/h1&gt;
&lt;p&gt;这一部分涉及公式，为了保证效果直接贴了图过来。&lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/20180805_02.jpg&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;python-实现&#34;&gt;Python 实现&lt;/h1&gt;
&lt;p&gt;接下来尝试用 Python 实现一下蓄水池算法，由于蓄水池算法是在事先不知道总量的情况下抽样的，所以定义一个方法来接收单个元素，并且把这个方法放在类中，以持有采样后的数据。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; random
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ReservoirSample&lt;/span&gt;(object):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;__init__&lt;/span&gt;(self, size):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;_size &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; size
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;_counter &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;_sample &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; []
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;feed&lt;/span&gt;(self, item):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;_counter &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;# 第i个元素（i &amp;lt;= k），直接进入池中&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; len(self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;_sample) &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;_size:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;_sample&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;append(item)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;_sample
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;# 第i个元素（i &amp;gt; k），以k / i的概率进入池中&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        rand_int &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; random&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;randint(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;_counter)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; rand_int &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;_size:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;_sample[rand_int &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; item
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;_sample
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h1 id=&#34;测试代码&#34;&gt;测试代码&lt;/h1&gt;
&lt;p&gt;接下来实现一个测试用例验证实现的算法是否正确，既然是随机抽样，无法通过单词测试来验证是否正确，所以通过多次执行的方式来验证，比如从 1-10 里随机取样 3 个数，然后执行 10000 次取样，如果算法正确，最后结果中 1-10 被取样的次数应该是相同的，都是 3000 上下。&lt;/p&gt;</description>
    </item>
    <item>
      <title>你所不知道的Python | 函数参数的演进之路</title>
      <link>http://localhost:1313/posts/transition-of-parameters-of-functions-in-python/</link>
      <pubDate>Tue, 10 Jul 2018 10:08:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/transition-of-parameters-of-functions-in-python/</guid>
      <description>&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/20180710_01.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;函数参数处理机制是 Python 中一个非常重要的知识点，随着 Python 的演进，参数处理机制的灵活性和丰富性也在不断增加，使得我们不仅可以写出简化的代码，也能处理复杂的调用。&lt;/p&gt;
&lt;h1 id=&#34;关键字参数&#34;&gt;关键字参数&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;调用时指定参数的名称，且与函数声明时的参数名称一致。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;关键字参数是 Python 函数中最基础也最常见的，我们写一个记账的函数，参数是需要记录的时间和金额。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;add_record&lt;/span&gt;(date, amount):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	print(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;date:&amp;#39;&lt;/span&gt;, date, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;amount:&amp;#39;&lt;/span&gt;, amount)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里的 amount 参数就是一个关键字参数，关键字参数支持两种调用方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;位置调用&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;关键字调用&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;位置调用，就是按参数的位置进行调用，例如传入两个参数，第一个是字符串 2018-07-06，第二个是整数 10，那么这两个参数会被分别赋予 date 和 amount 变量，如果顺序反过来，则这两个参数分别赋予 amount 和 date 变量。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;add_record(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;2018-07-06&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;)  &lt;span style=&#34;color:#75715e&#34;&gt;# 输出date: 2018-07-06 amount: 10&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;add_record(&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;2018-07-06&amp;#39;&lt;/span&gt;)  &lt;span style=&#34;color:#75715e&#34;&gt;# 输出date: 10 amount: 2018-07-06&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;关键字调用，可以忽略参数顺序，直接指定参数。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;add_record(amount&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;, date&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;2018-07-06&amp;#39;&lt;/span&gt;)  &lt;span style=&#34;color:#75715e&#34;&gt;# 虽然参数顺序反了，但是使用了关键字调用，所以依然输出date: 2018-07-06 amount: 10&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h1 id=&#34;仅限关键字参数&#34;&gt;仅限关键字参数&lt;/h1&gt;
&lt;p&gt;我们定义一个 Person 类，并实现它的&lt;code&gt;__init__&lt;/code&gt;方法&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Person&lt;/span&gt;(object):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;__init__&lt;/span&gt;(self, name, age,  gender, height, weight):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;_name &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; name
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;_age &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; age
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;_gender &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; gender
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;_height &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; height
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;_weight &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; weight
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;当初始化这个类的时候，我们可以使用关键字调用，也可以使用位置调用。&lt;/p&gt;</description>
    </item>
    <item>
      <title>你所不知道的Python | 字符串连接的秘密</title>
      <link>http://localhost:1313/posts/the-secret-of-string-concatenation/</link>
      <pubDate>Thu, 28 Jun 2018 23:51:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/the-secret-of-string-concatenation/</guid>
      <description>&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/20180628_04.jpg&#34;&gt;&lt;/p&gt;
&lt;p&gt;字符串连接，就是将 2 个或以上的字符串合并成一个，看上去连接字符串是一个非常基础的小问题，但是在 Python 中，我们可以用多种方式实现字符串的连接，稍有不慎就有可能因为选择不当而给程序带来性能损失。&lt;/p&gt;
&lt;h1 id=&#34;方法-1加号连接&#34;&gt;方法 1：加号连接&lt;/h1&gt;
&lt;p&gt;很多语言都支持使用加号连接字符串，Python 也不例外，只需要简单的将 2 个或多个字符串相加就可以完成拼接。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;a &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Python&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;b &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;私房菜&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;r &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; a &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; b  &lt;span style=&#34;color:#75715e&#34;&gt;# 输出&amp;#39;Python私房菜&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h1 id=&#34;方法-2使用操作符&#34;&gt;方法 2：使用%操作符&lt;/h1&gt;
&lt;p&gt;在 Python 2.6 以前，%操作符是唯一一种格式化字符串的方法，它也可以用于连接字符串。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;a &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Python&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;b &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;私房菜&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;r &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;%s%s&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt; (a, b)  &lt;span style=&#34;color:#75715e&#34;&gt;# 输出&amp;#39;Python私房菜&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h1 id=&#34;方法-3使用-format-方法&#34;&gt;方法 3：使用 format 方法&lt;/h1&gt;
&lt;p&gt;format 方法是 Python 2.6 中出现的一种代替%操作符的字符串格式化方法，同样可以用来连接字符串。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;a &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Python&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;b &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;私房菜&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;r &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;{}{}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;format(a, b)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h1 id=&#34;方法-4使用-f-string&#34;&gt;方法 4：使用 f-string&lt;/h1&gt;
&lt;p&gt;Python 3.6 中引入了 Formatted String Literals（字面量格式化字符串），简称 f-string，f-string 是%操作符和 format 方法的进化版，使用 f-string 连接字符串的方法和使用%操作符、format 方法类似。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;a &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Python&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;b &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;私房菜&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;r &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;f&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;{&lt;/span&gt;a&lt;span style=&#34;color:#e6db74&#34;&gt;}{&lt;/span&gt;b&lt;span style=&#34;color:#e6db74&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h1 id=&#34;方法-5使用-strjoin方法&#34;&gt;方法 5：使用 str.join()方法&lt;/h1&gt;
&lt;p&gt;字符串有一个内置方法 join，其参数是一个序列类型，例如数组或者元组等。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;a &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Python&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;b &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;私房菜&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;r &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;join([a, b])
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h1 id=&#34;对比测试&#34;&gt;对比测试&lt;/h1&gt;
&lt;p&gt;既然连接字符串有这么多方法，那么使用时到底选择哪种呢？我们从代码可读性和性能两个层面来评估一下上面 5 种方法。&lt;/p&gt;</description>
    </item>
    <item>
      <title>你所不知道的Python | 字符串格式化的演进之路</title>
      <link>http://localhost:1313/posts/things-you-dont-know-about-python/</link>
      <pubDate>Mon, 11 Jun 2018 11:50:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/things-you-dont-know-about-python/</guid>
      <description>&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/20180611_01.jpg&#34;&gt;&lt;/p&gt;
&lt;p&gt;字符串格式化对于每个语言来说都是一个非常基础和常用的功能，学习 Python 的同学大概都知道可以用%语法来格式化字符串。然而为了让我们更方便的使用这个常用功能，语言本身也在对字符串格式化方法进行迭代。&lt;/p&gt;
&lt;h1 id=&#34;python-26-以前操作符&#34;&gt;Python 2.6 以前：%操作符&lt;/h1&gt;
&lt;p&gt;在 Python 2.6 出现之前，字符串迭代只有一种方法，就是%（也是取模）操作符，%操作符支持 unicode 和 str 类型的 Python 字符串，效果和 C 语言中的 sprintf()方法相似，下面是一个使用%格式化字符串的例子：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;print(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;I&amp;#39;m &lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;%s&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;. I&amp;#39;m &lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;%d&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt; year old&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt; (&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Tom&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;27&lt;/span&gt;))
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;%符号前面使用一个字符串作为模板，模板中有标记格式的占位符号，%后面是一个 tuple 或者 dict，用来传递需要格式化的值。占位符控制着显示的格式，下面列表展示了占位符的种类：&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;占位符&lt;/th&gt;
          &lt;th&gt;内容&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;%d&lt;/td&gt;
          &lt;td&gt;十进制整数&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;%i&lt;/td&gt;
          &lt;td&gt;十进制整数&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;%o&lt;/td&gt;
          &lt;td&gt;八进制整数&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;%u&lt;/td&gt;
          &lt;td&gt;无符号整数&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;%x&lt;/td&gt;
          &lt;td&gt;无符号十六进制（小写）&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;%X&lt;/td&gt;
          &lt;td&gt;无符号十六进制（大写）&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;%e&lt;/td&gt;
          &lt;td&gt;浮点型（科学记数法，小写）&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;%E&lt;/td&gt;
          &lt;td&gt;浮点型（科学记数法，大写）&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;%f&lt;/td&gt;
          &lt;td&gt;浮点数&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;%F&lt;/td&gt;
          &lt;td&gt;浮点数&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;%g&lt;/td&gt;
          &lt;td&gt;浮点型，如果小数位数超过 4 位，使用科学记数法表示（小写）&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;%G&lt;/td&gt;
          &lt;td&gt;浮点型，如果小数位数超过 4 位，使用科学记数法表示（大写）&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;%c&lt;/td&gt;
          &lt;td&gt;单个字符&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;%r&lt;/td&gt;
          &lt;td&gt;字符串（调用 repr()方法生成）&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;%s&lt;/td&gt;
          &lt;td&gt;字符串（调用 str()方法生成）&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;除了对数据类型的指定，%操作符还支持更复杂的格式控制：&lt;/p&gt;</description>
    </item>
    <item>
      <title>初学者必备 | Python Cheat Sheet 中文版</title>
      <link>http://localhost:1313/posts/python-cheat-sheet/</link>
      <pubDate>Thu, 31 May 2018 13:22:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/python-cheat-sheet/</guid>
      <description>&lt;p&gt;笔者整理了 Python3 中内置方法的速查表，包含：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内置方法&lt;/li&gt;
&lt;li&gt;列表处理方法&lt;/li&gt;
&lt;li&gt;字典处理方法&lt;/li&gt;
&lt;li&gt;元组处理方法&lt;/li&gt;
&lt;li&gt;集合处理方法&lt;/li&gt;
&lt;li&gt;序列类型的切片方法&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;共计 100 多个方法，点击图片——查看原图——下载。&lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/20180531_01.jpg&#34;&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>简析Python中的四种队列</title>
      <link>http://localhost:1313/posts/four-types-of-queue-in-python/</link>
      <pubDate>Tue, 22 May 2018 10:25:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/four-types-of-queue-in-python/</guid>
      <description>&lt;p&gt;队列是一种只允许在一端进行插入操作，而在另一端进行删除操作的线性表。&lt;/p&gt;
&lt;p&gt;在 Python 文档中搜索队列（queue）会发现，Python 标准库中包含了四种队列，分别是 queue.Queue / asyncio.Queue / multiprocessing.Queue / collections.deque。&lt;/p&gt;
&lt;h1 id=&#34;collectionsdeque&#34;&gt;collections.deque&lt;/h1&gt;
&lt;p&gt;deque 是双端队列（double-ended queue）的缩写，由于两端都能编辑，deque 既可以用来实现栈（stack）也可以用来实现队列（queue）。&lt;/p&gt;
&lt;p&gt;deque 支持丰富的操作方法，主要方法如图：&lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/20180522_01.jpg&#34;&gt;&lt;/p&gt;
&lt;p&gt;相比于 list 实现的队列，deque 实现拥有更低的时间和空间复杂度。list 实现在出队（pop）和插入（insert）时的空间复杂度大约为 O(n)，deque 在出队（pop）和入队（append）时的时间复杂度是 O(1)。&lt;/p&gt;
&lt;p&gt;deque 也支持 in 操作符，可以使用如下写法：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;q &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; collections&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;deque([&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;])
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;print(&lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; q)  &lt;span style=&#34;color:#75715e&#34;&gt;# False&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;print(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; q)  &lt;span style=&#34;color:#75715e&#34;&gt;# True&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;deque 还封装了顺逆时针的旋转的方法：rotate。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 顺时针&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;q &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; collections&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;deque([&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;])
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;q&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;rotate(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;print(q)  &lt;span style=&#34;color:#75715e&#34;&gt;# [4, 1, 2, 3]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;q&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;rotate(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;print(q)  &lt;span style=&#34;color:#75715e&#34;&gt;# [3, 4, 1, 2]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 逆时针&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;q &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; collections&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;deque([&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;])
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;q&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;rotate(&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;print(q)  &lt;span style=&#34;color:#75715e&#34;&gt;# [2, 3, 4, 1]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;q&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;rotate(&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;print(q)  &lt;span style=&#34;color:#75715e&#34;&gt;# [3, 4, 1, 2]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;线程安全方面，通过查看 collections.deque 中的 append()、pop()等方法的源码可以知道，他们都是原子操作，所以是 GIL 保护下的线程安全方法。&lt;/p&gt;</description>
    </item>
    <item>
      <title>你真的会正确使用断言吗？</title>
      <link>http://localhost:1313/posts/right-way-to-use-assert-in-python/</link>
      <pubDate>Mon, 07 May 2018 16:12:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/right-way-to-use-assert-in-python/</guid>
      <description>&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/20180507_01.jpg&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;什么是断言&#34;&gt;什么是断言&lt;/h1&gt;
&lt;p&gt;断言是作为一种调试工具被发明出来的，用来检查那些“代码写对了就肯定成立”的条件。例如我们要断言一个变量 a 必须要大于 2，就可以这样写：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;assert&lt;/span&gt; a &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;当条件不满足时，就会抛出 AssertionError 异常，等同于如下代码：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;not&lt;/span&gt; assert_condition:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;raise&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;AssertionError&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;由于断言是一个 debug 工具，Python 的实现也符合这个设计哲学，在 Python 中 assert 语句的执行是依赖于&lt;code&gt;__debug__&lt;/code&gt;变量的，当&lt;code&gt;__debug__&lt;/code&gt;为 true 时，assert 语句才会被执行。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; __debug__ &lt;span style=&#34;color:#f92672&#34;&gt;and&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;not&lt;/span&gt; assert_condition:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;raise&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;AssertionError&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;默认情况下，当我们执行一个 Python 文件时，&lt;code&gt;__debug__&lt;/code&gt;是会被设置为 True 的，只有加参数-O 或-OO 时，&lt;code&gt;__debug__&lt;/code&gt;才会被设置为 False。&lt;/p&gt;
&lt;p&gt;新建一个 assert.py 文件，写下如下代码：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;print(__debug__)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;assert&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;当使用 python assert.py 运行时，&lt;code&gt;__debug__&lt;/code&gt;会输出 True，assert 2 &amp;gt; 5 语句会抛出 AssertionError 异常。&lt;/p&gt;
&lt;p&gt;当使用 python -O assert.py 运行时，&lt;code&gt;__debug__&lt;/code&gt;会输出 False，assert 2 &amp;gt; 5 语句由于没有执行不会报任何异常。&lt;/p&gt;
&lt;h1 id=&#34;断言-or-异常&#34;&gt;断言 or 异常&lt;/h1&gt;
&lt;p&gt;我们思考这几个问题：断言应该用在哪些情境下？异常和断言的区别是什么？&lt;/p&gt;
&lt;p&gt;用一句话来概括断言的使用场景和与异常的区别：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;检查先验条件使用断言，检查后验条件使用异常&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;我们定义一个 read_file 函数：&lt;/p&gt;</description>
    </item>
    <item>
      <title>用装饰器封装Flask-WTF表单验证逻辑</title>
      <link>http://localhost:1313/posts/using-decorators-to-validate-form/</link>
      <pubDate>Thu, 26 Apr 2018 16:15:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/using-decorators-to-validate-form/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;Don&amp;rsquo;t repeat yourself&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;在使用Flask-WTF的时候，常会用下面这样的代码来验证表单数据的合法性：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;from&lt;/span&gt; flask &lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; Flask
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;app &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Flask(__name__)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;@app.route&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;/&amp;#39;&lt;/span&gt;, methods&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;[&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;GET&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;POST&amp;#39;&lt;/span&gt;])
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;index&lt;/span&gt;():
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	form &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; TestForm()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#75715e&#34;&gt;# 判断是否合法&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;not&lt;/span&gt; form&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;validate_on_submit():
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;err&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;400&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#75715e&#34;&gt;# 主要逻辑&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;对于有很多提交接口的项目来说，需要在每个路由下写相同的的逻辑，造成了大量的代码重复。在Flask-Login中，要把一个路由设置为登录后才能访问，只需要在路由上加一个@login_required装饰器，不需要额外的代码。能不能像Flask-Login一样，用装饰器来封装对表单的验证逻辑呢？&lt;/p&gt;
&lt;h1 id=&#34;实现表单验证装饰器&#34;&gt;实现表单验证装饰器&lt;/h1&gt;
&lt;p&gt;由于不同路由使用的表单类不一样，所以需要为装饰器传入一个表单类参数，并且在路由函数中需要用到表单中的值，所以还需要将验证通过的表单传给路由函数。&lt;/p&gt;
&lt;p&gt;上代码：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;validate_form&lt;/span&gt;(self, form_cls):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;decorator&lt;/span&gt;(fn):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;@wraps&lt;/span&gt;(fn)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;wrapper&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;args, &lt;span style=&#34;color:#f92672&#34;&gt;**&lt;/span&gt;kwargs):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;not&lt;/span&gt; form&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;validate_on_submit():
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;error&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;400&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; fn(form, &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;args, &lt;span style=&#34;color:#f92672&#34;&gt;**&lt;/span&gt;kwargs)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; wrapper
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; decorator
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;使用方式如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;@validate_form&lt;/span&gt;(TestForm)  &lt;span style=&#34;color:#75715e&#34;&gt;# 需要传入要验证的表单类&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;@app.route&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;/&amp;#39;&lt;/span&gt;, methods&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;[&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;GET&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;POST&amp;#39;&lt;/span&gt;])
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;index&lt;/span&gt;(form):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;# 执行到这里说明表单验证通过&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;经过在项目中的应用，发现装饰器还是有一些缺陷：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;无法自定义处理非法表单的逻辑&lt;/li&gt;
&lt;li&gt;不支持get方式提交的表单（查看validate_on_submit()源码可知其只支持对post和put方式提交的表单进行验证）&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;丰富一下&#34;&gt;丰富一下&lt;/h1&gt;
&lt;p&gt;要自定义处理非法表单的逻辑，需要增加一个可以传入自定义逻辑的接口。表单非法时接口的返回往往是一致的，所以我们为所有应用装饰器的路由传入一个统一的处理逻辑。将装饰器封装在一个类中，在类中添加一个配置处理逻辑的方法。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;from&lt;/span&gt; functools &lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; wraps
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;from&lt;/span&gt; flask &lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; request
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;FormValidator&lt;/span&gt;(object):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;__init__&lt;/span&gt;(self, error_handler&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;None&lt;/span&gt;):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;_error_handler &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; error_handler
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;validate_form&lt;/span&gt;(self, form_cls):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;decorator&lt;/span&gt;(fn):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#a6e22e&#34;&gt;@wraps&lt;/span&gt;(fn)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;wrapper&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;args, &lt;span style=&#34;color:#f92672&#34;&gt;**&lt;/span&gt;kwargs):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;not&lt;/span&gt; form&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;validate_on_submit() &lt;span style=&#34;color:#f92672&#34;&gt;and&lt;/span&gt; self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;_error_handler:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;_error_handler(form&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;errors)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; fn(form, &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;args, &lt;span style=&#34;color:#f92672&#34;&gt;**&lt;/span&gt;kwargs)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; wrapper
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; decorator
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;error_handler&lt;/span&gt;(self, fn):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;_error_handler &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; fn
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; fn
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;error_handler也是一个装饰器，被它修饰的方法就是处理非法表单的方法。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Python参数传递，既不是传值也不是传引用</title>
      <link>http://localhost:1313/posts/python-parameter-passing/</link>
      <pubDate>Sun, 22 Apr 2018 14:38:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/python-parameter-passing/</guid>
      <description>&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/20180422_01.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;面试的时候，有没有被问到 Python 传参是传引用还是传值这种问题？有没有听到过 Python 传参既不是传值也不是传引用这种说法？一个小小的参数默认值也可能让代码出现难以查找的 bug？&lt;/p&gt;
&lt;p&gt;如果你也遇到过上面的问题，不妨我们来探究下 Python 函数传递的种种。&lt;/p&gt;
&lt;h1 id=&#34;万物皆对象&#34;&gt;万物皆对象&lt;/h1&gt;
&lt;p&gt;Python 中有一个非常重要的概念——万物皆对象，无论是一个数字、字符串，还是数组、字典，在 Python 中都会以一个对象的形式存在。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;a &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;123&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;对于上面这行代码，在 Python 看来就是创建一个 PyObject 对象，值为 123，然后定义一个指针 a，a 指向这个 PyObject 对象。&lt;/p&gt;
&lt;h1 id=&#34;可变对象和不可变对象&#34;&gt;可变对象和不可变对象&lt;/h1&gt;
&lt;p&gt;Python 中的对象分为两种类型，可变对象和不可变对象，不可变对象指 tuple、str、int 等类型的对象，可变对象指的是 dict、list、自定义对象等类型的对象，我们用一段代码说明他们的区别。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;a &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;print(id(a))  &lt;span style=&#34;color:#75715e&#34;&gt;# 2587116690248&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;a &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; [&lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;print(id(a)) &lt;span style=&#34;color:#75715e&#34;&gt;# 2587116690248&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;b &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;print(id(b)) &lt;span style=&#34;color:#75715e&#34;&gt;# 2006430784&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;b &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;print(id(b)) &lt;span style=&#34;color:#75715e&#34;&gt;# 2006430816&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;上面代码中我们分别定义了一个可变对象和一个不可变对象，并且对他们进行修改，打印修改前后的对象标识可以发现，对可变对象进行修改，变量对其引用不会发生变化，对不可变对象进行修改，变量引用发生了变化。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;可变对象的引用&#34; loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/20180422_02.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;上图是一个可变对象，当修改对象时，例如删除数组中的一个元素，实际上把其中一个元素从对象中移除，对象本身的标识是不发生变化的。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;不可变对象的引用&#34; loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/20180422_03.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;改变一个不可变对象时，例如给一个 int 型加 2，语法上看上去是直接修改了 i 这个对象，但是如前面所说，i 只是一个指向对象 73 的一个变量，Python 会将这个变量指向的对象加 2 后，生成一个新的对象，然后再让 i 指向这个新的对象。&lt;/p&gt;
&lt;h1 id=&#34;参数传递时的表现&#34;&gt;参数传递时的表现&lt;/h1&gt;
&lt;p&gt;了解了对象的原理后，我们就可以来尝试理解一下参数传递时他们的不同表现了。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;a &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;print(id(a))  &lt;span style=&#34;color:#75715e&#34;&gt;# 1437494204232&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;mutable&lt;/span&gt;(a):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	print(id(a))  &lt;span style=&#34;color:#75715e&#34;&gt;# 1437494204232&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	a &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; [&lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	print(id(a))  &lt;span style=&#34;color:#75715e&#34;&gt;# 1437494204232&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;mutable(a)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;b &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;print(id(b))  &lt;span style=&#34;color:#75715e&#34;&gt;# 2006430784&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;immutable&lt;/span&gt;(b):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	print(id(b))  &lt;span style=&#34;color:#75715e&#34;&gt;# 2006430784&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	b &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	print(id(b))  &lt;span style=&#34;color:#75715e&#34;&gt;# 2006430816&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;immutable(b)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;通过上面的代码可以看出，修改传进的可变参数时，会对外部对象产生影响，修改不可变参数时则不会影响。&lt;/p&gt;</description>
    </item>
    <item>
      <title>实战 | 用aiohttp和uvloop实现一个高性能爬虫</title>
      <link>http://localhost:1313/posts/a-crawler-based-on-aiohttp-and-uvloop/</link>
      <pubDate>Tue, 10 Apr 2018 19:26:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/a-crawler-based-on-aiohttp-and-uvloop/</guid>
      <description>&lt;p&gt;asyncio 于 Python3.4 引入标准库，增加了对异步 I/O 的支持，asyncio 基于事件循环，可以轻松实现异步 I/O 操作。接下来，我们用基于 asyncio 的库实现一个高性能爬虫。&lt;/p&gt;
&lt;h1 id=&#34;准备工作&#34;&gt;准备工作&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://chrome.google.com/webstore/detail/earth-view-from-google-ea/bhloflhklmhfpedakmangadcdofhnnoh&#34;&gt;Earth View from Google Earth&lt;/a&gt;是一款 Chrome 插件，会在打开新标签页时自动加载一张来自 Google Earth 的背景图片。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;Earth View from Google Earth&#34; loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/20180410_01.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;使用 Chrome 开发者工具观察插件的网络请求，我们发现插件会请求一个地址如&lt;a href=&#34;https://www.gstatic.com/prettyearth/assets/data/v2/1234.json&#34;&gt;https://www.gstatic.com/prettyearth/assets/data/v2/1234.json&lt;/a&gt;的 JSON 文件，文件中包含了经过 Base64 的图片内容，观察发现，图片的 ID 范围大致在 1000-8000 之间，我们的爬虫就要来爬取这些精美的背景图片。&lt;/p&gt;
&lt;h1 id=&#34;实现主要逻辑&#34;&gt;实现主要逻辑&lt;/h1&gt;
&lt;p&gt;由于爬取目标是 JSON 文件，爬虫的主要逻辑就变成了&lt;strong&gt;爬取 JSON&amp;ndash;&amp;gt;提取图片&amp;ndash;&amp;gt;保存图片&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;requests 是一个常用的 http 请求库，但是由于 requests 的请求都是同步的，我们使用&lt;a href=&#34;https://aiohttp.readthedocs.io/en/stable/&#34;&gt;aiohttp&lt;/a&gt;这个异步 http 请求库来代替。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;async&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;fetch_image_by_id&lt;/span&gt;(item_id):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	url &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;f&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;https://www.gstatic.com/prettyearth/assets/data/v2/&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;{&lt;/span&gt;item_id&lt;span style=&#34;color:#e6db74&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;.json&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;# 由于URL是https的，所以选择不验证SSL&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;async&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;with&lt;/span&gt; aiohttp&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;ClientSession(connector&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;aiohttp&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;TCPConnector(verify_ssl&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;False&lt;/span&gt;)) &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; session:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#66d9ef&#34;&gt;async&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;with&lt;/span&gt; session&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;get(url) &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; response:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#75715e&#34;&gt;# 获取后需要将JSON字符串转为对象&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;			&lt;span style=&#34;color:#66d9ef&#34;&gt;try&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;				json_obj &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; json&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;loads(&lt;span style=&#34;color:#66d9ef&#34;&gt;await&lt;/span&gt; response&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;text())
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;			&lt;span style=&#34;color:#66d9ef&#34;&gt;except&lt;/span&gt; json&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;decoder&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;JSONDecodeError &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; e:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;				print(&lt;span style=&#34;color:#e6db74&#34;&gt;f&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Download failed - &lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;{&lt;/span&gt;item_id&lt;span style=&#34;color:#e6db74&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;.jpg&amp;#39;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;				&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#75715e&#34;&gt;# 获取JSON中的图片内容字段，经过Base64解码成二进制内容&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;			image_str &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; json_obj[&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;dataUri&amp;#39;&lt;/span&gt;]&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;replace(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;data:image/jpeg;base64,&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&amp;#39;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;			image_data &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; base64&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;b64decode(image_str)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;			save_folder &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; dir_path &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; os&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;path&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;dirname(
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;				os&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;path&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;realpath(__file__)) &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;/google_earth/&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;			&lt;span style=&#34;color:#66d9ef&#34;&gt;with&lt;/span&gt; open(&lt;span style=&#34;color:#e6db74&#34;&gt;f&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;{&lt;/span&gt;save_folder&lt;span style=&#34;color:#e6db74&#34;&gt;}{&lt;/span&gt;item_id&lt;span style=&#34;color:#e6db74&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;.jpg&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;wb&amp;#39;&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; f:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;				f&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;write(image_data)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;			print(&lt;span style=&#34;color:#e6db74&#34;&gt;f&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Download complete - &lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;{&lt;/span&gt;item_id&lt;span style=&#34;color:#e6db74&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;.jpg&amp;#39;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;aiohttp 基于 asyncio，所以在调用时需要使用 async/await 语法糖，可以看到，由于 aiohttp 中提供了一个 ClientSession 上下文，代码中使用了 async with 的语法糖。&lt;/p&gt;</description>
    </item>
    <item>
      <title>与面试官谈笑风生 | Python面向对象之访问控制</title>
      <link>http://localhost:1313/posts/python-access-control/</link>
      <pubDate>Fri, 30 Mar 2018 17:54:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/python-access-control/</guid>
      <description>&lt;p&gt;Python 从设计之初就是一门面向对象的语言，面向对象思想的第一个要素就是封装。所谓封装，通俗的讲就是类中的属性和方法，分为公有和私有，公有可以被外界访问，私有不能被外界访问，这就是封装中最关键的概念——访问控制。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;面向对象编程&#34; loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/20180330_01.jpg&#34;&gt;&lt;/p&gt;
&lt;p&gt;访问控制有三种级别：私有、受保护、公有&lt;/p&gt;
&lt;p&gt;私有（Private）：只有类自身可以访问
受保护（Protected）：只有类自身和子类可以访问
公有（Public）：任何类都可以访问&lt;/p&gt;
&lt;p&gt;由于 Python 不像 Java，有访问控制符（private / public / protected），所以 Python 的访问控制也是容易被应聘者忽视和搞错的。&lt;/p&gt;
&lt;h1 id=&#34;公有public&#34;&gt;公有（Public）&lt;/h1&gt;
&lt;p&gt;在 Python 的类中，默认情况下定义的属性都是公有的。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Foo&lt;/span&gt;(object):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	bar &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;123&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;__init__&lt;/span&gt;(self, bob):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;bob &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; bob
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;print(Foo&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;bar)  &lt;span style=&#34;color:#75715e&#34;&gt;# 123&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;foo &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Foo(&lt;span style=&#34;color:#ae81ff&#34;&gt;456&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;print(foo&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;bob)  &lt;span style=&#34;color:#75715e&#34;&gt;# 456&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;上面类&lt;code&gt;Foo&lt;/code&gt;中的&lt;code&gt;bar&lt;/code&gt;属性就是类属性，&lt;code&gt;__init__&lt;/code&gt;方法中定义的 bob 是实例属性，&lt;code&gt;bar&lt;/code&gt;和&lt;code&gt;bob&lt;/code&gt;都是公有的属性，外部可以访问，分别 print 类中的&lt;code&gt;bar&lt;/code&gt;和实例中的&lt;code&gt;bob&lt;/code&gt;，输出了对应的值。&lt;/p&gt;
&lt;h1 id=&#34;受保护protected&#34;&gt;受保护（Protected）&lt;/h1&gt;
&lt;p&gt;在 Python 中定义一个受保护的属性，只需要在其名字前加一个下划线&lt;code&gt;_&lt;/code&gt;，我们将 Foo 方法中的&lt;code&gt;bob&lt;/code&gt;和&lt;code&gt;bar&lt;/code&gt;改为&lt;code&gt;_bob&lt;/code&gt;和&lt;code&gt;_bar&lt;/code&gt;，他们就变成了受保护的属性了，代码如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Foo&lt;/span&gt;(object):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	_bar &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;123&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;__init__&lt;/span&gt;(self, bob):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;_bob &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; bob
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Son&lt;/span&gt;(Foo):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;print_bob&lt;/span&gt;(self):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		print(self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;_bob)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;@classmethod&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;print_bar&lt;/span&gt;(cls):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		print(cls&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;_bar)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Son&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;print_bar()  &lt;span style=&#34;color:#75715e&#34;&gt;# 123&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;son &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Son(&lt;span style=&#34;color:#ae81ff&#34;&gt;456&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;son&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;print_bob()  &lt;span style=&#34;color:#75715e&#34;&gt;# 456&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;定义一个类&lt;code&gt;Son&lt;/code&gt;继承自&lt;code&gt;Foo&lt;/code&gt;，由于受保护的对象只能在类的内部和子类中被访问，不能直接调用&lt;code&gt;print(Son._bar)&lt;/code&gt;或&lt;code&gt;print(son._bob)&lt;/code&gt;来输出这两个属性的值，所以定义了&lt;code&gt;print_bar&lt;/code&gt;和&lt;code&gt;print_bob&lt;/code&gt;方法，实现在子类中输出，这段代码也正常的输出了&lt;code&gt;_bar&lt;/code&gt;和&lt;code&gt;_bob&lt;/code&gt;的值。&lt;/p&gt;</description>
    </item>
    <item>
      <title>用Python批量提取Win10锁屏壁纸</title>
      <link>http://localhost:1313/posts/extract-lockscreen-wallpapers-in-win10/</link>
      <pubDate>Mon, 26 Mar 2018 22:21:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/extract-lockscreen-wallpapers-in-win10/</guid>
      <description>&lt;p&gt;使用 Win10 的朋友会发现，每次开机锁屏界面都会有不一样的漂亮图片，这些图片通常选自优秀的摄影作品，十分精美。&lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/20180326_01.jpg&#34;&gt;&lt;/p&gt;
&lt;p&gt;但是由于系统会自动更换这些图片，所以就算再好看的图片，也许下次开机之后就被替换掉了。&lt;/p&gt;
&lt;p&gt;借助 Python，我们可以用简单的几行代码，批量提取这些精美的锁屏图片。把喜欢的图片设置成桌面背景，就不用担心被替换掉啦。&lt;/p&gt;
&lt;h1 id=&#34;提取原理&#34;&gt;提取原理&lt;/h1&gt;
&lt;p&gt;Win10 系统会自动下载最新的锁屏壁纸，并将他们保存在一个系统文件夹中，路径是&lt;code&gt;C:\Users\[用户名]\AppData\Local\Packages\Microsoft.Windows.ContentDeliveryManager_cw5n1h2txyewy\LocalState\Assets&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;随机命名的锁屏图片&#34; loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/20180326_02.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;直接打开这个文件夹，里面会有随机命名的多个文件，每一个文件就是一张图片。但是由于文件没有扩展名，所以并不能预览。为了不搞坏系统文件，并且把这些文件变成可以预览的格式，我们用 Python 把这些文件复制出来，加上 JPG 作为扩展名。&lt;/p&gt;
&lt;h1 id=&#34;实现代码&#34;&gt;实现代码&lt;/h1&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; os&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt; shutil
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;from&lt;/span&gt; datetime &lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; datetime
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 把这个文件所在目录wallpapers文件夹作为保存图片的目录&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;save_folder &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; dir_path &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; os&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;path&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;dirname(
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	os&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;path&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;realpath(__file__)) &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;\wallpapers&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 动态获取系统存放锁屏图片的位置&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;wallpaper_folder &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; os&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;getenv(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;LOCALAPPDATA&amp;#39;&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; (
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;\Packages\Microsoft.Windows.ContentDeliveryManager_cw5n1h2txyewy&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;\LocalState\Assets&amp;#39;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 列出所有的文件&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;wallpapers &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; os&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;listdir(wallpaper_folder)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; wallpaper &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; wallpapers:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	wallpaper_path &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; os&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;path&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;join(wallpaper_folder, wallpaper)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#75715e&#34;&gt;# 小于150kb的不是锁屏图片&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (os&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;path&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;getsize(wallpaper_path) &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1024&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;150&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#66d9ef&#34;&gt;continue&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	wallpaper_name &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; wallpaper &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;.jpg&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	save_path &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; os&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;path&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;join(save_folder, wallpaper_name)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	shutil&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;copyfile(wallpaper_path, save_path)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	print(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Save wallpaper &amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; save_path)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;首先确定系统存放锁屏图片的文件夹位置，由于文件夹位于用户的个人文件夹内，每个用户的用户名是不一样的，所以我们需要通过系统的&lt;code&gt;LOCALAPPDATA&lt;/code&gt;变量动态的获取路径。代码会把提取出来的图片保存在 wallpapers 文件夹下，所以代码文件所在的目录没有 wallpapers 文件夹，需要手工创建一个。&lt;/p&gt;</description>
    </item>
    <item>
      <title>15行Python代码，帮你理解令牌桶算法</title>
      <link>http://localhost:1313/posts/implementation-of-the-token-bucket-algorithm-in-python/</link>
      <pubDate>Tue, 20 Mar 2018 12:50:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/implementation-of-the-token-bucket-algorithm-in-python/</guid>
      <description>&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/20180320_01.jpg&#34;&gt;&lt;/p&gt;
&lt;p&gt;在网络中传输数据时，为了防止网络拥塞，需限制流出网络的流量，使流量以比较均匀的速度向外发送，令牌桶算法就实现了这个功能，&lt;strong&gt;可控制发送到网络上数据的数目，并允许突发数据的发送。&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&#34;什么是令牌&#34;&gt;什么是令牌&lt;/h1&gt;
&lt;p&gt;从名字上看令牌桶，大概就是一个装有令牌的桶吧，那么什么是令牌呢？&lt;/p&gt;
&lt;p&gt;紫薇格格拿的令箭，可以发号施令，令行禁止。在计算机的世界中，令牌也有令行禁止的意思，有令牌，则相当于得到了进行操作的授权，没有令牌，就什么都不能做。&lt;/p&gt;
&lt;h1 id=&#34;用令牌实现限速器&#34;&gt;用令牌实现限速器&lt;/h1&gt;
&lt;p&gt;我们用 1 块令牌来代表发送 1 字节数据的资格，假设我们源源不断的发放令牌给程序，程序就有资格源源不断的发送数据，当我们不发放令牌给程序，程序就相当于被限流，无法发送数据了。接下来我们说说限速器，所谓限速器，就是让程序在单位时间内，最多只能发送一定大小的数据。假设在 1 秒发放 10 块令牌，那么程序发送数据的速度就会被限制在 10bytes/s。如果 1 秒内有大于 10bytes 的数据需要发送，就会因为没有令牌而被丢弃。&lt;/p&gt;
&lt;h1 id=&#34;改进限速器加个桶&#34;&gt;改进限速器——加个桶&lt;/h1&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/20180320_02.jpg&#34;&gt;&lt;/p&gt;
&lt;p&gt;我们实现的限速器，速度是恒定的，但是在实际的应用中，往往会有突发的传输需求（需要更快速的发送，但是不会持续太久，也不会引起网络拥塞），这种数据碰上我们的限速器，就因为拿不到令牌而无法发送。&lt;/p&gt;
&lt;p&gt;对限速器进行一下改动，依然 1 秒产生 10 块令牌，但是我们把产生出来的令牌先放到一个桶里，当程序需要发送的时候，从桶里取令牌，不需要的时候，令牌就会在桶里沉淀下来，假设桶里沉淀了 10 块令牌，程序最多就可以在 1 秒内发送 20bytes 的数据，满足了突发数据传输的要求，并且由于桶里的令牌被用完，下一秒最多依然只能发 10bytes 的数据，不会因为持续发送大量数据，对网络造成压力。&lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/20180320_03.jpg&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;15-行-python-代码实践令牌桶&#34;&gt;15 行 Python 代码实践令牌桶&lt;/h1&gt;
&lt;p&gt;令牌桶需要以一定的速度生成令牌放入桶中，当程序要发送数据时，再从桶中取出令牌。这里似乎有点问题，如果我们使用一个死循环，来不停地发放令牌，程序就被阻塞住了，有没有更好的办法？&lt;/p&gt;
&lt;p&gt;我们可以在取令牌的时候，用现在的时间减去上次取令牌的时间，乘以令牌的发放速度，计算出桶里可以取的令牌数量（当然不能超过桶的大小），从而避免循环发放的逻辑。&lt;/p&gt;
&lt;p&gt;接下来看代码：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; time
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;TokenBucket&lt;/span&gt;(object):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;# rate是令牌发放速度，capacity是桶的大小&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;__init__&lt;/span&gt;(self, rate, capacity):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;_rate &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; rate
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;_capacity &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; capacity
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;_current_amount &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;_last_consume_time &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; int(time&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;time())
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;# token_amount是发送数据需要的令牌数&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;consume&lt;/span&gt;(self, token_amount):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        increment &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (int(time&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;time()) &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;_last_consume_time) &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;_rate  &lt;span style=&#34;color:#75715e&#34;&gt;# 计算从上次发送到这次发送，新发放的令牌数量&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;_current_amount &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; min(
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            increment &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;_current_amount, self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;_capacity)  &lt;span style=&#34;color:#75715e&#34;&gt;# 令牌数量不能超过桶的容量&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; token_amount &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;_current_amount:  &lt;span style=&#34;color:#75715e&#34;&gt;# 如果没有足够的令牌，则不能发送数据&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;False&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;_last_consume_time &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; int(time&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;time())
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;_current_amount &lt;span style=&#34;color:#f92672&#34;&gt;-=&lt;/span&gt; token_amount
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;True&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    <item>
      <title>最爱你的人，会让你不费脑细胞的理解区块链原理</title>
      <link>http://localhost:1313/posts/understanding-blockchain/</link>
      <pubDate>Wed, 14 Mar 2018 21:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/understanding-blockchain/</guid>
      <description>&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/20180314_01.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;区块链是一个近期非常火的概念，随便走进一个写字楼的电梯，都会听到有人谈论区块链，或者炒币: ) 希望通过这篇文章，能让你对区块链的概念有一个整体的认识，在理解概念后，&lt;strong&gt;下一篇文章将用大约 300 行 Python 代码，实现一个区块链网络。&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&#34;区块-和-链&#34;&gt;区块 和 链&lt;/h1&gt;
&lt;p&gt;所谓区块，就是一个块咯（要不然还是什么？），把这些块一个一个连在一起，像链条一样，就称为区块链（别急着打我，先往下看）。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;区块和区块链&#34; loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/20180314_02.jpg&#34;&gt;&lt;/p&gt;
&lt;p&gt;这是一些链条，链条的价值更多的体现在锁楼下小电动车的时候，不过我们再仔细看一下这个链条是不是有点像那什么？⛓&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;脱氧核糖核酸&#34; loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/20180314_03.gif&#34;&gt;&lt;/p&gt;
&lt;p&gt;很聪明，高中生物老师在冲你微笑！这就是传说中的脱氧核糖核酸（DNA），DNA 也是一种链式结构，&lt;strong&gt;携带了遗传信息&lt;/strong&gt;。区块链中的“区块”，就好比 DNA 分子中的脱氧核糖核苷酸（我也不知道自己在说什么），而区块链中的“链”，就好比 DNA 分子的链式结构。&lt;/p&gt;
&lt;p&gt;DNA 和链条的价值差异，关键在于 DNA 携带了大量遗传&lt;strong&gt;信息&lt;/strong&gt;，而链条什么都没有携带。对于区块链来说，携带信息也是它的一个重要特点（不携带信息连锁电动车的作用都没有）。&lt;/p&gt;
&lt;p&gt;当区块链携带的是账务信息的时候，它就变成了一个特别厉害的东西——账本（我们给他起了个 00 后的名字——比特币）。&lt;/p&gt;
&lt;h1 id=&#34;peer-to-peer&#34;&gt;Peer-to-Peer&lt;/h1&gt;
&lt;p&gt;为了显得专业一些，我们祭出比特币的创造者，中本聪的论文&lt;a href=&#34;https://bitcoin.org/bitcoin.pdf&#34;&gt;《Bitcoin: A Peer-to-Peer Electronic Cash System》&lt;/a&gt;，从这篇论文的题目我们可以看到，区块链是基于&lt;strong&gt;Peer-to-Peer&lt;/strong&gt;的，下面就来了解一下什么是 Peer-to-Peer。&lt;/p&gt;
&lt;p&gt;Peer-to-Peer，简称 P2P（不是互联网借贷的那个 P2P），它是一种点对点网络，看图（我也不知道该怎么讲）。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;P2P网络&#34; loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/20180314_04.jpg&#34;&gt;&lt;/p&gt;
&lt;p&gt;图中每一个方脑袋就是一个 Peer（节点），注意一下，这些方脑袋有一个共同点，他们都一毛一样（不仅长得一样，每一个脑袋都跟其它脑袋相连）。这也是 P2P 网络的最大特点——&lt;strong&gt;去中心化&lt;/strong&gt;，P2P 网络中不存在中心节点，所有节点都是平等的，任何一个节点，想跟谁说话就跟谁说话，并且谁（节点）都不能说了算。&lt;/p&gt;
&lt;h1 id=&#34;共识机制&#34;&gt;共识机制&lt;/h1&gt;
&lt;p&gt;你和好基友老王，还有你们共同喜欢的一个姑娘阿圆（对，就是圆滚滚的圆），组成了一个三节点的 P2P 网络，根据 P2P 网络定义你们三个人谁都不能说了算。这一天，阿圆生日，你和老王同时给阿圆送了一个大蛋糕，那么问题来了，阿圆先吃哪个呢？&lt;/p&gt;
&lt;p&gt;既然没有人能说了算，也不能让你和老王决斗（计算机这么做恐怕人类会毁灭），那么就需要采用一个文明的办法决定——商量。既然商量，就要有规矩，这个规矩叫&lt;strong&gt;共识机制&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/20180314_05.png&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;proof-of-work&#34;&gt;Proof-of-work&lt;/h1&gt;
&lt;p&gt;区块链共识机制有很多种，Proof-of-work（POW，工作量证明）是其中一种，所谓工作量证明，有点像是比武招亲。你和老王对阿圆都很好，阿圆也很难抉择到底先吃谁的蛋糕，于是她请了两位武力相当的武林高手，让你和老王分别与高手过招，谁赢了高手，就先吃谁的蛋糕，如果你们都赢了高手，那么谁先赢算数。&lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/20180314_06.jpg&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;把这些捏在一起&#34;&gt;把这些捏在一起&lt;/h1&gt;
&lt;p&gt;了解了 POW、共识机制、P2P、区块、链的概念，我们就可以把他们拼在一起，看看会发生什么了。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;区块链诞生了！&#34; loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/20180314_07.jpeg&#34;&gt;&lt;/p&gt;
&lt;p&gt;我们把 P2P 网络中的每一个节点，赋予一条链，这样网络中所有的链都是平等的了，接下来在其中一条链上增加一个带有信息的区块，P2P 网络会将这个区块同步到所有的链上，也就是这条信息会被存储在所有节点。&lt;/p&gt;
&lt;p&gt;把上面的一段话缩成一句（会显得比较厉害）：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;区块链是用分布式数据库识别、传播和记载信息的智能化对等网络, 也称为价值互联网。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;看到这里是不是对区块链略知一二了？&lt;/p&gt;</description>
    </item>
    <item>
      <title>面试不再怕，20行Python代码帮你搞懂LRU算法</title>
      <link>http://localhost:1313/posts/lru-algorithm-implemented-in-python/</link>
      <pubDate>Tue, 06 Mar 2018 20:00:00 +0000</pubDate>
      <guid>http://localhost:1313/posts/lru-algorithm-implemented-in-python/</guid>
      <description>&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/20180306_01.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;LRU 算法在后端工程师面试中，是一个比较常出现的题目，这篇文章带大家一起，理解 LRU 算法，并最终用 Python 轻松实现一个基于 LRU 算法的缓存。&lt;/p&gt;
&lt;h2 id=&#34;缓存是什么&#34;&gt;缓存是什么&lt;/h2&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/20180306_02.jpg&#34;&gt;&lt;/p&gt;
&lt;p&gt;先看一张图，当我们访问网页，浏览器会给服务器发请求，服务器会经过一系列的运算，把页面返回给浏览器。&lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/20180306_03.jpg&#34;&gt;&lt;/p&gt;
&lt;p&gt;当有多个浏览器同时访问的时候，就会在短时间内发起多个请求，而服务器对每一个请求都要进行一系列相同的操作。重复工作不仅浪费资源，还可能导致响应速度变慢。&lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/20180306_04.jpg&#34;&gt;&lt;/p&gt;
&lt;p&gt;而缓存则可以把服务器返回的页面保存下来，当有其他的浏览器再访问时候，就不必劳服务器大驾，直接由缓存返回页面。为了保证响应速度，缓存通常是基于比较昂贵的硬件，比如 RAM，这就决定了我们很难用大量的缓存把所有的页面都存下来，当恰好没有缓存浏览器请求的页面时，依然需要请求服务器。由于缓存容量有限，而数据量无限（互联网每天新产生的页面数无法估计），就需要把好刚用在刀刃上，缓存那些最有用的信息。&lt;/p&gt;
&lt;h2 id=&#34;lru-是什么&#34;&gt;LRU 是什么&lt;/h2&gt;
&lt;p&gt;LRU 是一种缓存淘汰算法（在 OS 中也叫内存换页算法），由于缓存空间是有限的，所以要淘汰缓存中不常用的数据，留下常用的数据，达到缓存效率的最大化。LRU 就是这样一种决定“淘汰谁留下谁”的算法，LRU 是 Least recently used 的缩写，从字面意思“最近最少使用”，我们就可以理解 LRU 的淘汰规则。&lt;/p&gt;
&lt;h2 id=&#34;lru-的淘汰逻辑&#34;&gt;LRU 的淘汰逻辑&lt;/h2&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;http://localhost:1313/images/20180306_05.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;我们用一张图来描述 LRU 的淘汰逻辑，图中的缓存是一个列表结构，上面是头结点下面是尾节点，缓存容量为 8（8 个小格子）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;有新数据（意味着数据之前没有被缓存过）时，加入到列表头&lt;/li&gt;
&lt;li&gt;缓存到达最大容量时，需要淘汰数据多出来的数据，此时淘汰列表尾部的数据&lt;/li&gt;
&lt;li&gt;当缓存中有数据被命中，则将数据移动到列表头部（相当于新加入缓存）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;按上面的逻辑我们可以看到，一个数据如果经常被访问就会不断地被移动到列表头部，不会被淘汰出缓存，而越不经常访问的数据，越容易被挤出缓存。&lt;/p&gt;
&lt;h2 id=&#34;20-行-python-代码实践-lru&#34;&gt;20 行 Python 代码实践 LRU&lt;/h2&gt;
&lt;p&gt;接下来我们用 Python 来实现一个采用 LRU 算法的缓存。&lt;/p&gt;
&lt;p&gt;从前面的文章中我们可以知道，缓存简化下来就两个功能，一个是往里装数据（缓存数据），一个是往外吐数据（命中缓存），所以我们的缓存对外只需要 put 和 get 两个接口就可以了。&lt;/p&gt;
&lt;p&gt;按照前面的示意图，缓存内部我们只需要有一个列表（list）就可以实现 LRU 逻辑，不过用列表虽然能实现逻辑，但是在判断是否命中缓存时，速度可能非常慢（列表需要遍历才能知道数据有没有在里面）。在 Python 中，我们可以用基于 hash 的结构，比如字典（dict）或集合（set），来快速判断数据是否存在，解决列表实现的性能问题。但是字典和集合又是没有顺序的，如果能有一种既能排序，又是基于 hash 存储的数据结构，就好了。&lt;/p&gt;
&lt;p&gt;在 Python 的 collections 包中，已经内置了这种实用的结构 OrderedDict，OrderedDict 是 dict 的子类，但是存储在内部的元素是有序的（列表的特点）。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
