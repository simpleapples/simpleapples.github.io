<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Zhiya&#39;s Blog</title>
    <link>https://simpleapples.com/zh/</link>
    <description>Recent content on Zhiya&#39;s Blog</description>
    <generator>Hugo -- 0.147.8</generator>
    <language>cn</language>
    <lastBuildDate>Fri, 16 May 2025 21:52:00 +0000</lastBuildDate>
    <atom:link href="https://simpleapples.com/zh/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>唯一索引这玩意儿，真得好好掂量掂量</title>
      <link>https://simpleapples.com/zh/posts/think-twice-on-unique-key/</link>
      <pubDate>Fri, 16 May 2025 21:52:00 +0000</pubDate>
      <guid>https://simpleapples.com/zh/posts/think-twice-on-unique-key/</guid>
      <description>&lt;p&gt;在大厂（就是那种用户多、数据量大、需求快速迭代的地方），如果不是对账那种一分钱不能错的业务，想着靠数据库的 &lt;code&gt;UNIQUE INDEX&lt;/code&gt;（唯一索引）来拦重复数据，说实话，效果不一定好，伺候它的成本还很高。更好的办法是把去重的主要活儿放应用层，数据库那个唯一索引，能不用就先别用，或者想清楚了再用。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;一-为啥我开始琢磨唯一索引这事儿因为坑踩了&#34;&gt;一、 为啥我开始琢磨唯一索引这事儿？因为坑踩了&lt;/h2&gt;
&lt;p&gt;数据库唯一索引，听着挺靠谱，对吧？保证数据不重复的最后一道防线。以前我也是这么想的，表里哪个字段不让重，随手就给它来个唯一索引。&lt;/p&gt;
&lt;p&gt;直到被现实狠狠摩擦了。&lt;/p&gt;
&lt;p&gt;很久之前，当我头发还很茂密的时候，给一个千万级的表加个组合唯一索引（比如 &lt;code&gt;tenant_id&lt;/code&gt; 和 &lt;code&gt;is_deleted&lt;/code&gt; 这俩字段不能重复）。听着简单吧？结果呢，整个变更从头到尾折腾了几天！这期间，主从延迟跟过山车似的，时不时还得担心线上服务会不会抖一下。事儿完了我在想，就为了数据库层面这个“唯一”，搭进去这么多工夫、担这么大风险，值吗？&lt;/p&gt;
&lt;p&gt;还有个事儿也挺别扭。 业务上，我们都知道 &lt;code&gt;user@example.com&lt;/code&gt; 和 &lt;code&gt;USER@EXAMPLE.COM&lt;/code&gt; 其实是一个邮箱，你注册的时候，应用代码肯定也会把它们统一处理成小写再判断有没有重复。结果呢，数据库里的唯一索引（区分大小写）不认这个账。有时候因为一些历史数据或者旁路数据同步没做好规范化，数据库里就存了两种大小写格式的“同一个”邮箱。这时候，唯一索引它要么“眼瞎”发现不了这种业务上的重复，要么在你修数据的时候，因为它那死板的规矩，反而碍手碍脚。&lt;/p&gt;
&lt;p&gt;更别提业务迭代了。 比如，以前光是“邮箱唯一”就行，现在要改成“租户 ID+邮箱唯一”。好家伙，应用代码得改吧？数据库的唯一索引也得跟着 &lt;code&gt;DROP&lt;/code&gt; 旧的 &lt;code&gt;CREATE&lt;/code&gt; 新的吧？这两拨操作怎么配合？谁先谁后？万一中间出岔子怎么办？在大表上搞这种操作，每次都跟拆炸弹似的，提心吊胆。&lt;/p&gt;
&lt;p&gt;就这些事儿搞得我不得不琢磨：数据量大、并发高、需求又变得快，唯一索引这一套，是不是该重新掂量掂量了？它带来的麻烦，是不是已经比它的好处多了？&lt;/p&gt;
&lt;p&gt;这篇文章，就是想跟大家伙儿聊聊我的反思。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;二-unique-index我们为啥那么信它&#34;&gt;二、 &lt;code&gt;UNIQUE INDEX&lt;/code&gt;：我们为啥那么信它？&lt;/h2&gt;
&lt;p&gt;在吐槽之前，咱也得公平点，说说唯一索引为啥那么招人待见，它确实有几个看上去不错的点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;数据不跑偏的最后保险：&lt;/strong&gt; 防止数据重复的最后一道关卡。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;上手简单：&lt;/strong&gt; 建表的时候或者后来加个 DDL，几行 SQL 就搞定了。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;表结构一看就懂：&lt;/strong&gt; Schema 里标着呢，这字段不能重。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;顺便还能快点查：&lt;/strong&gt; 反正也是个索引，按这个键查数据能快点。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这些好处，在小项目或者数据量不大、业务不复杂的时候，确实挺香。但一到大数据量+快速迭代“修罗场”，情况就变了。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;三-大厂滤镜下的unique-index那些好处还好使吗&#34;&gt;三、 大厂滤镜下的&lt;code&gt;UNIQUE INDEX&lt;/code&gt;：那些“好处”还好使吗？&lt;/h2&gt;
&lt;p&gt;接下来咱们挨个盘盘上面说的那些“好处”，看看在大厂这环境下，它们是不是还那么“美”。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;“最后保险”？这保险靠谱吗？保的是啥险？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;业务上的“重复”它认不全啊！就像前面说的邮箱大小写，还有手机号带不带&lt;code&gt;+86&lt;/code&gt;，用户名清不清除特殊字符……这些业务上才认的“一样”，数据库那简单粗暴的“字节必须一样”的唯一索引根本管不过来。它防不住业务层面的“逻辑重复”。&lt;/p&gt;
&lt;p&gt;应用层反正要干活。 既然这些复杂的“一样不一样”都得在应用代码里判断（总不能直接把数据库报错丢给用户吧？），那应用层才是真正保证“业务数据不重复”的主力军。数据库那个唯一索引，充其量是个标准可能还跟业务不一致的“辅警”。&lt;/p&gt;
&lt;p&gt;分布式系统里它就是个“本地保镖”。在分布式场景下一旦分表，表内的唯一索引，管不了全局唯一性。全局唯一还得靠 ID 生成服务或者应用层的全局校验。这时候，数据库本地那点“保险”作用就更小了。&lt;/p&gt;
&lt;p&gt;这个“最后保险”既可能保不到点子上，覆盖面也有限，全指望它优点悬。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;“上手简单”？一次上线，一周折腾&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;新表新加个唯一索引，确实就一条 SQL。但更多的时候是给已经跑了好久、数据堆成山的旧表改规则。你想给千万行的表改个唯一索引（比如从一个字段唯一改成俩字段组合唯一），可能就是几分钟的锁表！在线 DDL 工具，也只是让你不用停服务，但整个过程照样漫长、耗资源、有风险。&lt;/p&gt;
&lt;p&gt;敏捷？快不起来啊！在快速迭代+多区域同步+合规要求的场景下。数据库这儿一个唯一索引的变更就要卡你好几天，啥敏捷都白搭。&lt;/p&gt;
&lt;p&gt;所以开始那一下“简单”，跟后来改起来的“要老命”比，简直是钓鱼。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;“表结构一看就懂”？懂的可能跟实际要的不一样啊！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;唯一索引在表结构里写着，是，算是一种“技术文档”。可是“文档”可能误导人，如果这个唯一索引定义的“唯一”跟业务上实际的、更复杂的唯一规则对不上（比如大小写问题），那这份“文档”不光没用，还可能误导后来的开发。 如果改这份“文档”（就是改唯一索引）就要经历九九八十一难，那我们为啥不把业务规则好好写在真正的设计文档、Wiki 或者代码注释里呢？那些地方改起来可方便多了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;“顺便还能快点查”？为了这点醋，才包的这顿饺子？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这是个很常见的误解，或者说是一个被过分强调的“附加值”。如果你只是想让某个字段或某几个字段的查询快一点，你完全可以给它们建一个普普通通的、非唯一的索引（Non-Unique Index）啊！非唯一索引照样能嗖嗖地提高查询速度，而且它还没有唯一性约束带来的那些写入开销、DDL 痛苦和业务逻辑的死板限制。&lt;/p&gt;</description>
    </item>
    <item>
      <title>羊了个羊科技通关攻略</title>
      <link>https://simpleapples.com/zh/posts/yang-le-ge-yang-crack/</link>
      <pubDate>Tue, 20 Sep 2022 18:52:00 +0000</pubDate>
      <guid>https://simpleapples.com/zh/posts/yang-le-ge-yang-crack/</guid>
      <description>&lt;p&gt;最近羊了个羊比较火，但是难度非常高，打了几天几十盘都通不过，所以犯了职业病，想看看有没有科技手段，实践有效后整理出来方便大家科技通关。&lt;/p&gt;
&lt;h1 id=&#34;原理&#34;&gt;原理&lt;/h1&gt;
&lt;p&gt;科技通关的原理比较简单，游戏每天都有两幅地图，第一个地图是练手的可以无脑通过，第二个是难度爆表的版本，所以只要能够把第二个地图改成第一个，就可以实现通关。&lt;/p&gt;
&lt;h1 id=&#34;准备工作&#34;&gt;准备工作&lt;/h1&gt;
&lt;p&gt;实现科技通关需要一个 Web 调试代理 App，在 iOS 上可以用 HTTP Catcher（需要内购），Storm Sniffer（三天试用），Android 上也可以找类似的软件。以 HTTP Catcher 为例，安装好之后需要安装并启用 Root 证书，以实现 HTTPS 解密。&lt;/p&gt;
&lt;h1 id=&#34;步骤&#34;&gt;步骤&lt;/h1&gt;
&lt;p&gt;首先需要启动 HTTP Catcher，打开羊了个羊进入游戏开始挑战，然后返回 HTTP Catcher，筛选 JSON 类型的请求，找到包含 map_info_ex 的请求。&lt;/p&gt;
&lt;center&gt;&lt;img style=&#34;margin: 0 10px&#34; src=&#34;https://simpleapples.com/images/20220920_01.png&#34; width=&#34;200&#34;/&gt;&lt;/center&gt;
&lt;p&gt;点进这个请求里的 Response，可以看到返回内容里有个 map_md5 的列表，里面有两个 md5 值，分别对应第一个地图和第二个地图，我们要做的就是把返回值里第二个地图的 md5 替换成第一个的。&lt;/p&gt;
&lt;center&gt;&lt;img style=&#34;margin: 0 10px&#34; src=&#34;https://simpleapples.com/images/20220920_02.png&#34; width=&#34;200&#34;/&gt;&lt;/center&gt;
&lt;p&gt;接下来返回上一个界面，左滑选择更多，新建重写，在弹出的界面中新增规则。&lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://simpleapples.com/images/20220920_03.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;按下图的选择 Response 和 Body，将第二张地图的 md5（可以提前复制好）填入 Find，将第二张地图的 md5 填入 Replace，然后一路保存。&lt;/p&gt;
&lt;center&gt;&lt;img style=&#34;margin: 0 10px&#34; src=&#34;https://simpleapples.com/images/20220920_04.png&#34; width=&#34;200&#34;/&gt;&lt;/center&gt;
&lt;p&gt;接下来重新启动 HTTP Catcher，回到羊了个羊重新开始游戏，第二关就变成和第一关一样简单的地图了。&lt;/p&gt;
&lt;center&gt;&lt;img style=&#34;margin: 0 10px&#34; src=&#34;https://simpleapples.com/images/20220920_05.png&#34; width=&#34;200&#34;/&gt;&lt;/center&gt;</description>
    </item>
    <item>
      <title>基于Clean Architecture的Go项目架构实践</title>
      <link>https://simpleapples.com/zh/posts/go-project-with-clean-architecture/</link>
      <pubDate>Sun, 12 Dec 2021 16:45:00 +0000</pubDate>
      <guid>https://simpleapples.com/zh/posts/go-project-with-clean-architecture/</guid>
      <description>&lt;p&gt;经过这些年的发展，Go 语言已经成为一门被广泛使用在各个领域的编程语言。从 k8s、docker 等基础组件，到业务领域的微服务，都可以用 Go 构建。在构建这些 Go 项目时，采用哪种架构模式和代码布局，是一个仁者见仁智者见智的事情。有 Java Spring 经验的可能会采用 MVC 模式，有 Python Flask 经验的可能会采用 MTV 模式。加上 Go 语言领域并没有出现主流的企业级开发框架，很多项目甚至没有明确的架构模式。&lt;/p&gt;
&lt;h1 id=&#34;clean-architecture&#34;&gt;Clean Architecture&lt;/h1&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://simpleapples.com/images/20211212_01.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;Clean Architecture 是 Uncle Bob 提出的适用于复杂业务系统的架构模式，其核心思想是将业务复杂度与技术复杂度解藕，相比于 MVC、MTV 等模式，Clean Architecture 除了进行分层，还通过约定依赖原则，明确了与外部依赖的交互方式，以及外部依赖与业务逻辑的边界。感兴趣的朋友可以直接阅读作者原文&lt;a href=&#34;https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html&#34;&gt;https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;由于 Clean Architecture 具有脱离语言和框架的灵活性，作者在提出时也没有规定实现细节，给 Clean Architecture 的落地带来了困难，接下来以一个例子来说明如何在 Go 项目中应用 Clean Architecture 的思想。&lt;/p&gt;
&lt;h1 id=&#34;布局&#34;&gt;布局&lt;/h1&gt;
&lt;p&gt;作为一个 Go 项目，不管用哪种架构模式，建议都建立 app 和 scripts 这两个路径。app 存放启动 Go 项目的入口文件，通常是 main.go。而 scripts 可以放一些构建和部署时候用到的脚本。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;clean_architecture_demo
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;├── README.md
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;├── app
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;│   └── main.go
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;├── scripts
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;│   ├── build.sh
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;│   └── run.sh
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;├── go.mod
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;├── go.sum
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;└── usecases
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;接下来是代码部分，分为 entities、usecases、adapters 三个部分。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Python跨服务传递作用域的坑</title>
      <link>https://simpleapples.com/zh/posts/python-cross-scope-issue/</link>
      <pubDate>Sat, 06 Nov 2021 08:25:00 +0000</pubDate>
      <guid>https://simpleapples.com/zh/posts/python-cross-scope-issue/</guid>
      <description>&lt;h1 id=&#34;背景&#34;&gt;背景&lt;/h1&gt;
&lt;p&gt;在一个古老的系统中，有这样一段代码：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;scope &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; dict(globals(), &lt;span style=&#34;color:#f92672&#34;&gt;**&lt;/span&gt;locals())
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;exec(
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;#34;&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;global_a = 123
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;def func_a():
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;    print(global_a)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;#34;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;, scope)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;exec(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;func_a()&amp;#34;&lt;/span&gt;, scope)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;第一段用户代码定义了函数，第二段用户代码执行函数（不要问为什么这么做，因为用户永远是正确的）。第一个代码段执行后，func_a 和 global_a 都会被加入作用域 scope，由于第二个代码段也使用同一个 scope，所以第二个代码段调用 func_a 是可以正确输出 123 的。&lt;/p&gt;
&lt;p&gt;但是使用 exec 执行用户代码毕竟不优雅，也很危险，于是把 exec 函数封装在了一个 Python 沙箱环境中（简单理解就是另一个 Python 服务，将 code 和 scope 传给这个服务后，服务会在沙箱环境调用 exec(code,scope)执行代码），相当于每一次对 exec 调用都替换成了对沙箱服务的 RPC 请求。&lt;/p&gt;
&lt;p&gt;于是代码变成了这个样子：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;scope &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; dict(globals(), &lt;span style=&#34;color:#f92672&#34;&gt;**&lt;/span&gt;locals())
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;scope &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; call_sandbox(
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;#34;&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;global_a = 123
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;def func_a():
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;    print(global_a)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;#34;&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;, scope)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;call_sandbox(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;func_a()&amp;#34;&lt;/span&gt;, scope)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h1 id=&#34;作用域跨服务传递问题&#34;&gt;作用域跨服务传递问题&lt;/h1&gt;
&lt;p&gt;由于多次 RPC 调用需要使用同一个作用域，所以沙箱服务返回了新的 scope，以保证下次调用时作用域不会丢失。但是执行代码会发现第二次 call_sandbox 调用时候，会返回错误：&lt;/p&gt;</description>
    </item>
    <item>
      <title>利用AWS Lambda和iOS捷径实现手机一键开小区门禁</title>
      <link>https://simpleapples.com/zh/posts/one-click-open-door-based-on-aws-lambda-and-ios-shortcut/</link>
      <pubDate>Tue, 19 Oct 2021 22:30:00 +0000</pubDate>
      <guid>https://simpleapples.com/zh/posts/one-click-open-door-based-on-aws-lambda-and-ios-shortcut/</guid>
      <description>&lt;p&gt;我住的小区使用了一个叫守望领域的智能门禁系统，可以通过手机 App 开小区门禁和单元门，但是用 App 开门需要经过四五步：打开 App→ 进入开门界面 → 找到需要开的门 → 点击开门。&lt;/p&gt;
&lt;center&gt;&lt;img style=&#34;margin: 0 10px&#34; src=&#34;https://simpleapples.com/images/20211019_01.png&#34; width=&#34;200&#34;/&gt;&lt;img style=&#34;margin: 0 10px&#34; src=&#34;https://simpleapples.com/images/20211019_02.png&#34; width=&#34;200&#34;/&gt;&lt;img style=&#34;margin: 0 10px&#34; src=&#34;https://simpleapples.com/images/20211019_03.png&#34; width=&#34;200&#34;/&gt;&lt;/center&gt;
&lt;p&gt;加上戴口罩时候解锁手机需要输入密码，导致整个流程非常耗时，经常需要站在小区门口和单元门口操作半天，有一段时间我甚至养成了携带实体门禁卡的习惯，实体门禁卡开门要快很多。&lt;/p&gt;
&lt;p&gt;最近又开始忘带门禁卡，苦恼之余发现 iOS 在锁屏界面右划可以免解锁直接进入 spotlight 界面，这个界面可以添加捷径，如果能写一个捷径去调用守望领域 App 的 API 开门，就可以实现手机免解锁一键开门。&lt;/p&gt;
&lt;center&gt;&lt;img src=&#34;https://simpleapples.com/images/20211019_04.gif&#34; width=&#34;300&#34;/&gt;&lt;/center&gt;
&lt;h1 id=&#34;查找-api&#34;&gt;查找 API&lt;/h1&gt;
&lt;p&gt;首先需要通过 Charles 之类的软件查找 App 调用的 API，配置 Charles 查看 App 请求的方式不再赘述，Google 一下可以看到很多教程。直接看结果 Charles 的结果，可以看到 api.lookdoor.cn 是这个软件所请求的 API 域名。&lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://simpleapples.com/images/20211019_05.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;打开软件发的请求非常多，经过操作和请求的对比可以看到，发送开门指令调用的 API 是：/func/hjapp/house/v1/pushOpenDoorBySn.json?equipmentId=xxxxxx 这个路径。&lt;/p&gt;
&lt;p&gt;详细查看这个请求可以发现，equipmentId 指的就是小区门的 Id，接口使用 cookie 做认证，只要将 cookie 带上就可以模拟开门指令。&lt;/p&gt;
&lt;h1 id=&#34;第一次尝试&#34;&gt;第一次尝试&lt;/h1&gt;
&lt;p&gt;打开 iOS 捷径 App，创建一个新捷径，App 调用 API 使用了 POST 请求，搜索 Get contents of 这个动作来实现发送 POST 请求。&lt;/p&gt;</description>
    </item>
    <item>
      <title>规避 Go 中的常见并发 bug</title>
      <link>https://simpleapples.com/zh/posts/avoid-concurrency-bugs-in-go/</link>
      <pubDate>Tue, 17 Aug 2021 20:53:00 +0000</pubDate>
      <guid>https://simpleapples.com/zh/posts/avoid-concurrency-bugs-in-go/</guid>
      <description>&lt;p&gt;在&lt;a href=&#34;https://cseweb.ucsd.edu/~yiying/GoStudy-ASPLOS19.pdf&#34;&gt;Understanding Real-World Concurrency Bugs in Go&lt;/a&gt;这篇论文中，几名研究人员分析了常见的Go并发bug，并在最流行的几个Go开源项目中进行了验证。本文梳理了论文中提到的常见的bug并给出解决方法的分析。&lt;/p&gt;
&lt;p&gt;论文中对bugs进行了分类，分为阻塞式和非阻塞式两种：
阻塞式：goroutine发生阻塞无法继续执行（例如死锁）
非阻塞式：不会阻塞执行，但存在潜在的数据冲突（例如并发写）&lt;/p&gt;
&lt;h1 id=&#34;阻塞式bug&#34;&gt;阻塞式bug&lt;/h1&gt;
&lt;p&gt;阻塞式bug发生的根因有两种，一种是共享内存（例如卡在了意图保护共享内存的锁操作上），一种是消息传递（比如等待chan）。同时研究发现共享内存和消息传递导致的bug数量不想上下，但是共享这种方法的使用量比消息传递使用的更频繁，所以也得出了共享内存方式更不容易导致bug的结论。&lt;/p&gt;
&lt;h2 id=&#34;读写锁优先级导致的死锁&#34;&gt;读写锁优先级导致的死锁&lt;/h2&gt;
&lt;p&gt;在Go中的写锁优先级高于读锁优先级，假设一个goroutine（goroutine A）连续获取两次读锁，而另一个goroutine（goroutine B）在gouroutine A两次获取读锁中间获取了写锁，就会导致死锁的发生。论文中没有针对这个bug给出示例代码，我写了一个简单的代码示意一下。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;gouroutine1&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;m&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;RLock&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;m&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;RLock&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;gouroutine2&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;m&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;WLock&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;f1和f2都在goroutine中执行，当f1执行完第一个l.RLock()语句后，假设这时f2的m.WLock执行，由于写锁是排它的，WLock本身被f1的第一个m.RLock()阻塞，写锁操作本身又会阻塞f1中的第二个m.RLock&lt;/p&gt;
&lt;h2 id=&#34;waitgroup误用导致的死锁&#34;&gt;WaitGroup误用导致的死锁&lt;/h2&gt;
&lt;p&gt;这种情况就是比较典型的WaitGroup的误用了，提前执行group.Wait()会导致部分group.Done()无法执行到，进而导致程序被阻塞。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;group&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;sync&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;WaitGroup&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;group&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Add&lt;/span&gt;(len(&lt;span style=&#34;color:#a6e22e&#34;&gt;pm&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;plugins&lt;/span&gt;))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;_&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;p&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;range&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;pm&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;plugins&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;go&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;p&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;plugin&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;defer&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;group&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Done&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;group&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Wait&lt;/span&gt;()  &lt;span style=&#34;color:#75715e&#34;&gt;// blocked&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// group.Wait() should be here&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;for循环内的group.Wait()执行到的时候，循环内的部分goroutine还没有被创建出来，其中的group.Done()也就永远没法执行到，所以会导致永远阻塞在这一句，正确的写法是将group.Wait()移到for循环外。&lt;/p&gt;
&lt;h2 id=&#34;channel的误用&#34;&gt;Channel的误用&lt;/h2&gt;
&lt;p&gt;Channel是go支持并发的一个非常重要的特性，Channel虽然在很多场景下非常解决问题，但是误用也是不容易发现的。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;goroutine1&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;m&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Lock&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;ch&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;-&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;request&lt;/span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// blocked&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;m&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Unlock&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;goroutine2&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;m&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Lock&lt;/span&gt;()  &lt;span style=&#34;color:#75715e&#34;&gt;// 阻塞&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;m&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Unlock&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;request&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;-&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ch&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这段代码的业务语义是goroutine1会通过ch接收goroutine2发送的消息，但是当goroutine1执行到ch &amp;lt;- request时候会阻塞并等待ch，此时由于goroutine1没有释放锁，goroutine2的m.Lock()也会阻塞，形成死锁。&lt;/p&gt;</description>
    </item>
    <item>
      <title>MySQL 子查询中order by不生效问题</title>
      <link>https://simpleapples.com/zh/posts/orderby-invalid-in-subquery/</link>
      <pubDate>Thu, 29 Jul 2021 21:19:00 +0000</pubDate>
      <guid>https://simpleapples.com/zh/posts/orderby-invalid-in-subquery/</guid>
      <description>&lt;p&gt;一个偶然的机会，发现一条 SQL 语句在不同的 MySQL 实例上执行得到了不同的结果。&lt;/p&gt;
&lt;h1 id=&#34;问题描述&#34;&gt;问题描述&lt;/h1&gt;
&lt;p&gt;创建商品表 product_tbl 和商品操作记录表 product_operation_tbl 两个表，来模拟下业务场景，结构和数据如下：&lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://simpleapples.com/images/20210729_01.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://simpleapples.com/images/20210729_02.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;接下来需要查询所有商品最新的修改时间，使用如下语句：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;select&lt;/span&gt; t1.id, t1.name, t2.product_id, t2.created_at  &lt;span style=&#34;color:#66d9ef&#34;&gt;from&lt;/span&gt; product_tbl t1 &lt;span style=&#34;color:#66d9ef&#34;&gt;left&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;join&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;select&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;from&lt;/span&gt; product_operation_log_tbl &lt;span style=&#34;color:#66d9ef&#34;&gt;order&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;by&lt;/span&gt; created_at &lt;span style=&#34;color:#66d9ef&#34;&gt;desc&lt;/span&gt;) t2 &lt;span style=&#34;color:#66d9ef&#34;&gt;on&lt;/span&gt; t1.id &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; t2.product_id &lt;span style=&#34;color:#66d9ef&#34;&gt;group&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;by&lt;/span&gt; t1.id;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;通过结果可以看到，子查询先将 product_operation_log_tbl 里的所有记录按创建时间(created_at)逆序，然后和 product_tbl 进行 join 操作，进而查询出的商品的最新修改时间。&lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://simpleapples.com/images/20210729_03.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;在区域 A 的 MySQL 实例上，查询商品最新修改时间可以得到正确结果，但是在区域 B 的 MySQL 实例上，得到的修改时间并不是最新的，而是最老的。通过对语句进行简化，发现是子查询中的 order by created_at desc 语句在区域 B 的实例上没有生效。&lt;/p&gt;
&lt;h1 id=&#34;排查过程&#34;&gt;排查过程&lt;/h1&gt;
&lt;p&gt;难道区域会影响 MySQL 的行为？经过 DBA 排查，区域 A 的 MySQL 是 5.6 版，区域 B 的 MySQL 是 5.7 版，并且找到了这篇文章：&lt;/p&gt;</description>
    </item>
    <item>
      <title>为 WSL2 一键设置代理</title>
      <link>https://simpleapples.com/zh/posts/one-click-setting-proxy-for-wsl2/</link>
      <pubDate>Tue, 30 Jun 2020 15:34:00 +0000</pubDate>
      <guid>https://simpleapples.com/zh/posts/one-click-setting-proxy-for-wsl2/</guid>
      <description>&lt;p&gt;在 WSL2 环境中 clone 一个很大的 git 项目，不走代理速度很慢，所以研究了一下怎么让 WSL2 走 Windows 的代理客户端。&lt;/p&gt;
&lt;h3 id=&#34;wsl1-和-wsl2-网络的区别&#34;&gt;WSL1 和 WSL2 网络的区别&lt;/h3&gt;
&lt;p&gt;在 WSL1 时代，由于 Linux 子系统和 Windows 共享了网络端口，所以访问 Windows 的代理非常简单。例如 Windows 的代理客户端监听了 8000 端口，那么只需要在 Linux 子系统中执行如下命令，就可以让当前 session 中的请求通过代理访问互联网。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;export ALL_PROXY&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;http://127.0.0.1:8000&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;但是 WSL2 基于 Hyper-V 运行，导致 Linux 子系统和 Windows 在网络上是两台各自独立的机器，从 Linux 子系统访问 Windows 首先需要找到 Windows 的 IP。&lt;/p&gt;
&lt;h3 id=&#34;配置-wsl2-访问-windows-上的代理&#34;&gt;配置 WSL2 访问 Windows 上的代理&lt;/h3&gt;
&lt;p&gt;有两个关键步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;WSL2 中配置的代理要指向 Windows 的 IP；&lt;/li&gt;
&lt;li&gt;Windows 上的代理客户端需要允许来自本地局域网的请求；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;由于 Linux 子系统也是通过 Windows 访问网络，所以 Linux 子系统中的网关指向的是 Windows，DNS 服务器指向的也是 Windows，基于这两个特性，我们可以将 Windows 的 IP 读取出来。&lt;/p&gt;</description>
    </item>
    <item>
      <title>面向开发者的 WSL2 安装指南</title>
      <link>https://simpleapples.com/zh/posts/wsl2-guideline-for-developers/</link>
      <pubDate>Mon, 01 Jun 2020 19:02:00 +0000</pubDate>
      <guid>https://simpleapples.com/zh/posts/wsl2-guideline-for-developers/</guid>
      <description>&lt;h3 id=&#34;为什么要使用-windows-做开发&#34;&gt;为什么要使用 Windows 做开发&lt;/h3&gt;
&lt;p&gt;一直以来 macOS 以类 unix 的特性，获得了程序员的青睐，但是近几年 Apple 在硬件领域少有让人耳目一新的产品，加上取消 Esc、使用蝶式键盘、基本为 0 的硬件可升级性、系统权限的收紧等骚操作，让 Mac 从软件到硬件都不如以前适合编程。另一方面，PC 阵营在软件层面保持开放的基础上，硬件体验也逐步赶上甚至超越 Mac，我也不想在用 Mac 做开发，用 PC 玩游戏，希望用一台电脑兼顾游戏和开发，所以选择回到了 PC 阵营。&lt;/p&gt;
&lt;p&gt;随着微软拥抱开源领域，Windows 也开始变得程序员友好。Windows 10 2004 发布后，WSL2 也可以在正式版 Windows 10 中使用，相比于 macOS，WSL2 是一个原生 Linux 环境而非类 unix 环境，甚至可以在 App 商店中选择所需要的发行版。而相比于 WSL1，WSL2 采用了 HyperV 虚拟机的方式，解决了 WSL1 不能安装 Docker 等问题。&lt;/p&gt;
&lt;h3 id=&#34;wsl1-和-wsl2&#34;&gt;WSL1 和 WSL2&lt;/h3&gt;
&lt;p&gt;相比于 WSL1，WSL2 通过虚拟机的方式带来了更完整的 Linux 内核，但这种方式也引入了一些问题，微软给出了下面的图表来展示这些不同：&lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://simpleapples.com/images/20200601_01.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;WSL2 不能和 VMWarework Station、VirtualBox 同时运行这一条已经过时了，VirtualBox 和 VMWare Workstation 都发布了支持 WSL2 和 Hyper-V 的新版。&lt;/p&gt;</description>
    </item>
    <item>
      <title>gRPC 跨进程使用引发的问题</title>
      <link>https://simpleapples.com/zh/posts/grpc-fork-support/</link>
      <pubDate>Thu, 23 Apr 2020 14:30:00 +0000</pubDate>
      <guid>https://simpleapples.com/zh/posts/grpc-fork-support/</guid>
      <description>&lt;h3 id=&#34;问题描述&#34;&gt;问题描述&lt;/h3&gt;
&lt;p&gt;在 Python 项目中使用 gRPC 进行通信，跨进程使用时，会出现阻塞或报错的情况（根据 gRPC.io 的版本不同，现象不同）。下面代码展示了一个跨进程使用的 DEMO，主进程向 30001 端口上的 gRPC 服务器发送请求，子进程也向相同的服务器发送请求。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;send&lt;/span&gt;():
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    channel &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; grpc&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;insecure_channel(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;localhost:30001&amp;#39;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    stub &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; message_pb2_grpc&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;GreeterStub(channel)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    response &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; stub&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;SayHello(message_pb2&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;HelloRequest(name&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;you&amp;#39;&lt;/span&gt;))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    print(&lt;span style=&#34;color:#e6db74&#34;&gt;f&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Greeter client received 1: &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; response&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;message)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;():
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    channel &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; grpc&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;insecure_channel(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;localhost:30001&amp;#39;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    stub &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; message_pb2_grpc&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;GreeterStub(channel)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    response &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; stub&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;SayHello2(message_pb2&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;HelloRequest(name&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;you&amp;#39;&lt;/span&gt;))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    print(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Greeter client received 2: &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; response&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;message)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    p &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; multiprocessing&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;Process(target&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;send)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    p&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;start()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    p&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;join()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; __name__ &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;__main__&amp;#39;&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    main()
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;使用 gRPC.io 1.28.1 的情况下，会发生报错，主进程可以正常收到服务器的返回，但是子进程报 &lt;code&gt;Socket operation on non-socket&lt;/code&gt;。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;raise _InactiveRpcError&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;state&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;grpc._channel._InactiveRpcError: &amp;lt;_InactiveRpcError of RPC that terminated with:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        status &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; StatusCode.UNAVAILABLE
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        details &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Socket operation on non-socket&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        debug_error_string &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;{&amp;#34;&lt;/span&gt;created&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;:&amp;#34;&lt;/span&gt;@1587481625.192071231&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;,&amp;#34;&lt;/span&gt;description&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;:&amp;#34;&lt;/span&gt;Error received from peer ipv6:&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;::1&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;:50051&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;,&amp;#34;&lt;/span&gt;file&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;:&amp;#34;&lt;/span&gt;src/core/lib/surface/call.cc&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;,&amp;#34;&lt;/span&gt;file_line&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;:1056,&amp;#34;&lt;/span&gt;grpc_message&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;:&amp;#34;&lt;/span&gt;Socket operation on non-socket&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;,&amp;#34;&lt;/span&gt;grpc_status&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;:14}&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;排查过程&#34;&gt;排查过程&lt;/h3&gt;
&lt;p&gt;根据代码，主进程和子进程分别创建了自己的 Channel，看上去逻辑没什么问题，没有什么思路，所以多尝试几种情况先测试一下吧。首先尝试了一下主进程和子进程请求不同的server，在 30001 和 30002 端口分别启动两个 gRPC Server，然后将客户端代码改为主进程请求 30001 端口，子进程请求 30002 端口，代码可以正常运行。测试到这里就更摸不着头脑了，代码明明写的是主进程子进程分别创建 Channel，现在的现象看上去&lt;strong&gt;像是在请求相同服务器的情况下，子进程复用了主进程的socket连接&lt;/strong&gt;。gRPC 底层使用的是 HTTP2，而 HTTP2 使用了长连接，会不会是这个原因？&lt;/p&gt;</description>
    </item>
    <item>
      <title>探究vscode debug流程，解决无法运行go程序的问题</title>
      <link>https://simpleapples.com/zh/posts/vscode-cant-run-go-project/</link>
      <pubDate>Mon, 20 Apr 2020 15:35:00 +0000</pubDate>
      <guid>https://simpleapples.com/zh/posts/vscode-cant-run-go-project/</guid>
      <description>&lt;h3 id=&#34;问题描述&#34;&gt;问题描述&lt;/h3&gt;
&lt;p&gt;vscode 无法以 &lt;code&gt;run&lt;/code&gt; 模式运行 go 项目（只能以 &lt;code&gt;debug&lt;/code&gt; 模式调试），并且有如下报错。&lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://simpleapples.com/images/20200420_01.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;图中被遮盖的部分是项目内的 package，并非第三方 package，也就是说在以 &lt;code&gt;run&lt;/code&gt; 模式运行 go 项目时无法找到其他的 go 文件，只能找到入口文件。&lt;/p&gt;
&lt;h3 id=&#34;初步排查&#34;&gt;初步排查&lt;/h3&gt;
&lt;p&gt;找不到其他文件，首先想到的是 GO_PATH 的问题，但是项目使用了 go mod，允许在 GO_PATH 之外的路径创建项目，所以这个怀疑点排除。接下来怀疑 vscode 的配置有问题，每个 vscode 项目中都有 .launch.json 文件，配置运行代码时的环境，下面是项目中的 .launch.json。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// Use IntelliSense to learn about possible attributes.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// Hover to view descriptions of existing attributes.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;version&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;0.2.0&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;configurations&amp;#34;&lt;/span&gt;: [
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Launch&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;type&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;go&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;request&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;launch&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;mode&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;auto&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;program&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;${workspaceRoot}/src/main.go&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;env&amp;#34;&lt;/span&gt;: {},
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;args&amp;#34;&lt;/span&gt;: []
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  ]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;可以看到 .launch.json 里没有指定程序的工作目录，&lt;code&gt;debug&lt;/code&gt; 模式和 &lt;code&gt;run&lt;/code&gt; 模式会不会默认的工作路径不同呢？于是在 main 函数里使用 &lt;code&gt;os.Getwd()&lt;/code&gt; 打印一下当前的路径，结果如下：&lt;/p&gt;</description>
    </item>
    <item>
      <title>viper从etcd读取配置失败的问题</title>
      <link>https://simpleapples.com/zh/posts/viper-read-from-etcd-failed/</link>
      <pubDate>Thu, 16 Apr 2020 11:35:00 +0000</pubDate>
      <guid>https://simpleapples.com/zh/posts/viper-read-from-etcd-failed/</guid>
      <description>&lt;h3 id=&#34;问题描述&#34;&gt;问题描述&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/spf13/viper&#34;&gt;Viper&lt;/a&gt; （本文环境是 Viper 1.1.0）是 Go 应用程序的完整配置解决方案，在很多项目中都有应用。&lt;a href=&#34;https://github.com/etcd-io/etcd&#34;&gt;etcd&lt;/a&gt;是一个分布式 KV 存储，最直接的应用是配置中心。&lt;/p&gt;
&lt;p&gt;Viper 除了支持从文件中读取配置，还支持从远程的配置中心读取配置，使用下面的代码进行配置。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;viper&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;AddRemoteProvider&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;etcd&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;http://127.0.0.1:2379&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;conf.toml&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;viper&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;SetConfigType&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;toml&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;viper&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;ReadRemoteConfig&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;nil&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    panic(&lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;运行后报错&lt;code&gt;panic: Remote Configurations Error: No Files Found&lt;/code&gt;，检查后发现 etcd 开启了 tls，所以需要用 https 协议访问 etcd 的 API，更新代码如下。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;viper&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;AddSecureRemoteProvider&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;etcd&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;https://127.0.0.1:2379&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;conf.toml&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;key_path&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;viper&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;SetConfigType&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;toml&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;viper&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;ReadRemoteConfig&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;nil&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    panic(&lt;span style=&#34;color:#a6e22e&#34;&gt;err&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;使用&lt;code&gt;AddSecureRemoteProvider&lt;/code&gt;方法替换&lt;code&gt;AddRemoteProvider&lt;/code&gt;方法，问题依旧。&lt;/p&gt;
&lt;h3 id=&#34;定位问题&#34;&gt;定位问题&lt;/h3&gt;
&lt;p&gt;跟踪源码发现，最终像 etcd 发送请求的是&lt;a href=&#34;https://github.com/coreos/go-etcd/&#34;&gt;go-etcd&lt;/a&gt;包（目前 go-etcd 已经不维护），在 go-etcd 的 requests.go 文件中找到了相关的源码，go-etcd 调用了 net/http 包向 etcd 发送请求。&lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://simpleapples.com/images/20200416_01.jpg&#34;&gt;&lt;/p&gt;
&lt;p&gt;这个时候忽然想到 etcd 的证书是自签名的，访问自签名证书的 https 接口应该会报错啊，怎么会请求到内容呢？如下图，在 Chrome 中访问 etcd 的自签名 https 接口，会提示证书无效。&lt;/p&gt;</description>
    </item>
    <item>
      <title>使用Pipfile代替reqirements.txt</title>
      <link>https://simpleapples.com/zh/posts/use-pipfile-instead-of-requirements/</link>
      <pubDate>Tue, 31 Mar 2020 12:50:00 +0000</pubDate>
      <guid>https://simpleapples.com/zh/posts/use-pipfile-instead-of-requirements/</guid>
      <description>&lt;p&gt;很多语言都提供了环境隔离的支持，例如nodejs的node_module，golang的go mod，python也有virtualenv和pyvenv等机制。为了建立依赖快照，通常会用&lt;code&gt;pip freeze &amp;gt; requirements.txt&lt;/code&gt; 命令生成一个requirements.txt文件，在一些场景下这种方式就可以满足需求，但是在复杂场景下requirements.txt就力不从心了。&lt;/p&gt;
&lt;h3 id=&#34;requirementstxt&#34;&gt;requirements.txt&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;appdirs==1.4.3
astroid==2.3.3
attrs==19.3.0
black==19.3b0
certifi==2019.11.28
chardet==3.0.4
click==7.1.1
et-xmlfile==1.0.1
Flask==1.1.1
gevent==1.4.0
greenlet==0.4.15
idna==2.9
isort==4.3.21
itsdangerous==1.1.0
jdcal==1.4.1
Jinja2==2.11.1
lazy-object-proxy==1.4.3
MarkupSafe==1.1.1
mccabe==0.6.1
numpy==1.18.2
openpyxl==3.0.3
pandas==1.0.3
pylint==2.4.4
python-dateutil==2.8.1
pytz==2019.3
requests==2.23.0
six==1.14.0
tinydb==3.15.2
toml==0.10.0
typed-ast==1.4.1
urllib3==1.25.8
Werkzeug==1.0.0
wrapt==1.11.2
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;requirements.txt文件中只记录了依赖的版本，所以如果遇到官方的pypi源下载速度慢，需要使用更快的国内镜像下载，通常只能使用&lt;code&gt;pip install -i&lt;/code&gt;安装或者修改全局的pip.conf文件。&lt;/p&gt;
&lt;p&gt;当某个项目使用确定的python版本，这个版本也并不能在requirements.txt中体现，只能通过readme或者文档来记录，并且需要在创建虚拟环境时手动调用正确的python版本。&lt;/p&gt;
&lt;p&gt;项目需要使用flake8、pylint、black等代码优化工具时，这些依赖也会被&lt;code&gt;pip freeze&lt;/code&gt;命令写入requirements.txt中，然而这些依赖是不需要出现在生产环境的。&lt;/p&gt;
&lt;h3 id=&#34;pipfile&#34;&gt;Pipfile&lt;/h3&gt;
&lt;p&gt;Pipenv的出现，一举解决了上面的问题，Pipenv是Kenneth Reitz在2017年1月发布的Python依赖管理工具，他所基于的Pipfile则用来替代requirements.txt。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;[[source]]
name = &amp;#34;pypi&amp;#34;
url = &amp;#34;https://pypi.doubanio.com/simple&amp;#34;
verify_ssl = false

[dev-packages]
isort = &amp;#34;*&amp;#34;
black = &amp;#34;==19.3b0&amp;#34;
pylint = &amp;#34;*&amp;#34;

[packages]
flask = &amp;#34;*&amp;#34;
tinydb = &amp;#34;*&amp;#34;
pandas = &amp;#34;*&amp;#34;
requests = &amp;#34;*&amp;#34;
gevent = &amp;#34;*&amp;#34;
openpyxl = &amp;#34;*&amp;#34;

[requires]
python_version = &amp;#34;3.6&amp;#34;
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;好处1记录内容更详细&#34;&gt;好处1：记录内容更详细&lt;/h4&gt;
&lt;p&gt;相比于requirements.txt，Pipfile多了pip源的设置，可以针对不同项目使用不同环境。并且将依赖分为dev和默认环境，例如pylint、flake8、black等依赖，可以将他们放入dev依赖中。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Docker COPY 复制文件夹的诡异行为</title>
      <link>https://simpleapples.com/zh/posts/dockers-creepy-behaviour-in-copying-folders/</link>
      <pubDate>Mon, 28 Oct 2019 10:55:00 +0000</pubDate>
      <guid>https://simpleapples.com/zh/posts/dockers-creepy-behaviour-in-copying-folders/</guid>
      <description>&lt;h3 id=&#34;问题现象&#34;&gt;问题现象&lt;/h3&gt;
&lt;p&gt;在制作 docker 镜像时，有复制某一个路径下所有文件和文件夹到镜像的需求，写下了如下 dockerfile：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-dockerfile&#34; data-lang=&#34;dockerfile&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;FROM&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt; alpine&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;WORKDIR&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt; /root/test_docker_proj&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;COPY&lt;/span&gt; * ./&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;原始目录结构是这样的：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;/projects/test_docker_proj
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;├── Dockerfile
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;├── dir1
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;│   ├── dir11
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;│   │   └── file11
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;│   └── file1
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;└── file2
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;然而复制到 docker 镜像里的目录结构变成了这样：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;/root/test_docker_proj
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;├── Dockerfile
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;├── dir11
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;│   └── file11
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;├── file1
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;└── file2
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;!-- more --&gt;
&lt;p&gt;可以看到 dir1 这个文件夹并没有被复制到镜像里，但是 dir1 中的子文件夹和文件都被复制进来了，和 dir1 同级的文件也被复制了。也就是说，在 COPY 执行的过程中，第一层文件夹被「解包」了。&lt;/p&gt;
&lt;h3 id=&#34;copyadd-行为逻辑&#34;&gt;COPY/ADD 行为逻辑&lt;/h3&gt;
&lt;p&gt;为了确定 COPY 和相似的 ADD 命令的行为，做了以下测试：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-dockerfile&#34; data-lang=&#34;dockerfile&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;FROM&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt; alpine&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;WORKDIR&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt; /root/test_docker_proj_1&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;COPY&lt;/span&gt; * ./&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;WORKDIR&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt; /root/test_docker_proj_2&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;ADD&lt;/span&gt; * ./&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;WORKDIR&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt; /root/test_docker_proj_3&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;COPY&lt;/span&gt; ./ ./&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;WORKDIR&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt; /root/test_docker_proj_4&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;ADD&lt;/span&gt; ./ ./&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;WORKDIR&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt; /root/test_docker_proj_5&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;COPY&lt;/span&gt; ./dir* ./&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;WORKDIR&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt; /root/test_docker_proj_6&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;ADD&lt;/span&gt; ./dir* ./&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;通过测试可以发现 &lt;code&gt;COPY/ADD&lt;/code&gt; 命令有这么几个规则：&lt;/p&gt;</description>
    </item>
    <item>
      <title>探究 Pandas 读取 Excel 文件报错问题</title>
      <link>https://simpleapples.com/zh/posts/solution-for-pandas-assertion-error-while-reading-an-excel-file/</link>
      <pubDate>Thu, 22 Aug 2019 15:50:00 +0000</pubDate>
      <guid>https://simpleapples.com/zh/posts/solution-for-pandas-assertion-error-while-reading-an-excel-file/</guid>
      <description>&lt;h3 id=&#34;问题描述&#34;&gt;问题描述&lt;/h3&gt;
&lt;p&gt;使用 Pandas 的 &lt;code&gt;read_excel&lt;/code&gt; 方法读取一个 16 万行的 Excel 文件报 &lt;code&gt;AssertionError&lt;/code&gt; 错误：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;  &amp;#34;/Users/XXX/excel_test/venv/lib/python3.7/site-packages/xlrd/xlsx.py&amp;#34;, line 637, in do_row
    assert 0 &amp;lt;= self.rowx &amp;lt; X12_MAX_ROWS
AssertionError
&lt;/code&gt;&lt;/pre&gt;&lt;!-- more --&gt; 
&lt;h3 id=&#34;背后原理&#34;&gt;背后原理&lt;/h3&gt;
&lt;p&gt;Excel 文件有两种默认格式，在 Excel 2007 以前，使用扩展名为 &lt;code&gt;.xls&lt;/code&gt; 格式的文件，这种文件格式是一种特定的二进制格式，最多支持 65,536 行（在 Excel 97 之前支持的最大行数是 16,384），256 列表格。从 Excel 2007 版开始，默认采用了基于 XML 的新的文件格式 &lt;code&gt;.xlsx&lt;/code&gt;，支持的表格行数达到了 1,048,576，列数达到了 16,384。需要注意的是，将 &lt;code&gt;.xlsx&lt;/code&gt; 格式的文件转换为 &lt;code&gt;.xls&lt;/code&gt; 格式的文件时，65,536 行和 256 列之后的数据都会被丢弃。&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;版本&lt;/th&gt;
          &lt;th&gt;最大行数&lt;/th&gt;
          &lt;th&gt;最大列数&lt;/th&gt;
          &lt;th&gt;文件格式&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;Excel 97 之前&lt;/td&gt;
          &lt;td&gt;16,384&lt;/td&gt;
          &lt;td&gt;256&lt;/td&gt;
          &lt;td&gt;.xls&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Excel 97 到 Excel 2003&lt;/td&gt;
          &lt;td&gt;65,536&lt;/td&gt;
          &lt;td&gt;256&lt;/td&gt;
          &lt;td&gt;.xls&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Excel 2007 及以后版本&lt;/td&gt;
          &lt;td&gt;1,048,576&lt;/td&gt;
          &lt;td&gt;16,384&lt;/td&gt;
          &lt;td&gt;.xlsx&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Pandas 读取 Excel 文件的引擎是 &lt;code&gt;xlrd&lt;/code&gt;，&lt;code&gt;xlrd&lt;/code&gt; 在读取 Excel 文件时，&lt;a href=&#34;https://github.com/python-excel/xlrd/blob/master/xlrd/xlsx.py&#34;&gt;&lt;code&gt;xlrd/xlsx.py&lt;/code&gt;&lt;/a&gt; 文件的 637 行会对行号做断言，判断行号是否在 0 - 1,048,576（Excel支持的最大行数） 的范围内。这段代码是这样的：&lt;/p&gt;</description>
    </item>
    <item>
      <title>使用代理进行 docker build 问题的解决思路</title>
      <link>https://simpleapples.com/zh/posts/building-docker-image-behind-proxy/</link>
      <pubDate>Thu, 18 Apr 2019 10:55:00 +0000</pubDate>
      <guid>https://simpleapples.com/zh/posts/building-docker-image-behind-proxy/</guid>
      <description>&lt;h3 id=&#34;问题描述&#34;&gt;问题描述&lt;/h3&gt;
&lt;p&gt;在使用 docker build 打包镜像时，遇到了需要使用代理访问网络的需求。使用如下的 Dockerfile 来模拟这个场景：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-dockerfile&#34; data-lang=&#34;dockerfile&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;FROM&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt; golang:1.12&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;RUN&lt;/span&gt; curl www.google.com --max-time &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;国内一般网络环境下，curl &lt;a href=&#34;https://www.google.com&#34;&gt;www.google.com&lt;/a&gt; 是无法正常返回的，加入 &amp;ndash;max-time 让 curl 的耗时不要太长。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h3 id=&#34;配置-http_proxy-变量&#34;&gt;配置 http_proxy 变量&lt;/h3&gt;
&lt;p&gt;首先需要在环境变量中设置 http_proxy 和 https_proxy，使得访问网络的命令（这里使用 curl 来代表）能够通过环境变量中配置的代理服务器访问 &lt;a href=&#34;https://www.google.com&#34;&gt;www.google.com&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;docker build 命令虽然是在 docker 所在的宿主机上执行的，看上去像是直接使用了宿主机的网络环境，但实际上 docker build 也是启动了一个 container 进行构建，所以在构建过程中的所有命令都是在 container 中执行的，http_proxy 和 https_proxy 的配置也应该是在 container 中进行的。可以使用 ENV 来配置 container 中的环境变量。&lt;/p&gt;
&lt;p&gt;代理服务器启动在宿主机的 1087 端口上，修改 dockerfile 文件：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-dockerfile&#34; data-lang=&#34;dockerfile&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;FROM&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt; golang:1.12&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;ENV&lt;/span&gt; http_proxy &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;http://127.0.0.1:1087&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;ENV&lt;/span&gt; HTTP_PROXY &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;http://127.0.0.1:1087&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;ENV&lt;/span&gt; https_proxy &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;http://127.0.0.1:1087&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;ENV&lt;/span&gt; HTTPS_PROXY &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;http://127.0.0.1:1087&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;RUN&lt;/span&gt; curl www.google.com --max-time &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;重新执行 docker build 会发现 curl 依旧无法访问 &lt;a href=&#34;https://www.google.com&#34;&gt;www.google.com&lt;/a&gt;，从报错信息上可以看到 127.0.0.1 上的 1087 端口上并没有服务。&lt;/p&gt;</description>
    </item>
    <item>
      <title>理解 PostgreSQL 的 count 函数的行为</title>
      <link>https://simpleapples.com/zh/posts/understanding-postgres-count-function/</link>
      <pubDate>Tue, 16 Apr 2019 11:25:00 +0000</pubDate>
      <guid>https://simpleapples.com/zh/posts/understanding-postgres-count-function/</guid>
      <description>&lt;p&gt;关于 count 函数的使用一直存在争议，尤其是在 MySQL 中，作为流行度越来越高的 PostgreSQL 是否也有类似的问题呢，我们通过实践来理解一下 PostgreSQL 中 count 函数的行为。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h3 id=&#34;构建测试数据库&#34;&gt;构建测试数据库&lt;/h3&gt;
&lt;p&gt;创建测试数据库，并创建测试表。测试表中有自增 ID、创建时间、内容三个字段，自增 ID 字段是主键。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;create&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;database&lt;/span&gt; performance_test;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;create&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;table&lt;/span&gt; test_tbl (id serial &lt;span style=&#34;color:#66d9ef&#34;&gt;primary&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;key&lt;/span&gt;, created_at &lt;span style=&#34;color:#66d9ef&#34;&gt;timestamp&lt;/span&gt;, content varchar(&lt;span style=&#34;color:#ae81ff&#34;&gt;512&lt;/span&gt;));
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;生成测试数据&#34;&gt;生成测试数据&lt;/h3&gt;
&lt;p&gt;使用 generate_series 函数生成自增 ID，使用 now() 函数生成 created_at 列，对于 content 列，使用了 repeat(md5(random()::text), 10) 生成 10 个 32 位长度的 md5 字符串。使用下列语句，插入 1000w 条记录用于测试。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;performance_test&lt;span style=&#34;color:#f92672&#34;&gt;=#&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;insert&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;into&lt;/span&gt; test_tbl &lt;span style=&#34;color:#66d9ef&#34;&gt;select&lt;/span&gt; generate_series(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;10000000&lt;/span&gt;),now(),repeat(md5(random()::text),&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;INSERT&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10000000&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Time: &lt;span style=&#34;color:#ae81ff&#34;&gt;212184&lt;/span&gt;.&lt;span style=&#34;color:#ae81ff&#34;&gt;223&lt;/span&gt; ms (&lt;span style=&#34;color:#ae81ff&#34;&gt;03&lt;/span&gt;:&lt;span style=&#34;color:#ae81ff&#34;&gt;32&lt;/span&gt;.&lt;span style=&#34;color:#ae81ff&#34;&gt;184&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;由-count-语句引发的思考&#34;&gt;由 count 语句引发的思考&lt;/h3&gt;
&lt;p&gt;默认情况下 PostgreSQL 不开启 SQL 执行时间的显示，所以需要手动开启一下，方便后面的测试对比。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;\&lt;/span&gt;timing &lt;span style=&#34;color:#66d9ef&#34;&gt;on&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;count(*) 和 count(1) 的性能区别是经常被讨论的问题，分别使用 count(*) 和 count(1) 执行一次查询。&lt;/p&gt;</description>
    </item>
    <item>
      <title>JWT 避坑指南：nbf 验签失效问题的解决</title>
      <link>https://simpleapples.com/zh/posts/solution-to-problem-of-jwt-token-invalidation/</link>
      <pubDate>Tue, 26 Mar 2019 18:52:00 +0000</pubDate>
      <guid>https://simpleapples.com/zh/posts/solution-to-problem-of-jwt-token-invalidation/</guid>
      <description>&lt;h3 id=&#34;现象&#34;&gt;现象&lt;/h3&gt;
&lt;p&gt;刚签发的 JWT，在下一个请求使用时候会失效，请求会报 422 错误。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#34;msg&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;The token is not yet valid (nbf)&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果隔几秒再请求（例如使用 Chrome 开发者工具中的 Replay XHR），就会成功。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://simpleapples.com/images/20190326_01.png&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;nbf-字段的原理&#34;&gt;nbf 字段的原理&lt;/h3&gt;
&lt;p&gt;查看上面的报错信息，会发现有一个 nbf，nbf 是 JWT 协议中的一个字段，是 Not Before 的缩写，表示 JWT Token 在这个时间之前是无效的，一般来讲会设置成签发的时间。这里产生了一个猜想，多服务器环境时候，服务器之间时间如果不一致，一台服务器签发的 token 如果立刻被发往另一台服务器验证，就很容易产生 nbf 字段验证不通过的问题。其实 JWT 协议已经考虑到了这类问题，所以协议中在 nbf 这一节专门提到了可以使用一个 small leeway 来解决这个问题。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;4.1.5. &amp;ldquo;nbf&amp;rdquo; (Not Before) Claim&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;The &amp;ldquo;nbf&amp;rdquo; (not before) claim identifies the time before which the JWT
MUST NOT be accepted for processing. The processing of the &amp;ldquo;nbf&amp;rdquo;
claim requires that the current date/time MUST be after or equal to
the not-before date/time listed in the &amp;ldquo;nbf&amp;rdquo; claim. Implementers MAY
provide for some small leeway, usually no more than a few minutes, to
account for clock skew. Its value MUST be a number containing a
NumericDate value. Use of this claim is OPTIONAL.&lt;/p&gt;</description>
    </item>
    <item>
      <title>nginx &#43; ingress &#43; gunicorn 环境上传大文件报错问题的解决思路</title>
      <link>https://simpleapples.com/zh/posts/update-error-on-nginx-ingress-gunicorn-environment/</link>
      <pubDate>Thu, 28 Feb 2019 14:32:00 +0000</pubDate>
      <guid>https://simpleapples.com/zh/posts/update-error-on-nginx-ingress-gunicorn-environment/</guid>
      <description>&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://simpleapples.com/images/20190228_01.jpeg&#34;&gt;&lt;/p&gt;
&lt;p&gt;在基于 Kubernetes 部署，使用 Gunicorn 运行的 Python Web 应用中，上传大文件时出现了一系列的错误，现在将解决问题的思路记录如下。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h3 id=&#34;文件上传过程&#34;&gt;文件上传过程&lt;/h3&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://simpleapples.com/images/20190228_02.jpg&#34;&gt;&lt;/p&gt;
&lt;p&gt;上传文件流程&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;上传的文件首先到达 Kubernetes 所在的宿主机。&lt;/li&gt;
&lt;li&gt;宿主机上的 Nginx 通过 Proxy 转发给 Kubernetes 集群中的 Ingress Controller，Ingress controller 也是使用 Nginx 实现的。&lt;/li&gt;
&lt;li&gt;Ingress Controller 中的 Nginx 通过 Proxy 转发给 Gunicorn。&lt;/li&gt;
&lt;li&gt;Gunicorn 会启动若干个 Worker 处理请求，所以 Gunicorn 会再转发给 Worker。&lt;/li&gt;
&lt;li&gt;Worker 就是最终的 Python Web App&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;错误-413-的解决&#34;&gt;错误 413 的解决&lt;/h3&gt;
&lt;p&gt;首先碰到的是 413 Request Entity Too Large 错误，在上传过程中连接被中断（基本上每次都是相同的上传百分比被中断），请求返回 413，首先考虑到 Nginx 对于请求体的大小有限制，查看 Nginx 文档，发现 client_max_body_size 参数控制请求体的大小，默认的设置是 1mb。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;client_max_body_size:&lt;/strong&gt; Sets the maximum allowed size of the client request body, specified in the “Content-Length” request header field. If the size in a request exceeds the configured value, the 413 (Request Entity Too Large) error is returned to the client. Please be aware that browsers cannot correctly display this error. Setting size to 0 disables checking of client request body size.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Python 日志库 logging 的理解和实践经验</title>
      <link>https://simpleapples.com/zh/posts/practice-on-python-logging/</link>
      <pubDate>Fri, 25 Jan 2019 15:18:16 +0000</pubDate>
      <guid>https://simpleapples.com/zh/posts/practice-on-python-logging/</guid>
      <description>&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://simpleapples.com/images/20190125_01.jpg&#34;&gt;&lt;/p&gt;
&lt;p&gt;本文从 Python logging 库的基础概念入手，理解 logging 库的执行流程，以及可能忽视的一些细节。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h3 id=&#34;日志级别&#34;&gt;日志级别&lt;/h3&gt;
&lt;p&gt;logging 库预置了 5 个错误级别，还有一个 &lt;code&gt;NOTSET&lt;/code&gt; 级别，作为 logger 的默认值。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;CRITICAL &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;50&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;ERROR &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;40&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;WARNING &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;30&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;INFO &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;20&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;DEBUG &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;NOTSET &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;logging 库也支持自定义错误级别，通过上面的源码可以看到，在不同级别的错误中间预留了 10 个数字的位置，方便我们在预置错误级别的基础上添加更细致的错误级别。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; logging
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;logging&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;addLevelName(&lt;span style=&#34;color:#ae81ff&#34;&gt;31&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;SERIOUS WARNING&amp;#39;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;logger &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; logging&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;getLogger(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;log&amp;#39;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;logger&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;warn(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;warn info&amp;#39;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;logger&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;log(logging&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;getLevelName(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;SERIOUS_WARNING&amp;#39;&lt;/span&gt;), &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;serious warn&amp;#39;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;例如添加一个 SERIOUS WARNING 类型的错误，值为 31，就可以用 log 方法输出该级别的错误。&lt;/p&gt;
&lt;p&gt;也可以覆盖 logging 预置的错误级别，例如将 WARNING 修改为 SERIOUS WARNING。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;logging&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;addLevelName(&lt;span style=&#34;color:#ae81ff&#34;&gt;30&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;SERIOUS WARNING&amp;#39;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;logger &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; logging&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;getLogger(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;log&amp;#39;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;print(logging&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;getLevelName(&lt;span style=&#34;color:#ae81ff&#34;&gt;30&lt;/span&gt;))  &lt;span style=&#34;color:#75715e&#34;&gt;# SERIOUS WARNING&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;logrecordformatter&#34;&gt;LogRecord、Formatter&lt;/h3&gt;
&lt;p&gt;logging 库中的每一条 log 都以 LogRecord 的形式存在，当调用 logger 打印 log 时候，都会有一条 LogRecord 被自动创建出来，LogRecord 中包含了大量的和该条日志相关的属性，也包含用户传入的 message。&lt;/p&gt;</description>
    </item>
    <item>
      <title>go json 实践中遇到的坑</title>
      <link>https://simpleapples.com/zh/posts/practice-in-json-with-go/</link>
      <pubDate>Mon, 24 Dec 2018 10:43:00 +0000</pubDate>
      <guid>https://simpleapples.com/zh/posts/practice-in-json-with-go/</guid>
      <description>&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://simpleapples.com/images/20181224_01.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;在使用 go 语言开发过程中，经常需要使用到 json 包来进行 json 和 struct 的互相转换，在使用过程中，遇到了一些需要额外注意的地方，记录如下。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h3 id=&#34;整数变浮点数问题&#34;&gt;整数变浮点数问题&lt;/h3&gt;
&lt;p&gt;假设有一个 Person 结构，其中包含 Age int64 和 Weight float64 两个字段，现在通过 json 包将 Person 结构转为 map[string]interface{}，代码如下。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Person&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;Name&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;Age&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int64&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;Weight&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;float64&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;person&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Person&lt;/span&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;Name&lt;/span&gt;: &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Wang Wu&amp;#34;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;Age&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;30&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;Weight&lt;/span&gt;: &lt;span style=&#34;color:#ae81ff&#34;&gt;150.07&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;jsonBytes&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;_&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;json&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Marshal&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;person&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Println&lt;/span&gt;(string(&lt;span style=&#34;color:#a6e22e&#34;&gt;jsonBytes&lt;/span&gt;))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;personFromJSON&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;interface&lt;/span&gt;{}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;json&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Unmarshal&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;jsonBytes&lt;/span&gt;, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;personFromJSON&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;r&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;personFromJSON&lt;/span&gt;.(&lt;span style=&#34;color:#66d9ef&#34;&gt;map&lt;/span&gt;[&lt;span style=&#34;color:#66d9ef&#34;&gt;string&lt;/span&gt;]&lt;span style=&#34;color:#66d9ef&#34;&gt;interface&lt;/span&gt;{})
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;代码执行到这里看上去一切正常，但是打印一下 map[string]interface{} 就会发现不太对了。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Println&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;reflect&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;TypeOf&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;r&lt;/span&gt;[&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Age&amp;#34;&lt;/span&gt;]).&lt;span style=&#34;color:#a6e22e&#34;&gt;Name&lt;/span&gt;())  &lt;span style=&#34;color:#75715e&#34;&gt;// float64&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;fmt&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Println&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;reflect&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;TypeOf&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;r&lt;/span&gt;[&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Weight&amp;#34;&lt;/span&gt;]).&lt;span style=&#34;color:#a6e22e&#34;&gt;Name&lt;/span&gt;())  &lt;span style=&#34;color:#75715e&#34;&gt;// float64&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;转换成 map[string]interface{} 之后，原先的 uint64 和 float64 类型都被转换成了 float64 类型，这显然是不符合我们的预期的。&lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://simpleapples.com/images/20181224_02.png&#34;&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>基于 JWT &#43; Refresh Token 的用户认证实践</title>
      <link>https://simpleapples.com/zh/posts/combining-jwt-with-refresh-token/</link>
      <pubDate>Thu, 13 Dec 2018 13:07:00 +0000</pubDate>
      <guid>https://simpleapples.com/zh/posts/combining-jwt-with-refresh-token/</guid>
      <description>&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://simpleapples.com/images/20181213_01.jpg&#34;&gt;&lt;/p&gt;
&lt;p&gt;HTTP 是一个无状态的协议，一次请求结束后，下次在发送服务器就不知道这个请求是谁发来的了（同一个 IP 不代表同一个用户），在 Web 应用中，用户的认证和鉴权是非常重要的一环，实践中有多种可用方案，并且各有千秋。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h3 id=&#34;基于-session-的会话管理&#34;&gt;基于 Session 的会话管理&lt;/h3&gt;
&lt;p&gt;在 Web 应用发展的初期，大部分采用基于 Session 的会话管理方式，逻辑如下。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;客户端使用用户名密码进行认证&lt;/li&gt;
&lt;li&gt;服务端生成并存储 Session，将 SessionID 通过 Cookie 返回给客户端&lt;/li&gt;
&lt;li&gt;客户端访问需要认证的接口时在 Cookie 中携带 SessionID&lt;/li&gt;
&lt;li&gt;服务端通过 SessionID 查找 Session 并进行鉴权，返回给客户端需要的数据&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://simpleapples.com/images/20181213_02.jpg&#34;&gt;&lt;/p&gt;
&lt;p&gt;基于 Session 的方式存在多种问题。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;服务端需要存储 Session，并且由于 Session 需要经常快速查找，通常存储在内存或内存数据库中，同时在线用户较多时需要占用大量的服务器资源。&lt;/li&gt;
&lt;li&gt;当需要扩展时，创建 Session 的服务器可能不是验证 Session 的服务器，所以还需要将所有 Session 单独存储并共享。&lt;/li&gt;
&lt;li&gt;由于客户端使用 Cookie 存储 SessionID，在跨域场景下需要进行兼容性处理，同时这种方式也难以防范 CSRF 攻击。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;基于-token-的会话管理&#34;&gt;基于 Token 的会话管理&lt;/h3&gt;
&lt;p&gt;鉴于基于 Session 的会话管理方式存在上述多个缺点，无状态的基于 Token 的会话管理方式诞生了，所谓无状态，就是服务端不再存储信息，甚至是不再存储 Session，逻辑如下。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;客户端使用用户名密码进行认证&lt;/li&gt;
&lt;li&gt;服务端验证用户名密码，通过后生成 Token 返回给客户端&lt;/li&gt;
&lt;li&gt;客户端保存 Token，访问需要认证的接口时在 URL 参数或 HTTP Header 中加入 Token&lt;/li&gt;
&lt;li&gt;服务端通过解码 Token 进行鉴权，返回给客户端需要的数据&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://simpleapples.com/images/20181213_03.jpg&#34;&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>通过 ngrok 实现 ssh 内网穿透</title>
      <link>https://simpleapples.com/zh/posts/ssh-via-ngrok/</link>
      <pubDate>Mon, 10 Dec 2018 14:42:00 +0000</pubDate>
      <guid>https://simpleapples.com/zh/posts/ssh-via-ngrok/</guid>
      <description>&lt;h3 id=&#34;ngrok&#34;&gt;ngrok&lt;/h3&gt;
&lt;p&gt;用 ssh 访问一台主机，如果和主机在一个局域网中或者主机拥有公网 IP，就可以使用 ssh 命令直接连接主机的 IP 地址，但是大部分公司和家庭内部都是局域网，并不能给局域网内的每一台主机都分配一个公网 IP，这时候就需要进行内网穿透，才能从外部连接到局域网内的主机。&lt;/p&gt;
&lt;p&gt;ngrok 是一个反向代理工具，可以实现将内网的端口暴露到公网，通过 ngrok，也能将 ssh 使用的端口暴露出去，以此实现 ssh 的内网穿透。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h3 id=&#34;注册并下载-ngrok&#34;&gt;注册并下载 ngrok&lt;/h3&gt;
&lt;p&gt;访问 &lt;a href=&#34;https://ngrok.com/&#34;&gt;https://ngrok.com/&lt;/a&gt; 注册 ngrok 账号并下载 ngrok 客户端。&lt;/p&gt;
&lt;h3 id=&#34;查看-ngrok-的-token&#34;&gt;查看 ngrok 的 token&lt;/h3&gt;
&lt;p&gt;访问 &lt;a href=&#34;https://dashboard.ngrok.com/auth&#34;&gt;https://dashboard.ngrok.com/auth&lt;/a&gt; 查看 token 并复制。&lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://simpleapples.com/images/20181210_01.png&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;在内网机器上启动-ngrok&#34;&gt;在内网机器上启动 ngrok&lt;/h3&gt;
&lt;p&gt;连接 ngrok 账号&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;ngrok authtoken 5TqUhMnum6ntDE8Z5HkNb_49F9ffzzcV9V7pKLVdDYc
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;启动 ngrok 并打开 22 端口转发&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;ngrok tcp &lt;span style=&#34;color:#ae81ff&#34;&gt;22&lt;/span&gt; --log&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;stdout &amp;gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;$HOME&lt;span style=&#34;color:#e6db74&#34;&gt;/ngrok.log&amp;#34;&lt;/span&gt; --region ap &amp;amp;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;其中 region 的 ap 代表 ngrok 新加坡节点，访问速度相比美国节点会快一些。访问 &lt;a href=&#34;https://ngrok.com/docs#config-options&#34;&gt;https://ngrok.com/docs#config-options&lt;/a&gt; 可以查看支持的所有区域。&lt;/p&gt;
&lt;p&gt;访问 &lt;code&gt;http://127.0.0.1:4040&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;可以看到一个 tcp 开头的地址，通过访问这个地址，就可以转发到本机的 22 端口上。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Unicode 和 UTF-8</title>
      <link>https://simpleapples.com/zh/posts/unicode-and-utf-8/</link>
      <pubDate>Fri, 07 Dec 2018 15:22:00 +0000</pubDate>
      <guid>https://simpleapples.com/zh/posts/unicode-and-utf-8/</guid>
      <description>&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://simpleapples.com/images/20181207_01.jpg&#34;&gt;&lt;/p&gt;
&lt;p&gt;Unicode 和 UTF-8 的概念是一个非常基础和重要，但是却容易被忽略的问题。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h3 id=&#34;字符集&#34;&gt;字符集&lt;/h3&gt;
&lt;p&gt;在计算机系统中，所有的数据都以二进制存储，所有的运算也以二进制表示，人类语言和符号也需要转化成二进制的形式，才能存储在计算机中，于是需要有一个从人类语言到二进制编码的映射表。这个映射表就叫做字符集。&lt;/p&gt;
&lt;h3 id=&#34;ascii&#34;&gt;ASCII&lt;/h3&gt;
&lt;p&gt;最早的字符集叫 American Standard Code for Information Interchange（美国信息交换标准代码），简称 ASCII，由 American National Standard Institute（美国国家标准协会）制定。在 ASCII 字符集中，字母 &lt;code&gt;A&lt;/code&gt; 对应的字符编码是 &lt;code&gt;65&lt;/code&gt;，转换成二进制是 &lt;code&gt;0100 0001&lt;/code&gt;，由于二进制表示比较长，通常使用十六进制 &lt;code&gt;41&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&#34;gb2312gbk&#34;&gt;GB2312、GBK&lt;/h3&gt;
&lt;p&gt;ASCII 字符集总共规定了 128 种字符规范，但是并没有涵盖西文字母之外的字符，当需要计算机显示存储中文的时候，就需要一种对中文进行编码的字符集，GB 2312 就是解决中文编码的字符集，由国家标准委员会发布。同时考虑到中文语境中往往也需要使用西文字母，GB 2312 也实现了对 ASCII 的向下兼容，原理是西文字母使用和 ASCII 中相同的代码，但是 GB 2312 只涵盖了 6000 多个汉字，还有很多没有包含在其中，所以又出现了 GBK 和 GB 18030，两种字符集都是在 GB 2312 的基础上进行了扩展。&lt;/p&gt;
&lt;h3 id=&#34;unicode&#34;&gt;Unicode&lt;/h3&gt;
&lt;p&gt;可以看到，光是简体中文，就先后出现了至少三种字符集，繁体中文方面也有 BIG5 等字符集，几乎每种语言都需要有一个自己的字符集，每个字符集使用了自己的编码规则，往往互不兼容。同一个字符在不同字符集下的字符代码不同，这使得跨语言交流的过程中双方必须要使用相同的字符编码才能不出现乱码的情况。为了解决传统字符编码的局限性，Unicode 诞生了，Unicoide 的全称是 Universal Multiple-Octet Coded Character Set（通用多八位字符集，简称 UCS）。Unicode 在一个字符集中包含了世界上所有文字和符号，统一编码，来终结不同编码产生乱码的问题。&lt;/p&gt;
&lt;h3 id=&#34;字符编码-utf-8&#34;&gt;字符编码 UTF-8&lt;/h3&gt;
&lt;p&gt;Unicode 统一了所有字符的编码，是一个 Character Set，也就是字符集，字符集只是给所有的字符一个唯一编号，但是却没有规定如何存储，一个编号为 &lt;code&gt;65&lt;/code&gt; 的字符，只需要一个字节就可以存下，但是编号 &lt;code&gt;40657&lt;/code&gt; 的字符需要两个字节的空间才可以装下，而更靠后的字符可能会需要三个甚至四个字节的空间。&lt;/p&gt;</description>
    </item>
    <item>
      <title>理解Golang的Time结构</title>
      <link>https://simpleapples.com/zh/posts/understand-time-struct-in-go/</link>
      <pubDate>Fri, 26 Oct 2018 17:58:00 +0000</pubDate>
      <guid>https://simpleapples.com/zh/posts/understand-time-struct-in-go/</guid>
      <description>&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://simpleapples.com/images/20181026_01.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;在 golang 中创建并打印一个时间对象，会看到如下输出&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;2018-10-26 14:15:50.306558969 +0800 CST m=+0.000401093
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;前面表示的意义好理解，分别是年月日和时间时区，最后的 m=+xxxx 这部分代表什么呢？&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h3 id=&#34;monotonic-clocks-和-wall-clocks&#34;&gt;Monotonic Clocks 和 Wall Clocks&lt;/h3&gt;
&lt;p&gt;根据 golang 的 time 包的文档可以知道，golang 的 time 结构中存储了两种时钟，一种是 Wall Clocks，一种是 Monotonic Clocks。&lt;/p&gt;
&lt;p&gt;Wall Clocks，顾名思义，表示墙上挂的钟，在这里表示我们平时理解的时间，存储的形式是自 1970 年 1 月 1 日 0 时 0 分 0 秒以来的时间戳，当系统和授时服务器进行校准时间时间操作时，有可能造成这一秒是 2018-1-1 00:00:00，而下一秒变成了 2017-12-31 23:59:59 的情况。Monotonic Clocks，意思是单调时间的，所谓单调，就是只会不停的往前增长，不受校时操作的影响，这个时间是自进程启动以来的秒数。&lt;/p&gt;
&lt;p&gt;如果每隔一秒生成一个 Time 并打印出来，就会看到如下输出。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;2018-10-26 14:15:50.306558969 +0800 CST m=+0.000401093
2018-10-26 14:15:51.310559881 +0800 CST m=+1.004425285
2018-10-26 14:15:52.311822486 +0800 CST m=+2.005711106
2018-10-26 14:15:53.314599457 +0800 CST m=+3.008511329
2018-10-26 14:15:54.31882248 +0800 CST m=+4.012757636
2018-10-26 14:15:55.320059921 +0800 CST m=+5.014018292
2018-10-26 14:15:56.323814998 +0800 CST m=+6.017796644
2018-10-26 14:15:57.324858749 +0800 CST m=+7.018863606
2018-10-26 14:15:58.325164174 +0800 CST m=+8.019192224
2018-10-26 14:15:59.329058535 +0800 CST m=+9.023109863
2018-10-26 14:16:00.329591268 +0800 CST m=+10.023665796
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以看到 m=+后面所显示的数字，就是文档中所说的 Monotonic Clocks。&lt;/p&gt;</description>
    </item>
    <item>
      <title>翻译 | 更快的Python（二）</title>
      <link>https://simpleapples.com/zh/posts/faster-python-part-2/</link>
      <pubDate>Thu, 25 Oct 2018 18:20:00 +0000</pubDate>
      <guid>https://simpleapples.com/zh/posts/faster-python-part-2/</guid>
      <description>&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://simpleapples.com/images/20181025_11.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;更快的 Python（&lt;a href=&#34;http://pythonfasterway.org&#34;&gt;Python Faster Way&lt;/a&gt;）使用代码示例来说明如何书写 Python 代码能带来更高的性能。本文对代码进行了讲解，从性能和可读性等角度来选择出最适合的写法。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h3 id=&#34;例子-11字符串连接&#34;&gt;例子 11：字符串连接&lt;/h3&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://simpleapples.com/images/20181025_01.png&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最差/最优时间比：&lt;strong&gt;1.15&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;使用建议：一次性连接多个（3 个以上）的字符串的时候，使用 join，其他情况使用加号或 f-string。&lt;/li&gt;
&lt;li&gt;说明：又是一个字符串连接的问题，不过这个例子举的不好，join 适用的场景是一次连接多个字符串，会比加号连接多个字符串要快很多（加号相当于一个一个连接）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;例子-12数字的格式化&#34;&gt;例子 12：数字的格式化&lt;/h3&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://simpleapples.com/images/20181025_02.png&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最差/最优时间比：&lt;strong&gt;1.29&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;使用建议：需要复杂格式，推荐使用 format 方法；将数字转换为字符串，直接使用 str 方法。&lt;/li&gt;
&lt;li&gt;说明：将数字转为字符串，使用 str 方法要快于 format 方法，因为 format 方法支持在转换过程中增加规则，例如将数字转为货币形式（每三位加一个逗号分隔符）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;例子-13获取内置列表类型的长度&#34;&gt;例子 13：获取内置列表类型的长度&lt;/h3&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://simpleapples.com/images/20181025_03.png&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最差/最优时间比：&lt;strong&gt;1.20&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;使用建议：使用 len()方法。&lt;/li&gt;
&lt;li&gt;说明：当调用 len()方法时，系统实际上是调用了对象内置的&lt;strong&gt;len&lt;/strong&gt;方法，从这个层面理解，直接调用&lt;strong&gt;len&lt;/strong&gt;应该比 len()方法更快。但是当 len()内置的列表方法时，Python 解释器做了优化，直接返回了列表对象中存储长度信息的变量，并不会调用&lt;strong&gt;len&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;例子-14整数类型的运算&#34;&gt;例子 14：整数类型的运算&lt;/h3&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://simpleapples.com/images/20181025_04.png&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最差/最优时间比：&lt;strong&gt;2.63&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;使用建议：不要直接调用&lt;strong&gt;add&lt;/strong&gt;等魔术方法。&lt;/li&gt;
&lt;li&gt;说明：对于整数类型，调用魔术方法完成运算的速度远远慢于直接使用运算符，使用运算符时，Python 解释器直接调用 C 实现的 operaotr 包中的运算方法，所以速度很快；而使用调用魔术方法，在 Python 层面多出了调用&lt;strong&gt;add&lt;/strong&gt;等魔术方法的额外操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;例子-15自定义类型的运算符重载&#34;&gt;例子 15：自定义类型的运算符重载&lt;/h3&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://simpleapples.com/images/20181025_05.png&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最差/最优时间比：&lt;strong&gt;1.06&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;使用建议：不要直接调用&lt;strong&gt;add&lt;/strong&gt;等魔术方法。&lt;/li&gt;
&lt;li&gt;说明：对于重载了运算符的对象，没有对应的 C 实现运算方法，所以直接直接调用魔术方法速度会更快。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;例子-16对-range-结果求和&#34;&gt;例子 16：对 range 结果求和&lt;/h3&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://simpleapples.com/images/20181025_06.png&#34;&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Go的栈空间管理</title>
      <link>https://simpleapples.com/zh/posts/stacks-in-go/</link>
      <pubDate>Thu, 11 Oct 2018 18:41:00 +0000</pubDate>
      <guid>https://simpleapples.com/zh/posts/stacks-in-go/</guid>
      <description>&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://simpleapples.com/images/20181011_01.jpg&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;栈空间管理的基本逻辑&#34;&gt;栈空间管理的基本逻辑&lt;/h3&gt;
&lt;p&gt;go 语言通过 goroutine 提供了并发编程支持，goroutine 是 go 运行库的功能，而不是操作系统线程实现的，goroutine 可以被理解成一个用户态的线程。&lt;/p&gt;
&lt;p&gt;既然 goroutine 是由 go 运行库管理的，那么 go 运行库也需要为每个 goroutine 创建并管理相应的栈空间，为每个 goroutine 分配的栈空间不能太大，goroutine 开多时会浪费大量空间，也不能太小，会导致栈溢出。go 语言选择栈的栈空间管理的方式是，一开始给一个比较小的空间，随着需要自动增长。当 goroutine 不需要那么大的空间时，栈空间也要自动缩小。&lt;/p&gt;
&lt;h3 id=&#34;分段栈-segment-stacks&#34;&gt;分段栈 Segment Stacks&lt;/h3&gt;
&lt;p&gt;在 go 1.3 之前，go 使用分段栈。&lt;/p&gt;
&lt;p&gt;分段栈实现了一种不连续但是可以持续增长的栈，开始时，栈只有一个段，当需要更多的栈空间时，会分配一个新的段，和上一个栈双向链接。这样，一个栈就是由多个双向链接的段所组成的。当新分配的段使用完毕后，新段会被释放掉。&lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://simpleapples.com/images/20181011_02.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;分段栈实现了栈的按需收缩，在增加新分段时也不需要对原有分段中的数据进行拷贝，使得 goroutine 的使用代价非常低廉。&lt;/p&gt;
&lt;p&gt;分段栈的好处是可以按需增长，空间利用率比较高，然而分段栈在某些情况下也存在一定的瑕疵。当一个段即将用尽，这时使用 for 循环执行一个比较耗空间的函数，会导致函数执行时 goroutine 进行段的分配，而执行完成返回时，进行段的销毁，这样就会导致在循环中出现多次栈的扩容和收缩，造成很大的性能损失，这种情况被称作栈分裂（Stack Split）。&lt;/p&gt;
&lt;h3 id=&#34;连续栈-contiguous-stacks&#34;&gt;连续栈 Contiguous Stacks&lt;/h3&gt;
&lt;p&gt;go 1.3 推出了连续栈，连续栈使用了另外一种策略，不再把栈分成一段一段的，当栈空间不够时，直接 new 一个 2 倍大的栈空间，并将原先栈空间中的数据拷贝到新的栈空间中，而后销毁旧栈。这样当出现栈空间触及边界时，不会产生栈分裂的情况。&lt;/p&gt;
&lt;p&gt;继续假设当前栈空间即将用尽，并且需要在 for 循环中执行一个比较消耗空间的函数。当该函数执行时，栈空间发生了扩容，变成原先 2 倍大小，函数执行完成一次后，栈空间的使用量缩小回执行前的大小，但是栈空间的使用量并没有小于栈大小的 1/4，不会触发栈收缩，所以在整个 for 循环执行过程中，不会反复触发栈空间的收缩扩容。&lt;/p&gt;
&lt;h3 id=&#34;总结&#34;&gt;总结&lt;/h3&gt;
&lt;p&gt;相比于分段栈，连续栈避免了某些场景下栈空间的的频繁伸缩。有一点需要注意的是，连续栈的收缩也是需要重新申请一段空间（原先的 1/2 大小），并进行栈拷贝操作的。&lt;/p&gt;</description>
    </item>
    <item>
      <title>翻译 | 更快的Python（一）</title>
      <link>https://simpleapples.com/zh/posts/faster-python-part-1/</link>
      <pubDate>Mon, 08 Oct 2018 18:15:00 +0000</pubDate>
      <guid>https://simpleapples.com/zh/posts/faster-python-part-1/</guid>
      <description>&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://simpleapples.com/images/20181008_11.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;更快的 Python（&lt;a href=&#34;http://pythonfasterway.org&#34;&gt;Python Faster Way&lt;/a&gt;）使用代码示例来说明如何书写 Python 代码能带来更高的性能。本文对代码进行了讲解，从性能和可读性等角度来选择出最适合的写法。&lt;/p&gt;
&lt;h3 id=&#34;例子-1字符串格式化&#34;&gt;例子 1：字符串格式化&lt;/h3&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://simpleapples.com/images/20181008_01.png&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最差/最优时间比：&lt;strong&gt;1.95&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;使用建议：Python 3.7 或以上推荐使用 f-string，其他版本推荐使用 format 方法。&lt;/li&gt;
&lt;li&gt;说明：字符串格式化是代码中最常遇到的情况，虽然在连接少量字符串的情景中，使用+号的性能最优，但是使用+号的代码可读性最差。如果使用 Python 3.7 或优以上版本，可以使用 f-string 来解决这个问题，f-string 的性能比 format 方法和%操作符的性能都要高，可读性也比+号好。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;例子-2字典的初始化&#34;&gt;例子 2：字典的初始化&lt;/h3&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://simpleapples.com/images/20181008_02.png&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最差/最优时间比：&lt;strong&gt;1.83&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;使用建议：使用字面量初始化字典（以及其他集合类型）。&lt;/li&gt;
&lt;li&gt;说明：Python 中初始化集合类型时使用字面量的方式，解释器会直接调用 BUILD_MAP 等字节码来创建，如果用构造函数的方式来创建，则需要先查询构造方法，再执行构造方法。使用字面量初始化，Python 代码也更简洁。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;例子-3内置排序方法&#34;&gt;例子 3：内置排序方法&lt;/h3&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://simpleapples.com/images/20181008_03.png&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最差/最优时间比：&lt;strong&gt;1.26&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;使用建议：根据是否需要修改原始值来决定使用哪个方法。&lt;/li&gt;
&lt;li&gt;说明：sorted 和 list.sort 方法是 Python 中内置的排序方法，sorted 方法不会修改原始值，list.sort 方法在原始值上直接排序，会修改原始值。比较这两个方法的性能差异，意义不大。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;例子-4初始化多个变量&#34;&gt;例子 4：初始化多个变量&lt;/h3&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://simpleapples.com/images/20181008_04.png&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最差/最优时间比：&lt;strong&gt;1.01&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;使用建议：推荐使用第二种。&lt;/li&gt;
&lt;li&gt;说明：从字节码中可以看出两种方式出了执行顺序之外，基本一致，所以性能上也非常接近。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;例子-5多个变量的比较&#34;&gt;例子 5：多个变量的比较&lt;/h3&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://simpleapples.com/images/20181008_05.png&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最差/最优时间比：&lt;strong&gt;1.11&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;使用建议：推荐使用第二种。&lt;/li&gt;
&lt;li&gt;说明：使用第一种方法能带来一定的性能提升，但是提升有限，在实际情况中也很少出现多个变量连续比较大小的情况，并且第一种方法非常不 Pythonic，所以推荐使用第二种。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;例子-6if-true-的条件判断&#34;&gt;例子 6：if true 的条件判断&lt;/h3&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://simpleapples.com/images/20181008_06.png&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最差/最优时间比：&lt;strong&gt;1.17&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;使用建议：推荐使用第一种。&lt;/li&gt;
&lt;li&gt;说明：从字节码上看，第一种方法的性能最高，并且语法上也更加简洁。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;例子-7if-false-的条件判断&#34;&gt;例子 7：if false 的条件判断&lt;/h3&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://simpleapples.com/images/20181008_07.png&#34;&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Go语言中defer的一些坑</title>
      <link>https://simpleapples.com/zh/posts/how-to-use-defer-in-go/</link>
      <pubDate>Fri, 14 Sep 2018 13:31:00 +0000</pubDate>
      <guid>https://simpleapples.com/zh/posts/how-to-use-defer-in-go/</guid>
      <description>&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://simpleapples.com/images/20180914_01.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;defer 语句是 Go 中一个非常有用的特性，可以将一个方法延迟到包裹该方法的方法返回时执行，在实际应用中，defer 语句可以充当其他语言中 try…catch…的角色，也可以用来处理关闭文件句柄等收尾操作。&lt;/p&gt;
&lt;h3 id=&#34;defer-触发时机&#34;&gt;defer 触发时机&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;A &amp;ldquo;defer&amp;rdquo; statement invokes a function whose execution is deferred to the moment the surrounding function returns, either because the surrounding function executed a return statement, reached the end of its function body, or because the corresponding goroutine is panicking.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;Go 官方文档中对 defer 的执行时机做了阐述，分别是。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;包裹 defer 的函数返回时&lt;/li&gt;
&lt;li&gt;包裹 defer 的函数执行到末尾时&lt;/li&gt;
&lt;li&gt;所在的 goroutine 发生 panic 时&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;defer-执行顺序&#34;&gt;defer 执行顺序&lt;/h3&gt;
&lt;p&gt;当一个方法中有多个 defer 时， defer 会将要延迟执行的方法“压栈”，当 defer 被触发时，将所有“压栈”的方法“出栈”并执行。所以 defer 的执行顺序是 LIFO 的。&lt;/p&gt;</description>
    </item>
    <item>
      <title>用Python写算法 | 蓄水池算法实现随机抽样</title>
      <link>https://simpleapples.com/zh/posts/implementation-of-reservoir-sample-in-python/</link>
      <pubDate>Sun, 05 Aug 2018 00:02:00 +0000</pubDate>
      <guid>https://simpleapples.com/zh/posts/implementation-of-reservoir-sample-in-python/</guid>
      <description>&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://simpleapples.com/images/20180805_01.jpg&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;现在有一组数，不知道这组数的总量有多少，请描述一种算法能够在这组数据中随机抽取 k 个数，使得每个数被取出来的概率相等。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;如果这组数有 n 个，那么每个数字取到的概率就是 k/n，但是这个问题的难点在于不知道这组数的总数，也就是不知道 n，那么该怎么计算每个数取到的概率呢？&lt;/p&gt;
&lt;h1 id=&#34;蓄水池算法&#34;&gt;蓄水池算法&lt;/h1&gt;
&lt;p&gt;游泳池（蓄水池）大家都不陌生，有些游泳池中的水是活的，有入水管也有出水管，那么和泳池体积相当的水流过之后，是不是泳池中所有的水都会被替换呢？当然不是，有的水在泳池中可能会存留很久，有的可能刚进去就流走了。仿照这种现象，蓄水池抽样算法诞生了，蓄水池算法的关键在于保证流入蓄水池的水和已经在池中的水以相同的概率留存在蓄水池中。并且蓄水池算法可以在不预先知道总量的情况下，在时间复杂度 O(N)的情况下，来解决这类采样问题。&lt;/p&gt;
&lt;h1 id=&#34;核心原理&#34;&gt;核心原理&lt;/h1&gt;
&lt;p&gt;这一部分涉及公式，为了保证效果直接贴了图过来。&lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://simpleapples.com/images/20180805_02.jpg&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;python-实现&#34;&gt;Python 实现&lt;/h1&gt;
&lt;p&gt;接下来尝试用 Python 实现一下蓄水池算法，由于蓄水池算法是在事先不知道总量的情况下抽样的，所以定义一个方法来接收单个元素，并且把这个方法放在类中，以持有采样后的数据。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; random
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ReservoirSample&lt;/span&gt;(object):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;__init__&lt;/span&gt;(self, size):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;_size &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; size
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;_counter &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;_sample &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; []
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;feed&lt;/span&gt;(self, item):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;_counter &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;# 第i个元素（i &amp;lt;= k），直接进入池中&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; len(self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;_sample) &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;_size:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;_sample&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;append(item)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;_sample
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;# 第i个元素（i &amp;gt; k），以k / i的概率进入池中&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        rand_int &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; random&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;randint(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;_counter)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; rand_int &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;_size:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;_sample[rand_int &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; item
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;_sample
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h1 id=&#34;测试代码&#34;&gt;测试代码&lt;/h1&gt;
&lt;p&gt;接下来实现一个测试用例验证实现的算法是否正确，既然是随机抽样，无法通过单词测试来验证是否正确，所以通过多次执行的方式来验证，比如从 1-10 里随机取样 3 个数，然后执行 10000 次取样，如果算法正确，最后结果中 1-10 被取样的次数应该是相同的，都是 3000 上下。&lt;/p&gt;</description>
    </item>
    <item>
      <title>使用gofmt格式化代码</title>
      <link>https://simpleapples.com/zh/posts/gofmt-formating-your-code/</link>
      <pubDate>Tue, 17 Jul 2018 14:13:00 +0000</pubDate>
      <guid>https://simpleapples.com/zh/posts/gofmt-formating-your-code/</guid>
      <description>&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://simpleapples.com/images/20180717_01.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;对于一门编程语言来说，代码格式化是最容易引起争议的一个问题，不同的开发者可能会有不同的编码风格和习惯，但是如果所有开发者都能使用同一种格式来编写代码，开发者就可以将宝贵的时间专注在语言要解决的问题上。&lt;/p&gt;
&lt;h1 id=&#34;gofmt-介绍&#34;&gt;gofmt 介绍&lt;/h1&gt;
&lt;p&gt;Golang 的开发团队制定了统一的官方代码风格，并且推出了 gofmt 工具（gofmt 或 go fmt）来帮助开发者格式化他们的代码到统一的风格。gofmt 是一个 cli 程序，会优先读取标准输入，如果传入了文件路径的话，会格式化这个文件，如果传入一个目录，会格式化目录中所有.go 文件，如果不传参数，会格式化当前目录下的所有.go 文件。&lt;/p&gt;
&lt;p&gt;gofmt 默认不对代码进行简化，使用-s 参数可以开启简化代码功能，具体来说会进行如下的转换：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;去除数组、切片、Map 初始化时不必要的类型声明：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;如下形式的切片表达式&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    []&lt;span style=&#34;color:#a6e22e&#34;&gt;T&lt;/span&gt;{&lt;span style=&#34;color:#a6e22e&#34;&gt;T&lt;/span&gt;{}, &lt;span style=&#34;color:#a6e22e&#34;&gt;T&lt;/span&gt;{}}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;将被简化为&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    []&lt;span style=&#34;color:#a6e22e&#34;&gt;T&lt;/span&gt;{{}, {}}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;去除数组切片操作时不必要的索引指定&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;如下形式的切片表达式&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt;[&lt;span style=&#34;color:#a6e22e&#34;&gt;a&lt;/span&gt;:len(&lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt;)]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;将被简化为&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;s&lt;/span&gt;[&lt;span style=&#34;color:#a6e22e&#34;&gt;a&lt;/span&gt;:]
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;去除迭代时非必要的变量赋值&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;如下形式的迭代&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;x&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;_&lt;/span&gt; = &lt;span style=&#34;color:#66d9ef&#34;&gt;range&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;v&lt;/span&gt; {&lt;span style=&#34;color:#f92672&#34;&gt;...&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;将被简化为&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;x&lt;/span&gt; = &lt;span style=&#34;color:#66d9ef&#34;&gt;range&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;v&lt;/span&gt; {&lt;span style=&#34;color:#f92672&#34;&gt;...&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;如下形式的迭代&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;_&lt;/span&gt; = &lt;span style=&#34;color:#66d9ef&#34;&gt;range&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;v&lt;/span&gt; {&lt;span style=&#34;color:#f92672&#34;&gt;...&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;将被简化为&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;：&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;range&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;v&lt;/span&gt; {&lt;span style=&#34;color:#f92672&#34;&gt;...&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;gofmt 命令参数列表如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;usage: gofmt &lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;flags&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;path ...&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  -cpuprofile string
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        write cpu profile to this file
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  -d    display diffs instead of rewriting files
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  -e    report all errors &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;not just the first &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt; on different lines&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  -l    list files whose formatting differs from gofmt&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;s
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;  -r string
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;        rewrite rule (e.g., &amp;#39;&lt;/span&gt;a&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;b:len&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;a&lt;span style=&#34;color:#f92672&#34;&gt;)]&lt;/span&gt; -&amp;gt; a&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;b:&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  -s    simplify code
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;  -w    write result to &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;source&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt; file instead of stdout
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;可以看到，gofmt 命令还支持自定义的重写规则，使用-r 参数，按照 pattern -&amp;gt; replacement 的格式传入规则。&lt;/p&gt;</description>
    </item>
    <item>
      <title>搭建Kubernetes集群时DNS无法解析问题的处理过程</title>
      <link>https://simpleapples.com/zh/posts/solving-kubernetes-dns-problem/</link>
      <pubDate>Sun, 15 Jul 2018 00:00:00 +0000</pubDate>
      <guid>https://simpleapples.com/zh/posts/solving-kubernetes-dns-problem/</guid>
      <description>&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://simpleapples.com/images/20180715_01.jpg&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;问题描述&#34;&gt;问题描述&lt;/h1&gt;
&lt;p&gt;在搭建 Kubernetes 集群过程中，安装了 kube-dns 插件后，运行一个 ubuntu 容器，发现容器内无法解析集群外域名，一开始可以解析集群内域名，一段时间后也无法解析集群内域名。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;$ nslookup kubernetes.default
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Server:    10.99.0.2
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Address 1: 10.99.0.2 kube-dns.kube-system.svc.cluster.local
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;nslookup: can&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;t resolve &amp;#39;&lt;/span&gt;kubernetes.default&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h1 id=&#34;排查过程&#34;&gt;排查过程&lt;/h1&gt;
&lt;p&gt;在排查问题前，先思考一下 Kubernetes 集群中的 DNS 解析过程，在安装好 kube-dns 的集群中，普通 Pod 的 dnsPolicy 属性是默认值 ClusterFirst，也就是会指向集群内部的 DNS 服务器，kube-dns 负责解析集群内部的域名，kube-dns Pod 的 dnsPolicy 值是 Default，意思是从所在 Node 继承 DNS 服务器，对于无法解析的外部域名，kube-dns 会继续向集群外部的 dns 进行查询，过程如图。&lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://simpleapples.com/images/20180715_02.jpg&#34;&gt;&lt;/p&gt;
&lt;p&gt;Ubuntu 容器是一个普通的 Pod，在 Linux 系统中，/etc/resolv.conf 是存储 DNS 服务器的文件，普通 Pod 的/etc/resolv.conf 文件应该存储的是 kube-dns 的 Service IP。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;nameserver 10.99.0.2  &lt;span style=&#34;color:#75715e&#34;&gt;# 这里存储的是kube-dns的Service IP&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;search default.svc.cluster.local. svc.cluster.local. cluster.local.
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;options ndots:5
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;查看后发现/etc/resolv.conf 文件中存储的是 kube-dns 的 Service IP，证明这一步没有问题，接下来查看一下 kube-dns 的 Pod，先进入 kube-dns 的 Pod 中检查一下/etc/resolv.conf 文件，这里存储的应该是集群外部的 DNS 服务器地址，查看后发现，这里存储的地址是 127.0.0.53，进一步查看 kube-dns Pod 的 log，发现出现了非常多的 i/o timeout 错误。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Golang环境安装和依赖管理</title>
      <link>https://simpleapples.com/zh/posts/build-golang-environment/</link>
      <pubDate>Tue, 10 Jul 2018 21:45:00 +0000</pubDate>
      <guid>https://simpleapples.com/zh/posts/build-golang-environment/</guid>
      <description>&lt;p&gt;2015 年，Go 1.5 加入了一个试验性的 vendor 机制（到 2016 年的 Go 1.6 版变为默认开启），vendor 机制就是在项目中加入了 vendor 文件夹，用于存放依赖，这样就可以将不同项目的依赖隔离开。
&lt;img loading=&#34;lazy&#34; src=&#34;https://simpleapples.com/images/20180710_02.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;Golang 一种静态强类型、编译型、并发型，并具有垃圾回收功能的编程语言。Golang 提供了方便的安装包，支持 Windows、Linux、Mac 系统。&lt;/p&gt;
&lt;h1 id=&#34;下载安装包&#34;&gt;下载安装包&lt;/h1&gt;
&lt;p&gt;Golang 的官网是&lt;a href=&#34;https://golang.org/&#34;&gt;https://golang.org/&lt;/a&gt;，如果官网打不开，可以访问&lt;a href=&#34;https://golang.google.cn/&#34;&gt;https://golang.google.cn/&lt;/a&gt;这个域名。在官网点击 Download Go 会进入下载页，可以看到这里提供了针对各个系统的安装包，也提供了源码，可以下载源码编译安装。&lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://simpleapples.com/images/20180710_03.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;下载运行安装包后，在 terminal 中执行 go env 命令，如果出现下面的输出说明已经安装成功。&lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://simpleapples.com/images/20180710_04.png&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;goroot-与-gopath&#34;&gt;GOROOT 与 GOPATH&lt;/h1&gt;
&lt;p&gt;仔细看上面的输出，会发现其中有一个 GOPATH，又有一个 GOROOT，那么到底哪个才是 Golang 的运行环境呢。&lt;/p&gt;
&lt;p&gt;首先访问一下 GOROOT 这个路径，会发现其中包含 bin、lib 等文件夹。GOROOT 就是 Golang 的安装路径，其中包含 Golang 编译、工具、标准库等，在安装后就会存在。&lt;/p&gt;
&lt;p&gt;和 GOROOT 不同，GOPATH 是工作空间路径，从 go 1.8 开始，如果 GOPATH 没有被设置，会有一个默认值，在 Unix 上为$HOME/go，在 Windows 上为%USERPROFILE%/go，当调用 go build 时，它会在 GOPATH 中寻找源码。访问一下 GOPATH 这个路径，会发现其中只有 pkg、bin、src 三个文件夹，并且里面基本是空的，这是一个约定的目录结构，src 文件夹用来存放源码、pkg 存放编译后生成的文件，bin 存放编译后生成的可执行文件。项目代码需要在 GOPATH/src 路径下。&lt;/p&gt;</description>
    </item>
    <item>
      <title>你所不知道的Python | 函数参数的演进之路</title>
      <link>https://simpleapples.com/zh/posts/transition-of-parameters-of-functions-in-python/</link>
      <pubDate>Tue, 10 Jul 2018 10:08:00 +0000</pubDate>
      <guid>https://simpleapples.com/zh/posts/transition-of-parameters-of-functions-in-python/</guid>
      <description>&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://simpleapples.com/images/20180710_01.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;函数参数处理机制是 Python 中一个非常重要的知识点，随着 Python 的演进，参数处理机制的灵活性和丰富性也在不断增加，使得我们不仅可以写出简化的代码，也能处理复杂的调用。&lt;/p&gt;
&lt;h1 id=&#34;关键字参数&#34;&gt;关键字参数&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;调用时指定参数的名称，且与函数声明时的参数名称一致。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;关键字参数是 Python 函数中最基础也最常见的，我们写一个记账的函数，参数是需要记录的时间和金额。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;add_record&lt;/span&gt;(date, amount):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	print(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;date:&amp;#39;&lt;/span&gt;, date, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;amount:&amp;#39;&lt;/span&gt;, amount)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里的 amount 参数就是一个关键字参数，关键字参数支持两种调用方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;位置调用&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;关键字调用&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;位置调用，就是按参数的位置进行调用，例如传入两个参数，第一个是字符串 2018-07-06，第二个是整数 10，那么这两个参数会被分别赋予 date 和 amount 变量，如果顺序反过来，则这两个参数分别赋予 amount 和 date 变量。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;add_record(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;2018-07-06&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;)  &lt;span style=&#34;color:#75715e&#34;&gt;# 输出date: 2018-07-06 amount: 10&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;add_record(&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;2018-07-06&amp;#39;&lt;/span&gt;)  &lt;span style=&#34;color:#75715e&#34;&gt;# 输出date: 10 amount: 2018-07-06&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;关键字调用，可以忽略参数顺序，直接指定参数。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;add_record(amount&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;, date&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;2018-07-06&amp;#39;&lt;/span&gt;)  &lt;span style=&#34;color:#75715e&#34;&gt;# 虽然参数顺序反了，但是使用了关键字调用，所以依然输出date: 2018-07-06 amount: 10&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h1 id=&#34;仅限关键字参数&#34;&gt;仅限关键字参数&lt;/h1&gt;
&lt;p&gt;我们定义一个 Person 类，并实现它的&lt;code&gt;__init__&lt;/code&gt;方法&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Person&lt;/span&gt;(object):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;__init__&lt;/span&gt;(self, name, age,  gender, height, weight):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;_name &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; name
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;_age &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; age
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;_gender &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; gender
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;_height &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; height
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;_weight &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; weight
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;当初始化这个类的时候，我们可以使用关键字调用，也可以使用位置调用。&lt;/p&gt;</description>
    </item>
    <item>
      <title>你所不知道的Python | 字符串连接的秘密</title>
      <link>https://simpleapples.com/zh/posts/the-secret-of-string-concatenation/</link>
      <pubDate>Thu, 28 Jun 2018 23:51:00 +0000</pubDate>
      <guid>https://simpleapples.com/zh/posts/the-secret-of-string-concatenation/</guid>
      <description>&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://simpleapples.com/images/20180628_04.jpg&#34;&gt;&lt;/p&gt;
&lt;p&gt;字符串连接，就是将 2 个或以上的字符串合并成一个，看上去连接字符串是一个非常基础的小问题，但是在 Python 中，我们可以用多种方式实现字符串的连接，稍有不慎就有可能因为选择不当而给程序带来性能损失。&lt;/p&gt;
&lt;h1 id=&#34;方法-1加号连接&#34;&gt;方法 1：加号连接&lt;/h1&gt;
&lt;p&gt;很多语言都支持使用加号连接字符串，Python 也不例外，只需要简单的将 2 个或多个字符串相加就可以完成拼接。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;a &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Python&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;b &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;私房菜&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;r &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; a &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; b  &lt;span style=&#34;color:#75715e&#34;&gt;# 输出&amp;#39;Python私房菜&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h1 id=&#34;方法-2使用操作符&#34;&gt;方法 2：使用%操作符&lt;/h1&gt;
&lt;p&gt;在 Python 2.6 以前，%操作符是唯一一种格式化字符串的方法，它也可以用于连接字符串。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;a &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Python&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;b &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;私房菜&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;r &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;%s%s&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt; (a, b)  &lt;span style=&#34;color:#75715e&#34;&gt;# 输出&amp;#39;Python私房菜&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h1 id=&#34;方法-3使用-format-方法&#34;&gt;方法 3：使用 format 方法&lt;/h1&gt;
&lt;p&gt;format 方法是 Python 2.6 中出现的一种代替%操作符的字符串格式化方法，同样可以用来连接字符串。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;a &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Python&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;b &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;私房菜&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;r &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;{}{}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;format(a, b)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h1 id=&#34;方法-4使用-f-string&#34;&gt;方法 4：使用 f-string&lt;/h1&gt;
&lt;p&gt;Python 3.6 中引入了 Formatted String Literals（字面量格式化字符串），简称 f-string，f-string 是%操作符和 format 方法的进化版，使用 f-string 连接字符串的方法和使用%操作符、format 方法类似。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;a &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Python&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;b &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;私房菜&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;r &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;f&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;{&lt;/span&gt;a&lt;span style=&#34;color:#e6db74&#34;&gt;}{&lt;/span&gt;b&lt;span style=&#34;color:#e6db74&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h1 id=&#34;方法-5使用-strjoin方法&#34;&gt;方法 5：使用 str.join()方法&lt;/h1&gt;
&lt;p&gt;字符串有一个内置方法 join，其参数是一个序列类型，例如数组或者元组等。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;a &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Python&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;b &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;私房菜&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;r &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;join([a, b])
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h1 id=&#34;对比测试&#34;&gt;对比测试&lt;/h1&gt;
&lt;p&gt;既然连接字符串有这么多方法，那么使用时到底选择哪种呢？我们从代码可读性和性能两个层面来评估一下上面 5 种方法。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Ubuntu 18.04 LTS安装KVM虚拟机</title>
      <link>https://simpleapples.com/zh/posts/install-kvm-on-ubuntu-18.04-lts/</link>
      <pubDate>Thu, 28 Jun 2018 17:54:00 +0000</pubDate>
      <guid>https://simpleapples.com/zh/posts/install-kvm-on-ubuntu-18.04-lts/</guid>
      <description>&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://simpleapples.com/images/20180628_01.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;前一阵使用在最新的 Ubuntu 18.04 上安装了 KVM 来虚拟一个小的 VM 集群，将主要过程和其中遇到的一些问题记录下来。&lt;/p&gt;
&lt;h1 id=&#34;准备工作&#34;&gt;准备工作&lt;/h1&gt;
&lt;p&gt;首先需要检查一下 CPU 是否支持虚拟化，执行一下命令来检查/proc/cpuinfo 文件中是否又虚拟化相关的字眼，如果有的话表明 CPU 支持虚拟化技术。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;egrep -c &amp;#39;(svm|vmx)&amp;#39; /proc/cpuinfo
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面命令执行结果如果返回 0，表示 CPU 不支持虚拟化技术。当然主板 BIOS 中的虚拟化技术也可能不是默认开启的，如果没有开启需要手动开启一下。&lt;/p&gt;
&lt;h1 id=&#34;安装-kvm&#34;&gt;安装 KVM&lt;/h1&gt;
&lt;p&gt;执行以下命令安装 KVM&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;sudo apt update
sudo apt install qemu qemu-kvm libvirt-bin  bridge-utils  virt-manager
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;将 libvirtd 添加自启动&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;sudo systemctl start libvirtd.service
sudo systemctl enable libvirtd.service
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;网络模式&#34;&gt;网络模式&lt;/h1&gt;
&lt;p&gt;KVM 安装完成后，首先需要进行网络设定，KVM 支持四种网络模式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;桥接模式&lt;/li&gt;
&lt;li&gt;NAT 模式&lt;/li&gt;
&lt;li&gt;用户网络模式&lt;/li&gt;
&lt;li&gt;直接分配设备模式&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;主要讲一下前两种&lt;/p&gt;
&lt;h1 id=&#34;桥接bridge模式&#34;&gt;桥接（Bridge）模式&lt;/h1&gt;
&lt;p&gt;在桥接模式下，宿主机和虚拟机共享同一个物理网络设备，虚拟机中的网卡和物理机中的网卡是平行关系，所以虚拟机可以直接接入外部网络，虚拟机和宿主机有平级的 IP。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;桥接模式&#34; loading=&#34;lazy&#34; src=&#34;https://simpleapples.com/images/20180628_02.jpg&#34;&gt;&lt;/p&gt;
&lt;p&gt;原本宿主机是通过网卡 eth0 连接外部网络的，网桥模式会新创建一个网桥 br0，接管 eth0 来连接外部网络，然后将宿主机和虚拟机的网卡 eth0 都绑定到网桥上。&lt;/p&gt;</description>
    </item>
    <item>
      <title>大毒瘤！卸载WeGame解决XPS 15蓝屏问题</title>
      <link>https://simpleapples.com/zh/posts/wegame-causing-bsod-on-xps-15-9560/</link>
      <pubDate>Wed, 20 Jun 2018 14:00:00 +0000</pubDate>
      <guid>https://simpleapples.com/zh/posts/wegame-causing-bsod-on-xps-15-9560/</guid>
      <description>&lt;h1 id=&#34;潜伏期&#34;&gt;潜伏期&lt;/h1&gt;
&lt;p&gt;去年 4 月底买了一台美版 XPS 15 9560，用了几个月之后就会偶尔出现蓝屏问题，由于之前就在论坛上看到很多吐槽 XPS 品控的帖子，以为自己也中了枪，好在蓝屏也不频繁，不影响使用也就没管。&lt;/p&gt;
&lt;h1 id=&#34;上升期&#34;&gt;上升期&lt;/h1&gt;
&lt;p&gt;进入今年 5 月，升级了 Win10 1803 后（基本上软件有更新我都会第一时间升级，体验最新的改进），蓝屏的次数开始多了起来，开始变得影响使用，于是开始着手查找问题。&lt;/p&gt;
&lt;p&gt;由于心急，并没有看转储文件，而是直接 Google 了 XPS 15 的蓝屏问题，希望能尽快找到方案。很快发现具有类似问题的人不在少数，也有很大一部分人以此说 XPS 15 品控不好，看了很多内容后，把怀疑的方向放在了驱动层面（Dell 有一个 Dell Update 软件，一有更新提示我就会更新驱动），于是从更新频率最高的显卡驱动入手，降级显卡驱动到上一个版本，然而并没有什么用。于是又降级了 Wifi 驱动，因为 Wifi 驱动也是最近更新的，并且 XPS 15 的 Killer 显卡兼容性似乎没有那么好。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;XPS 15的驱动列表，可以看到Wifi和显卡驱动都是最近发布的&#34; loading=&#34;lazy&#34; src=&#34;https://simpleapples.com/images/20180620_01.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;降级完驱动之后，电脑进入了短暂的回光返照阶段，用了几个小时都没有蓝屏，然而紧接着更加不幸的问题就要发生了。&lt;/p&gt;
&lt;h1 id=&#34;爆发期&#34;&gt;爆发期&lt;/h1&gt;
&lt;p&gt;用 QQ 接收一个大文件，大概 1G，进行到一半的时候忽然蓝屏，重启后重新接收，准备传完之后再解决蓝屏问题，然而不幸的是传了一半又蓝屏了&amp;hellip; 这时我把怀疑的方向转向了硬盘，于是降级了 Intel RST 驱动，心想降级要是没用的话，有可能是 SSD 跪了&amp;hellip; 降级后怀着忐忑的心情再次重试，竟然&amp;hellip;又蓝屏了&amp;hellip;&lt;/p&gt;
&lt;p&gt;这次把怀疑的方向转到了 QQ 或者 Wifi 上，毕竟是一用 QQ 接收大文件就出问题，那么不是 QQ 就是 Wifi 了，于是卸载 QQ，用迅雷下载一个大文件，果不其然，又跪了&amp;hellip;&lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://simpleapples.com/images/20180620_02.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;然而已经降级了 Wifi 驱动，之前也一直没有什么问题，难道真的是硬件出了问题？这个时候，我内心已经有点放弃 PC，转而在京东上看 MBP 的价格了&amp;hellip;&lt;/p&gt;</description>
    </item>
    <item>
      <title>你所不知道的Python | 字符串格式化的演进之路</title>
      <link>https://simpleapples.com/zh/posts/things-you-dont-know-about-python/</link>
      <pubDate>Mon, 11 Jun 2018 11:50:00 +0000</pubDate>
      <guid>https://simpleapples.com/zh/posts/things-you-dont-know-about-python/</guid>
      <description>&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://simpleapples.com/images/20180611_01.jpg&#34;&gt;&lt;/p&gt;
&lt;p&gt;字符串格式化对于每个语言来说都是一个非常基础和常用的功能，学习 Python 的同学大概都知道可以用%语法来格式化字符串。然而为了让我们更方便的使用这个常用功能，语言本身也在对字符串格式化方法进行迭代。&lt;/p&gt;
&lt;h1 id=&#34;python-26-以前操作符&#34;&gt;Python 2.6 以前：%操作符&lt;/h1&gt;
&lt;p&gt;在 Python 2.6 出现之前，字符串迭代只有一种方法，就是%（也是取模）操作符，%操作符支持 unicode 和 str 类型的 Python 字符串，效果和 C 语言中的 sprintf()方法相似，下面是一个使用%格式化字符串的例子：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;print(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;I&amp;#39;m &lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;%s&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;. I&amp;#39;m &lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;%d&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt; year old&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt; (&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Tom&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;27&lt;/span&gt;))
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;%符号前面使用一个字符串作为模板，模板中有标记格式的占位符号，%后面是一个 tuple 或者 dict，用来传递需要格式化的值。占位符控制着显示的格式，下面列表展示了占位符的种类：&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;占位符&lt;/th&gt;
          &lt;th&gt;内容&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;%d&lt;/td&gt;
          &lt;td&gt;十进制整数&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;%i&lt;/td&gt;
          &lt;td&gt;十进制整数&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;%o&lt;/td&gt;
          &lt;td&gt;八进制整数&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;%u&lt;/td&gt;
          &lt;td&gt;无符号整数&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;%x&lt;/td&gt;
          &lt;td&gt;无符号十六进制（小写）&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;%X&lt;/td&gt;
          &lt;td&gt;无符号十六进制（大写）&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;%e&lt;/td&gt;
          &lt;td&gt;浮点型（科学记数法，小写）&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;%E&lt;/td&gt;
          &lt;td&gt;浮点型（科学记数法，大写）&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;%f&lt;/td&gt;
          &lt;td&gt;浮点数&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;%F&lt;/td&gt;
          &lt;td&gt;浮点数&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;%g&lt;/td&gt;
          &lt;td&gt;浮点型，如果小数位数超过 4 位，使用科学记数法表示（小写）&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;%G&lt;/td&gt;
          &lt;td&gt;浮点型，如果小数位数超过 4 位，使用科学记数法表示（大写）&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;%c&lt;/td&gt;
          &lt;td&gt;单个字符&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;%r&lt;/td&gt;
          &lt;td&gt;字符串（调用 repr()方法生成）&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;%s&lt;/td&gt;
          &lt;td&gt;字符串（调用 str()方法生成）&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;除了对数据类型的指定，%操作符还支持更复杂的格式控制：&lt;/p&gt;</description>
    </item>
    <item>
      <title>初学者必备 | Python Cheat Sheet 中文版</title>
      <link>https://simpleapples.com/zh/posts/python-cheat-sheet/</link>
      <pubDate>Thu, 31 May 2018 13:22:00 +0000</pubDate>
      <guid>https://simpleapples.com/zh/posts/python-cheat-sheet/</guid>
      <description>&lt;p&gt;笔者整理了 Python3 中内置方法的速查表，包含：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内置方法&lt;/li&gt;
&lt;li&gt;列表处理方法&lt;/li&gt;
&lt;li&gt;字典处理方法&lt;/li&gt;
&lt;li&gt;元组处理方法&lt;/li&gt;
&lt;li&gt;集合处理方法&lt;/li&gt;
&lt;li&gt;序列类型的切片方法&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;共计 100 多个方法，点击图片——查看原图——下载。&lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://simpleapples.com/images/20180531_01.jpg&#34;&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>简析Python中的四种队列</title>
      <link>https://simpleapples.com/zh/posts/four-types-of-queue-in-python/</link>
      <pubDate>Tue, 22 May 2018 10:25:00 +0000</pubDate>
      <guid>https://simpleapples.com/zh/posts/four-types-of-queue-in-python/</guid>
      <description>&lt;p&gt;队列是一种只允许在一端进行插入操作，而在另一端进行删除操作的线性表。&lt;/p&gt;
&lt;p&gt;在 Python 文档中搜索队列（queue）会发现，Python 标准库中包含了四种队列，分别是 queue.Queue / asyncio.Queue / multiprocessing.Queue / collections.deque。&lt;/p&gt;
&lt;h1 id=&#34;collectionsdeque&#34;&gt;collections.deque&lt;/h1&gt;
&lt;p&gt;deque 是双端队列（double-ended queue）的缩写，由于两端都能编辑，deque 既可以用来实现栈（stack）也可以用来实现队列（queue）。&lt;/p&gt;
&lt;p&gt;deque 支持丰富的操作方法，主要方法如图：&lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://simpleapples.com/images/20180522_01.jpg&#34;&gt;&lt;/p&gt;
&lt;p&gt;相比于 list 实现的队列，deque 实现拥有更低的时间和空间复杂度。list 实现在出队（pop）和插入（insert）时的空间复杂度大约为 O(n)，deque 在出队（pop）和入队（append）时的时间复杂度是 O(1)。&lt;/p&gt;
&lt;p&gt;deque 也支持 in 操作符，可以使用如下写法：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;q &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; collections&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;deque([&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;])
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;print(&lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; q)  &lt;span style=&#34;color:#75715e&#34;&gt;# False&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;print(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; q)  &lt;span style=&#34;color:#75715e&#34;&gt;# True&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;deque 还封装了顺逆时针的旋转的方法：rotate。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 顺时针&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;q &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; collections&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;deque([&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;])
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;q&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;rotate(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;print(q)  &lt;span style=&#34;color:#75715e&#34;&gt;# [4, 1, 2, 3]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;q&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;rotate(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;print(q)  &lt;span style=&#34;color:#75715e&#34;&gt;# [3, 4, 1, 2]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 逆时针&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;q &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; collections&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;deque([&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;])
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;q&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;rotate(&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;print(q)  &lt;span style=&#34;color:#75715e&#34;&gt;# [2, 3, 4, 1]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;q&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;rotate(&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;print(q)  &lt;span style=&#34;color:#75715e&#34;&gt;# [3, 4, 1, 2]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;线程安全方面，通过查看 collections.deque 中的 append()、pop()等方法的源码可以知道，他们都是原子操作，所以是 GIL 保护下的线程安全方法。&lt;/p&gt;</description>
    </item>
    <item>
      <title>你真的会正确使用断言吗？</title>
      <link>https://simpleapples.com/zh/posts/right-way-to-use-assert-in-python/</link>
      <pubDate>Mon, 07 May 2018 16:12:00 +0000</pubDate>
      <guid>https://simpleapples.com/zh/posts/right-way-to-use-assert-in-python/</guid>
      <description>&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://simpleapples.com/images/20180507_01.jpg&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;什么是断言&#34;&gt;什么是断言&lt;/h1&gt;
&lt;p&gt;断言是作为一种调试工具被发明出来的，用来检查那些“代码写对了就肯定成立”的条件。例如我们要断言一个变量 a 必须要大于 2，就可以这样写：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;assert&lt;/span&gt; a &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;当条件不满足时，就会抛出 AssertionError 异常，等同于如下代码：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;not&lt;/span&gt; assert_condition:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;raise&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;AssertionError&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;由于断言是一个 debug 工具，Python 的实现也符合这个设计哲学，在 Python 中 assert 语句的执行是依赖于&lt;code&gt;__debug__&lt;/code&gt;变量的，当&lt;code&gt;__debug__&lt;/code&gt;为 true 时，assert 语句才会被执行。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; __debug__ &lt;span style=&#34;color:#f92672&#34;&gt;and&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;not&lt;/span&gt; assert_condition:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;raise&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;AssertionError&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;默认情况下，当我们执行一个 Python 文件时，&lt;code&gt;__debug__&lt;/code&gt;是会被设置为 True 的，只有加参数-O 或-OO 时，&lt;code&gt;__debug__&lt;/code&gt;才会被设置为 False。&lt;/p&gt;
&lt;p&gt;新建一个 assert.py 文件，写下如下代码：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;print(__debug__)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;assert&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;当使用 python assert.py 运行时，&lt;code&gt;__debug__&lt;/code&gt;会输出 True，assert 2 &amp;gt; 5 语句会抛出 AssertionError 异常。&lt;/p&gt;
&lt;p&gt;当使用 python -O assert.py 运行时，&lt;code&gt;__debug__&lt;/code&gt;会输出 False，assert 2 &amp;gt; 5 语句由于没有执行不会报任何异常。&lt;/p&gt;
&lt;h1 id=&#34;断言-or-异常&#34;&gt;断言 or 异常&lt;/h1&gt;
&lt;p&gt;我们思考这几个问题：断言应该用在哪些情境下？异常和断言的区别是什么？&lt;/p&gt;
&lt;p&gt;用一句话来概括断言的使用场景和与异常的区别：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;检查先验条件使用断言，检查后验条件使用异常&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;我们定义一个 read_file 函数：&lt;/p&gt;</description>
    </item>
    <item>
      <title>用装饰器封装Flask-WTF表单验证逻辑</title>
      <link>https://simpleapples.com/zh/posts/using-decorators-to-validate-form/</link>
      <pubDate>Thu, 26 Apr 2018 16:15:00 +0000</pubDate>
      <guid>https://simpleapples.com/zh/posts/using-decorators-to-validate-form/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;Don&amp;rsquo;t repeat yourself&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;在使用Flask-WTF的时候，常会用下面这样的代码来验证表单数据的合法性：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;from&lt;/span&gt; flask &lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; Flask
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;app &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Flask(__name__)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;@app.route&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;/&amp;#39;&lt;/span&gt;, methods&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;[&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;GET&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;POST&amp;#39;&lt;/span&gt;])
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;index&lt;/span&gt;():
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	form &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; TestForm()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#75715e&#34;&gt;# 判断是否合法&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;not&lt;/span&gt; form&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;validate_on_submit():
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;err&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;400&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#75715e&#34;&gt;# 主要逻辑&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;对于有很多提交接口的项目来说，需要在每个路由下写相同的的逻辑，造成了大量的代码重复。在Flask-Login中，要把一个路由设置为登录后才能访问，只需要在路由上加一个@login_required装饰器，不需要额外的代码。能不能像Flask-Login一样，用装饰器来封装对表单的验证逻辑呢？&lt;/p&gt;
&lt;h1 id=&#34;实现表单验证装饰器&#34;&gt;实现表单验证装饰器&lt;/h1&gt;
&lt;p&gt;由于不同路由使用的表单类不一样，所以需要为装饰器传入一个表单类参数，并且在路由函数中需要用到表单中的值，所以还需要将验证通过的表单传给路由函数。&lt;/p&gt;
&lt;p&gt;上代码：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;validate_form&lt;/span&gt;(self, form_cls):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;decorator&lt;/span&gt;(fn):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;@wraps&lt;/span&gt;(fn)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;wrapper&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;args, &lt;span style=&#34;color:#f92672&#34;&gt;**&lt;/span&gt;kwargs):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;not&lt;/span&gt; form&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;validate_on_submit():
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;error&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;400&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; fn(form, &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;args, &lt;span style=&#34;color:#f92672&#34;&gt;**&lt;/span&gt;kwargs)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; wrapper
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; decorator
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;使用方式如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;@validate_form&lt;/span&gt;(TestForm)  &lt;span style=&#34;color:#75715e&#34;&gt;# 需要传入要验证的表单类&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;@app.route&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;/&amp;#39;&lt;/span&gt;, methods&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;[&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;GET&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;POST&amp;#39;&lt;/span&gt;])
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;index&lt;/span&gt;(form):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;# 执行到这里说明表单验证通过&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;经过在项目中的应用，发现装饰器还是有一些缺陷：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;无法自定义处理非法表单的逻辑&lt;/li&gt;
&lt;li&gt;不支持get方式提交的表单（查看validate_on_submit()源码可知其只支持对post和put方式提交的表单进行验证）&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;丰富一下&#34;&gt;丰富一下&lt;/h1&gt;
&lt;p&gt;要自定义处理非法表单的逻辑，需要增加一个可以传入自定义逻辑的接口。表单非法时接口的返回往往是一致的，所以我们为所有应用装饰器的路由传入一个统一的处理逻辑。将装饰器封装在一个类中，在类中添加一个配置处理逻辑的方法。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;from&lt;/span&gt; functools &lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; wraps
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;from&lt;/span&gt; flask &lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; request
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;FormValidator&lt;/span&gt;(object):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;__init__&lt;/span&gt;(self, error_handler&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;None&lt;/span&gt;):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;_error_handler &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; error_handler
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;validate_form&lt;/span&gt;(self, form_cls):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;decorator&lt;/span&gt;(fn):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#a6e22e&#34;&gt;@wraps&lt;/span&gt;(fn)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;wrapper&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;args, &lt;span style=&#34;color:#f92672&#34;&gt;**&lt;/span&gt;kwargs):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;not&lt;/span&gt; form&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;validate_on_submit() &lt;span style=&#34;color:#f92672&#34;&gt;and&lt;/span&gt; self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;_error_handler:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;_error_handler(form&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;errors)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; fn(form, &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;args, &lt;span style=&#34;color:#f92672&#34;&gt;**&lt;/span&gt;kwargs)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; wrapper
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; decorator
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;error_handler&lt;/span&gt;(self, fn):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;_error_handler &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; fn
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; fn
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;error_handler也是一个装饰器，被它修饰的方法就是处理非法表单的方法。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Python参数传递，既不是传值也不是传引用</title>
      <link>https://simpleapples.com/zh/posts/python-parameter-passing/</link>
      <pubDate>Sun, 22 Apr 2018 14:38:00 +0000</pubDate>
      <guid>https://simpleapples.com/zh/posts/python-parameter-passing/</guid>
      <description>&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://simpleapples.com/images/20180422_01.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;面试的时候，有没有被问到 Python 传参是传引用还是传值这种问题？有没有听到过 Python 传参既不是传值也不是传引用这种说法？一个小小的参数默认值也可能让代码出现难以查找的 bug？&lt;/p&gt;
&lt;p&gt;如果你也遇到过上面的问题，不妨我们来探究下 Python 函数传递的种种。&lt;/p&gt;
&lt;h1 id=&#34;万物皆对象&#34;&gt;万物皆对象&lt;/h1&gt;
&lt;p&gt;Python 中有一个非常重要的概念——万物皆对象，无论是一个数字、字符串，还是数组、字典，在 Python 中都会以一个对象的形式存在。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;a &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;123&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;对于上面这行代码，在 Python 看来就是创建一个 PyObject 对象，值为 123，然后定义一个指针 a，a 指向这个 PyObject 对象。&lt;/p&gt;
&lt;h1 id=&#34;可变对象和不可变对象&#34;&gt;可变对象和不可变对象&lt;/h1&gt;
&lt;p&gt;Python 中的对象分为两种类型，可变对象和不可变对象，不可变对象指 tuple、str、int 等类型的对象，可变对象指的是 dict、list、自定义对象等类型的对象，我们用一段代码说明他们的区别。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;a &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;print(id(a))  &lt;span style=&#34;color:#75715e&#34;&gt;# 2587116690248&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;a &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; [&lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;print(id(a)) &lt;span style=&#34;color:#75715e&#34;&gt;# 2587116690248&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;b &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;print(id(b)) &lt;span style=&#34;color:#75715e&#34;&gt;# 2006430784&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;b &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;print(id(b)) &lt;span style=&#34;color:#75715e&#34;&gt;# 2006430816&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;上面代码中我们分别定义了一个可变对象和一个不可变对象，并且对他们进行修改，打印修改前后的对象标识可以发现，对可变对象进行修改，变量对其引用不会发生变化，对不可变对象进行修改，变量引用发生了变化。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;可变对象的引用&#34; loading=&#34;lazy&#34; src=&#34;https://simpleapples.com/images/20180422_02.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;上图是一个可变对象，当修改对象时，例如删除数组中的一个元素，实际上把其中一个元素从对象中移除，对象本身的标识是不发生变化的。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;不可变对象的引用&#34; loading=&#34;lazy&#34; src=&#34;https://simpleapples.com/images/20180422_03.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;改变一个不可变对象时，例如给一个 int 型加 2，语法上看上去是直接修改了 i 这个对象，但是如前面所说，i 只是一个指向对象 73 的一个变量，Python 会将这个变量指向的对象加 2 后，生成一个新的对象，然后再让 i 指向这个新的对象。&lt;/p&gt;
&lt;h1 id=&#34;参数传递时的表现&#34;&gt;参数传递时的表现&lt;/h1&gt;
&lt;p&gt;了解了对象的原理后，我们就可以来尝试理解一下参数传递时他们的不同表现了。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;a &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;print(id(a))  &lt;span style=&#34;color:#75715e&#34;&gt;# 1437494204232&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;mutable&lt;/span&gt;(a):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	print(id(a))  &lt;span style=&#34;color:#75715e&#34;&gt;# 1437494204232&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	a &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; [&lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	print(id(a))  &lt;span style=&#34;color:#75715e&#34;&gt;# 1437494204232&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;mutable(a)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;b &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;print(id(b))  &lt;span style=&#34;color:#75715e&#34;&gt;# 2006430784&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;immutable&lt;/span&gt;(b):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	print(id(b))  &lt;span style=&#34;color:#75715e&#34;&gt;# 2006430784&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	b &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	print(id(b))  &lt;span style=&#34;color:#75715e&#34;&gt;# 2006430816&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;immutable(b)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;通过上面的代码可以看出，修改传进的可变参数时，会对外部对象产生影响，修改不可变参数时则不会影响。&lt;/p&gt;</description>
    </item>
    <item>
      <title>实战 | 用aiohttp和uvloop实现一个高性能爬虫</title>
      <link>https://simpleapples.com/zh/posts/a-crawler-based-on-aiohttp-and-uvloop/</link>
      <pubDate>Tue, 10 Apr 2018 19:26:00 +0000</pubDate>
      <guid>https://simpleapples.com/zh/posts/a-crawler-based-on-aiohttp-and-uvloop/</guid>
      <description>&lt;p&gt;asyncio 于 Python3.4 引入标准库，增加了对异步 I/O 的支持，asyncio 基于事件循环，可以轻松实现异步 I/O 操作。接下来，我们用基于 asyncio 的库实现一个高性能爬虫。&lt;/p&gt;
&lt;h1 id=&#34;准备工作&#34;&gt;准备工作&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://chrome.google.com/webstore/detail/earth-view-from-google-ea/bhloflhklmhfpedakmangadcdofhnnoh&#34;&gt;Earth View from Google Earth&lt;/a&gt;是一款 Chrome 插件，会在打开新标签页时自动加载一张来自 Google Earth 的背景图片。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;Earth View from Google Earth&#34; loading=&#34;lazy&#34; src=&#34;https://simpleapples.com/images/20180410_01.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;使用 Chrome 开发者工具观察插件的网络请求，我们发现插件会请求一个地址如&lt;a href=&#34;https://www.gstatic.com/prettyearth/assets/data/v2/1234.json&#34;&gt;https://www.gstatic.com/prettyearth/assets/data/v2/1234.json&lt;/a&gt;的 JSON 文件，文件中包含了经过 Base64 的图片内容，观察发现，图片的 ID 范围大致在 1000-8000 之间，我们的爬虫就要来爬取这些精美的背景图片。&lt;/p&gt;
&lt;h1 id=&#34;实现主要逻辑&#34;&gt;实现主要逻辑&lt;/h1&gt;
&lt;p&gt;由于爬取目标是 JSON 文件，爬虫的主要逻辑就变成了&lt;strong&gt;爬取 JSON&amp;ndash;&amp;gt;提取图片&amp;ndash;&amp;gt;保存图片&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;requests 是一个常用的 http 请求库，但是由于 requests 的请求都是同步的，我们使用&lt;a href=&#34;https://aiohttp.readthedocs.io/en/stable/&#34;&gt;aiohttp&lt;/a&gt;这个异步 http 请求库来代替。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;async&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;fetch_image_by_id&lt;/span&gt;(item_id):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	url &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;f&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;https://www.gstatic.com/prettyearth/assets/data/v2/&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;{&lt;/span&gt;item_id&lt;span style=&#34;color:#e6db74&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;.json&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;# 由于URL是https的，所以选择不验证SSL&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;async&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;with&lt;/span&gt; aiohttp&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;ClientSession(connector&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;aiohttp&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;TCPConnector(verify_ssl&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;False&lt;/span&gt;)) &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; session:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#66d9ef&#34;&gt;async&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;with&lt;/span&gt; session&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;get(url) &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; response:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#75715e&#34;&gt;# 获取后需要将JSON字符串转为对象&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;			&lt;span style=&#34;color:#66d9ef&#34;&gt;try&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;				json_obj &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; json&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;loads(&lt;span style=&#34;color:#66d9ef&#34;&gt;await&lt;/span&gt; response&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;text())
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;			&lt;span style=&#34;color:#66d9ef&#34;&gt;except&lt;/span&gt; json&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;decoder&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;JSONDecodeError &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; e:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;				print(&lt;span style=&#34;color:#e6db74&#34;&gt;f&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Download failed - &lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;{&lt;/span&gt;item_id&lt;span style=&#34;color:#e6db74&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;.jpg&amp;#39;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;				&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#75715e&#34;&gt;# 获取JSON中的图片内容字段，经过Base64解码成二进制内容&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;			image_str &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; json_obj[&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;dataUri&amp;#39;&lt;/span&gt;]&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;replace(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;data:image/jpeg;base64,&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&amp;#39;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;			image_data &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; base64&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;b64decode(image_str)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;			save_folder &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; dir_path &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; os&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;path&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;dirname(
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;				os&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;path&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;realpath(__file__)) &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;/google_earth/&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;			&lt;span style=&#34;color:#66d9ef&#34;&gt;with&lt;/span&gt; open(&lt;span style=&#34;color:#e6db74&#34;&gt;f&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;{&lt;/span&gt;save_folder&lt;span style=&#34;color:#e6db74&#34;&gt;}{&lt;/span&gt;item_id&lt;span style=&#34;color:#e6db74&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;.jpg&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;wb&amp;#39;&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; f:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;				f&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;write(image_data)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;			print(&lt;span style=&#34;color:#e6db74&#34;&gt;f&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Download complete - &lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;{&lt;/span&gt;item_id&lt;span style=&#34;color:#e6db74&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;.jpg&amp;#39;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;aiohttp 基于 asyncio，所以在调用时需要使用 async/await 语法糖，可以看到，由于 aiohttp 中提供了一个 ClientSession 上下文，代码中使用了 async with 的语法糖。&lt;/p&gt;</description>
    </item>
    <item>
      <title>与面试官谈笑风生 | Python面向对象之访问控制</title>
      <link>https://simpleapples.com/zh/posts/python-access-control/</link>
      <pubDate>Fri, 30 Mar 2018 17:54:00 +0000</pubDate>
      <guid>https://simpleapples.com/zh/posts/python-access-control/</guid>
      <description>&lt;p&gt;Python 从设计之初就是一门面向对象的语言，面向对象思想的第一个要素就是封装。所谓封装，通俗的讲就是类中的属性和方法，分为公有和私有，公有可以被外界访问，私有不能被外界访问，这就是封装中最关键的概念——访问控制。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;面向对象编程&#34; loading=&#34;lazy&#34; src=&#34;https://simpleapples.com/images/20180330_01.jpg&#34;&gt;&lt;/p&gt;
&lt;p&gt;访问控制有三种级别：私有、受保护、公有&lt;/p&gt;
&lt;p&gt;私有（Private）：只有类自身可以访问
受保护（Protected）：只有类自身和子类可以访问
公有（Public）：任何类都可以访问&lt;/p&gt;
&lt;p&gt;由于 Python 不像 Java，有访问控制符（private / public / protected），所以 Python 的访问控制也是容易被应聘者忽视和搞错的。&lt;/p&gt;
&lt;h1 id=&#34;公有public&#34;&gt;公有（Public）&lt;/h1&gt;
&lt;p&gt;在 Python 的类中，默认情况下定义的属性都是公有的。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Foo&lt;/span&gt;(object):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	bar &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;123&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;__init__&lt;/span&gt;(self, bob):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;bob &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; bob
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;print(Foo&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;bar)  &lt;span style=&#34;color:#75715e&#34;&gt;# 123&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;foo &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Foo(&lt;span style=&#34;color:#ae81ff&#34;&gt;456&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;print(foo&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;bob)  &lt;span style=&#34;color:#75715e&#34;&gt;# 456&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;上面类&lt;code&gt;Foo&lt;/code&gt;中的&lt;code&gt;bar&lt;/code&gt;属性就是类属性，&lt;code&gt;__init__&lt;/code&gt;方法中定义的 bob 是实例属性，&lt;code&gt;bar&lt;/code&gt;和&lt;code&gt;bob&lt;/code&gt;都是公有的属性，外部可以访问，分别 print 类中的&lt;code&gt;bar&lt;/code&gt;和实例中的&lt;code&gt;bob&lt;/code&gt;，输出了对应的值。&lt;/p&gt;
&lt;h1 id=&#34;受保护protected&#34;&gt;受保护（Protected）&lt;/h1&gt;
&lt;p&gt;在 Python 中定义一个受保护的属性，只需要在其名字前加一个下划线&lt;code&gt;_&lt;/code&gt;，我们将 Foo 方法中的&lt;code&gt;bob&lt;/code&gt;和&lt;code&gt;bar&lt;/code&gt;改为&lt;code&gt;_bob&lt;/code&gt;和&lt;code&gt;_bar&lt;/code&gt;，他们就变成了受保护的属性了，代码如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Foo&lt;/span&gt;(object):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	_bar &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;123&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;__init__&lt;/span&gt;(self, bob):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;_bob &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; bob
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Son&lt;/span&gt;(Foo):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;print_bob&lt;/span&gt;(self):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		print(self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;_bob)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#a6e22e&#34;&gt;@classmethod&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;print_bar&lt;/span&gt;(cls):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		print(cls&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;_bar)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;Son&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;print_bar()  &lt;span style=&#34;color:#75715e&#34;&gt;# 123&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;son &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Son(&lt;span style=&#34;color:#ae81ff&#34;&gt;456&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;son&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;print_bob()  &lt;span style=&#34;color:#75715e&#34;&gt;# 456&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;定义一个类&lt;code&gt;Son&lt;/code&gt;继承自&lt;code&gt;Foo&lt;/code&gt;，由于受保护的对象只能在类的内部和子类中被访问，不能直接调用&lt;code&gt;print(Son._bar)&lt;/code&gt;或&lt;code&gt;print(son._bob)&lt;/code&gt;来输出这两个属性的值，所以定义了&lt;code&gt;print_bar&lt;/code&gt;和&lt;code&gt;print_bob&lt;/code&gt;方法，实现在子类中输出，这段代码也正常的输出了&lt;code&gt;_bar&lt;/code&gt;和&lt;code&gt;_bob&lt;/code&gt;的值。&lt;/p&gt;</description>
    </item>
    <item>
      <title>用Python批量提取Win10锁屏壁纸</title>
      <link>https://simpleapples.com/zh/posts/extract-lockscreen-wallpapers-in-win10/</link>
      <pubDate>Mon, 26 Mar 2018 22:21:00 +0000</pubDate>
      <guid>https://simpleapples.com/zh/posts/extract-lockscreen-wallpapers-in-win10/</guid>
      <description>&lt;p&gt;使用 Win10 的朋友会发现，每次开机锁屏界面都会有不一样的漂亮图片，这些图片通常选自优秀的摄影作品，十分精美。&lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://simpleapples.com/images/20180326_01.jpg&#34;&gt;&lt;/p&gt;
&lt;p&gt;但是由于系统会自动更换这些图片，所以就算再好看的图片，也许下次开机之后就被替换掉了。&lt;/p&gt;
&lt;p&gt;借助 Python，我们可以用简单的几行代码，批量提取这些精美的锁屏图片。把喜欢的图片设置成桌面背景，就不用担心被替换掉啦。&lt;/p&gt;
&lt;h1 id=&#34;提取原理&#34;&gt;提取原理&lt;/h1&gt;
&lt;p&gt;Win10 系统会自动下载最新的锁屏壁纸，并将他们保存在一个系统文件夹中，路径是&lt;code&gt;C:\Users\[用户名]\AppData\Local\Packages\Microsoft.Windows.ContentDeliveryManager_cw5n1h2txyewy\LocalState\Assets&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;随机命名的锁屏图片&#34; loading=&#34;lazy&#34; src=&#34;https://simpleapples.com/images/20180326_02.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;直接打开这个文件夹，里面会有随机命名的多个文件，每一个文件就是一张图片。但是由于文件没有扩展名，所以并不能预览。为了不搞坏系统文件，并且把这些文件变成可以预览的格式，我们用 Python 把这些文件复制出来，加上 JPG 作为扩展名。&lt;/p&gt;
&lt;h1 id=&#34;实现代码&#34;&gt;实现代码&lt;/h1&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; os&lt;span style=&#34;color:#f92672&#34;&gt;,&lt;/span&gt; shutil
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;from&lt;/span&gt; datetime &lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; datetime
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 把这个文件所在目录wallpapers文件夹作为保存图片的目录&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;save_folder &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; dir_path &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; os&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;path&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;dirname(
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	os&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;path&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;realpath(__file__)) &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;\wallpapers&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 动态获取系统存放锁屏图片的位置&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;wallpaper_folder &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; os&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;getenv(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;LOCALAPPDATA&amp;#39;&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; (
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;\Packages\Microsoft.Windows.ContentDeliveryManager_cw5n1h2txyewy&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;\LocalState\Assets&amp;#39;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 列出所有的文件&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;wallpapers &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; os&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;listdir(wallpaper_folder)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; wallpaper &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; wallpapers:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	wallpaper_path &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; os&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;path&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;join(wallpaper_folder, wallpaper)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#75715e&#34;&gt;# 小于150kb的不是锁屏图片&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (os&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;path&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;getsize(wallpaper_path) &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1024&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;150&lt;/span&gt;:
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;		&lt;span style=&#34;color:#66d9ef&#34;&gt;continue&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	wallpaper_name &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; wallpaper &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;.jpg&amp;#39;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	save_path &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; os&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;path&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;join(save_folder, wallpaper_name)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	shutil&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;copyfile(wallpaper_path, save_path)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;	print(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Save wallpaper &amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; save_path)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;首先确定系统存放锁屏图片的文件夹位置，由于文件夹位于用户的个人文件夹内，每个用户的用户名是不一样的，所以我们需要通过系统的&lt;code&gt;LOCALAPPDATA&lt;/code&gt;变量动态的获取路径。代码会把提取出来的图片保存在 wallpapers 文件夹下，所以代码文件所在的目录没有 wallpapers 文件夹，需要手工创建一个。&lt;/p&gt;</description>
    </item>
    <item>
      <title>15行Python代码，帮你理解令牌桶算法</title>
      <link>https://simpleapples.com/zh/posts/implementation-of-the-token-bucket-algorithm-in-python/</link>
      <pubDate>Tue, 20 Mar 2018 12:50:00 +0000</pubDate>
      <guid>https://simpleapples.com/zh/posts/implementation-of-the-token-bucket-algorithm-in-python/</guid>
      <description>&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://simpleapples.com/images/20180320_01.jpg&#34;&gt;&lt;/p&gt;
&lt;p&gt;在网络中传输数据时，为了防止网络拥塞，需限制流出网络的流量，使流量以比较均匀的速度向外发送，令牌桶算法就实现了这个功能，&lt;strong&gt;可控制发送到网络上数据的数目，并允许突发数据的发送。&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&#34;什么是令牌&#34;&gt;什么是令牌&lt;/h1&gt;
&lt;p&gt;从名字上看令牌桶，大概就是一个装有令牌的桶吧，那么什么是令牌呢？&lt;/p&gt;
&lt;p&gt;紫薇格格拿的令箭，可以发号施令，令行禁止。在计算机的世界中，令牌也有令行禁止的意思，有令牌，则相当于得到了进行操作的授权，没有令牌，就什么都不能做。&lt;/p&gt;
&lt;h1 id=&#34;用令牌实现限速器&#34;&gt;用令牌实现限速器&lt;/h1&gt;
&lt;p&gt;我们用 1 块令牌来代表发送 1 字节数据的资格，假设我们源源不断的发放令牌给程序，程序就有资格源源不断的发送数据，当我们不发放令牌给程序，程序就相当于被限流，无法发送数据了。接下来我们说说限速器，所谓限速器，就是让程序在单位时间内，最多只能发送一定大小的数据。假设在 1 秒发放 10 块令牌，那么程序发送数据的速度就会被限制在 10bytes/s。如果 1 秒内有大于 10bytes 的数据需要发送，就会因为没有令牌而被丢弃。&lt;/p&gt;
&lt;h1 id=&#34;改进限速器加个桶&#34;&gt;改进限速器——加个桶&lt;/h1&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://simpleapples.com/images/20180320_02.jpg&#34;&gt;&lt;/p&gt;
&lt;p&gt;我们实现的限速器，速度是恒定的，但是在实际的应用中，往往会有突发的传输需求（需要更快速的发送，但是不会持续太久，也不会引起网络拥塞），这种数据碰上我们的限速器，就因为拿不到令牌而无法发送。&lt;/p&gt;
&lt;p&gt;对限速器进行一下改动，依然 1 秒产生 10 块令牌，但是我们把产生出来的令牌先放到一个桶里，当程序需要发送的时候，从桶里取令牌，不需要的时候，令牌就会在桶里沉淀下来，假设桶里沉淀了 10 块令牌，程序最多就可以在 1 秒内发送 20bytes 的数据，满足了突发数据传输的要求，并且由于桶里的令牌被用完，下一秒最多依然只能发 10bytes 的数据，不会因为持续发送大量数据，对网络造成压力。&lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://simpleapples.com/images/20180320_03.jpg&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;15-行-python-代码实践令牌桶&#34;&gt;15 行 Python 代码实践令牌桶&lt;/h1&gt;
&lt;p&gt;令牌桶需要以一定的速度生成令牌放入桶中，当程序要发送数据时，再从桶中取出令牌。这里似乎有点问题，如果我们使用一个死循环，来不停地发放令牌，程序就被阻塞住了，有没有更好的办法？&lt;/p&gt;
&lt;p&gt;我们可以在取令牌的时候，用现在的时间减去上次取令牌的时间，乘以令牌的发放速度，计算出桶里可以取的令牌数量（当然不能超过桶的大小），从而避免循环发放的逻辑。&lt;/p&gt;
&lt;p&gt;接下来看代码：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; time
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;TokenBucket&lt;/span&gt;(object):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;# rate是令牌发放速度，capacity是桶的大小&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;__init__&lt;/span&gt;(self, rate, capacity):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;_rate &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; rate
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;_capacity &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; capacity
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;_current_amount &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;_last_consume_time &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; int(time&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;time())
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;# token_amount是发送数据需要的令牌数&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;consume&lt;/span&gt;(self, token_amount):
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        increment &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (int(time&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;time()) &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;_last_consume_time) &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;_rate  &lt;span style=&#34;color:#75715e&#34;&gt;# 计算从上次发送到这次发送，新发放的令牌数量&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;_current_amount &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; min(
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            increment &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;_current_amount, self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;_capacity)  &lt;span style=&#34;color:#75715e&#34;&gt;# 令牌数量不能超过桶的容量&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; token_amount &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;_current_amount:  &lt;span style=&#34;color:#75715e&#34;&gt;# 如果没有足够的令牌，则不能发送数据&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;False&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;_last_consume_time &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; int(time&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;time())
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;_current_amount &lt;span style=&#34;color:#f92672&#34;&gt;-=&lt;/span&gt; token_amount
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;True&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    <item>
      <title>最爱你的人，会让你不费脑细胞的理解区块链原理</title>
      <link>https://simpleapples.com/zh/posts/understanding-blockchain/</link>
      <pubDate>Wed, 14 Mar 2018 21:00:00 +0000</pubDate>
      <guid>https://simpleapples.com/zh/posts/understanding-blockchain/</guid>
      <description>&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://simpleapples.com/images/20180314_01.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;区块链是一个近期非常火的概念，随便走进一个写字楼的电梯，都会听到有人谈论区块链，或者炒币: ) 希望通过这篇文章，能让你对区块链的概念有一个整体的认识，在理解概念后，&lt;strong&gt;下一篇文章将用大约 300 行 Python 代码，实现一个区块链网络。&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&#34;区块-和-链&#34;&gt;区块 和 链&lt;/h1&gt;
&lt;p&gt;所谓区块，就是一个块咯（要不然还是什么？），把这些块一个一个连在一起，像链条一样，就称为区块链（别急着打我，先往下看）。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;区块和区块链&#34; loading=&#34;lazy&#34; src=&#34;https://simpleapples.com/images/20180314_02.jpg&#34;&gt;&lt;/p&gt;
&lt;p&gt;这是一些链条，链条的价值更多的体现在锁楼下小电动车的时候，不过我们再仔细看一下这个链条是不是有点像那什么？⛓&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;脱氧核糖核酸&#34; loading=&#34;lazy&#34; src=&#34;https://simpleapples.com/images/20180314_03.gif&#34;&gt;&lt;/p&gt;
&lt;p&gt;很聪明，高中生物老师在冲你微笑！这就是传说中的脱氧核糖核酸（DNA），DNA 也是一种链式结构，&lt;strong&gt;携带了遗传信息&lt;/strong&gt;。区块链中的“区块”，就好比 DNA 分子中的脱氧核糖核苷酸（我也不知道自己在说什么），而区块链中的“链”，就好比 DNA 分子的链式结构。&lt;/p&gt;
&lt;p&gt;DNA 和链条的价值差异，关键在于 DNA 携带了大量遗传&lt;strong&gt;信息&lt;/strong&gt;，而链条什么都没有携带。对于区块链来说，携带信息也是它的一个重要特点（不携带信息连锁电动车的作用都没有）。&lt;/p&gt;
&lt;p&gt;当区块链携带的是账务信息的时候，它就变成了一个特别厉害的东西——账本（我们给他起了个 00 后的名字——比特币）。&lt;/p&gt;
&lt;h1 id=&#34;peer-to-peer&#34;&gt;Peer-to-Peer&lt;/h1&gt;
&lt;p&gt;为了显得专业一些，我们祭出比特币的创造者，中本聪的论文&lt;a href=&#34;https://bitcoin.org/bitcoin.pdf&#34;&gt;《Bitcoin: A Peer-to-Peer Electronic Cash System》&lt;/a&gt;，从这篇论文的题目我们可以看到，区块链是基于&lt;strong&gt;Peer-to-Peer&lt;/strong&gt;的，下面就来了解一下什么是 Peer-to-Peer。&lt;/p&gt;
&lt;p&gt;Peer-to-Peer，简称 P2P（不是互联网借贷的那个 P2P），它是一种点对点网络，看图（我也不知道该怎么讲）。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;P2P网络&#34; loading=&#34;lazy&#34; src=&#34;https://simpleapples.com/images/20180314_04.jpg&#34;&gt;&lt;/p&gt;
&lt;p&gt;图中每一个方脑袋就是一个 Peer（节点），注意一下，这些方脑袋有一个共同点，他们都一毛一样（不仅长得一样，每一个脑袋都跟其它脑袋相连）。这也是 P2P 网络的最大特点——&lt;strong&gt;去中心化&lt;/strong&gt;，P2P 网络中不存在中心节点，所有节点都是平等的，任何一个节点，想跟谁说话就跟谁说话，并且谁（节点）都不能说了算。&lt;/p&gt;
&lt;h1 id=&#34;共识机制&#34;&gt;共识机制&lt;/h1&gt;
&lt;p&gt;你和好基友老王，还有你们共同喜欢的一个姑娘阿圆（对，就是圆滚滚的圆），组成了一个三节点的 P2P 网络，根据 P2P 网络定义你们三个人谁都不能说了算。这一天，阿圆生日，你和老王同时给阿圆送了一个大蛋糕，那么问题来了，阿圆先吃哪个呢？&lt;/p&gt;
&lt;p&gt;既然没有人能说了算，也不能让你和老王决斗（计算机这么做恐怕人类会毁灭），那么就需要采用一个文明的办法决定——商量。既然商量，就要有规矩，这个规矩叫&lt;strong&gt;共识机制&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://simpleapples.com/images/20180314_05.png&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;proof-of-work&#34;&gt;Proof-of-work&lt;/h1&gt;
&lt;p&gt;区块链共识机制有很多种，Proof-of-work（POW，工作量证明）是其中一种，所谓工作量证明，有点像是比武招亲。你和老王对阿圆都很好，阿圆也很难抉择到底先吃谁的蛋糕，于是她请了两位武力相当的武林高手，让你和老王分别与高手过招，谁赢了高手，就先吃谁的蛋糕，如果你们都赢了高手，那么谁先赢算数。&lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://simpleapples.com/images/20180314_06.jpg&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;把这些捏在一起&#34;&gt;把这些捏在一起&lt;/h1&gt;
&lt;p&gt;了解了 POW、共识机制、P2P、区块、链的概念，我们就可以把他们拼在一起，看看会发生什么了。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;区块链诞生了！&#34; loading=&#34;lazy&#34; src=&#34;https://simpleapples.com/images/20180314_07.jpeg&#34;&gt;&lt;/p&gt;
&lt;p&gt;我们把 P2P 网络中的每一个节点，赋予一条链，这样网络中所有的链都是平等的了，接下来在其中一条链上增加一个带有信息的区块，P2P 网络会将这个区块同步到所有的链上，也就是这条信息会被存储在所有节点。&lt;/p&gt;
&lt;p&gt;把上面的一段话缩成一句（会显得比较厉害）：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;区块链是用分布式数据库识别、传播和记载信息的智能化对等网络, 也称为价值互联网。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;看到这里是不是对区块链略知一二了？&lt;/p&gt;</description>
    </item>
    <item>
      <title>面试不再怕，20行Python代码帮你搞懂LRU算法</title>
      <link>https://simpleapples.com/zh/posts/lru-algorithm-implemented-in-python/</link>
      <pubDate>Tue, 06 Mar 2018 20:00:00 +0000</pubDate>
      <guid>https://simpleapples.com/zh/posts/lru-algorithm-implemented-in-python/</guid>
      <description>&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://simpleapples.com/images/20180306_01.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;LRU 算法在后端工程师面试中，是一个比较常出现的题目，这篇文章带大家一起，理解 LRU 算法，并最终用 Python 轻松实现一个基于 LRU 算法的缓存。&lt;/p&gt;
&lt;h2 id=&#34;缓存是什么&#34;&gt;缓存是什么&lt;/h2&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://simpleapples.com/images/20180306_02.jpg&#34;&gt;&lt;/p&gt;
&lt;p&gt;先看一张图，当我们访问网页，浏览器会给服务器发请求，服务器会经过一系列的运算，把页面返回给浏览器。&lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://simpleapples.com/images/20180306_03.jpg&#34;&gt;&lt;/p&gt;
&lt;p&gt;当有多个浏览器同时访问的时候，就会在短时间内发起多个请求，而服务器对每一个请求都要进行一系列相同的操作。重复工作不仅浪费资源，还可能导致响应速度变慢。&lt;/p&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://simpleapples.com/images/20180306_04.jpg&#34;&gt;&lt;/p&gt;
&lt;p&gt;而缓存则可以把服务器返回的页面保存下来，当有其他的浏览器再访问时候，就不必劳服务器大驾，直接由缓存返回页面。为了保证响应速度，缓存通常是基于比较昂贵的硬件，比如 RAM，这就决定了我们很难用大量的缓存把所有的页面都存下来，当恰好没有缓存浏览器请求的页面时，依然需要请求服务器。由于缓存容量有限，而数据量无限（互联网每天新产生的页面数无法估计），就需要把好刚用在刀刃上，缓存那些最有用的信息。&lt;/p&gt;
&lt;h2 id=&#34;lru-是什么&#34;&gt;LRU 是什么&lt;/h2&gt;
&lt;p&gt;LRU 是一种缓存淘汰算法（在 OS 中也叫内存换页算法），由于缓存空间是有限的，所以要淘汰缓存中不常用的数据，留下常用的数据，达到缓存效率的最大化。LRU 就是这样一种决定“淘汰谁留下谁”的算法，LRU 是 Least recently used 的缩写，从字面意思“最近最少使用”，我们就可以理解 LRU 的淘汰规则。&lt;/p&gt;
&lt;h2 id=&#34;lru-的淘汰逻辑&#34;&gt;LRU 的淘汰逻辑&lt;/h2&gt;
&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://simpleapples.com/images/20180306_05.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;我们用一张图来描述 LRU 的淘汰逻辑，图中的缓存是一个列表结构，上面是头结点下面是尾节点，缓存容量为 8（8 个小格子）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;有新数据（意味着数据之前没有被缓存过）时，加入到列表头&lt;/li&gt;
&lt;li&gt;缓存到达最大容量时，需要淘汰数据多出来的数据，此时淘汰列表尾部的数据&lt;/li&gt;
&lt;li&gt;当缓存中有数据被命中，则将数据移动到列表头部（相当于新加入缓存）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;按上面的逻辑我们可以看到，一个数据如果经常被访问就会不断地被移动到列表头部，不会被淘汰出缓存，而越不经常访问的数据，越容易被挤出缓存。&lt;/p&gt;
&lt;h2 id=&#34;20-行-python-代码实践-lru&#34;&gt;20 行 Python 代码实践 LRU&lt;/h2&gt;
&lt;p&gt;接下来我们用 Python 来实现一个采用 LRU 算法的缓存。&lt;/p&gt;
&lt;p&gt;从前面的文章中我们可以知道，缓存简化下来就两个功能，一个是往里装数据（缓存数据），一个是往外吐数据（命中缓存），所以我们的缓存对外只需要 put 和 get 两个接口就可以了。&lt;/p&gt;
&lt;p&gt;按照前面的示意图，缓存内部我们只需要有一个列表（list）就可以实现 LRU 逻辑，不过用列表虽然能实现逻辑，但是在判断是否命中缓存时，速度可能非常慢（列表需要遍历才能知道数据有没有在里面）。在 Python 中，我们可以用基于 hash 的结构，比如字典（dict）或集合（set），来快速判断数据是否存在，解决列表实现的性能问题。但是字典和集合又是没有顺序的，如果能有一种既能排序，又是基于 hash 存储的数据结构，就好了。&lt;/p&gt;
&lt;p&gt;在 Python 的 collections 包中，已经内置了这种实用的结构 OrderedDict，OrderedDict 是 dict 的子类，但是存储在内部的元素是有序的（列表的特点）。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
