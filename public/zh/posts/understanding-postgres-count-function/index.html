<!DOCTYPE html>
<html lang="zh" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>理解 PostgreSQL 的 count 函数的行为 | Zhiya&#39;s Blog</title>
<meta name="keywords" content="">
<meta name="description" content="关于 count 函数的使用一直存在争议，尤其是在 MySQL 中，作为流行度越来越高的 PostgreSQL 是否也有类似的问题呢，我们通过实践来理解一下 PostgreSQL 中 count 函数的行为。

构建测试数据库
创建测试数据库，并创建测试表。测试表中有自增 ID、创建时间、内容三个字段，自增 ID 字段是主键。
create database performance_test;

create table test_tbl (id serial primary key, created_at timestamp, content varchar(512));
生成测试数据
使用 generate_series 函数生成自增 ID，使用 now() 函数生成 created_at 列，对于 content 列，使用了 repeat(md5(random()::text), 10) 生成 10 个 32 位长度的 md5 字符串。使用下列语句，插入 1000w 条记录用于测试。
performance_test=# insert into test_tbl select generate_series(1,10000000),now(),repeat(md5(random()::text),10);
INSERT 0 10000000
Time: 212184.223 ms (03:32.184)
由 count 语句引发的思考
默认情况下 PostgreSQL 不开启 SQL 执行时间的显示，所以需要手动开启一下，方便后面的测试对比。
\timing on
count(*) 和 count(1) 的性能区别是经常被讨论的问题，分别使用 count(*) 和 count(1) 执行一次查询。">
<meta name="author" content="Zhiya">
<link rel="canonical" href="https://simpleapples.com/zh/posts/understanding-postgres-count-function/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.8fe10233a706bc87f2e08b3cf97b8bd4c0a80f10675a143675d59212121037c0.css" integrity="sha256-j&#43;ECM6cGvIfy4Is8&#43;XuL1MCoDxBnWhQ2ddWSEhIQN8A=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://simpleapples.com/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://simpleapples.com/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://simpleapples.com/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://simpleapples.com/apple-touch-icon.png">
<link rel="mask-icon" href="https://simpleapples.com/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="zh" href="https://simpleapples.com/zh/posts/understanding-postgres-count-function/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:url" content="https://simpleapples.com/zh/posts/understanding-postgres-count-function/">
  <meta property="og:site_name" content="Zhiya&#39;s Blog">
  <meta property="og:title" content="理解 PostgreSQL 的 count 函数的行为">
  <meta property="og:description" content="关于 count 函数的使用一直存在争议，尤其是在 MySQL 中，作为流行度越来越高的 PostgreSQL 是否也有类似的问题呢，我们通过实践来理解一下 PostgreSQL 中 count 函数的行为。
构建测试数据库 创建测试数据库，并创建测试表。测试表中有自增 ID、创建时间、内容三个字段，自增 ID 字段是主键。
create database performance_test; create table test_tbl (id serial primary key, created_at timestamp, content varchar(512)); 生成测试数据 使用 generate_series 函数生成自增 ID，使用 now() 函数生成 created_at 列，对于 content 列，使用了 repeat(md5(random()::text), 10) 生成 10 个 32 位长度的 md5 字符串。使用下列语句，插入 1000w 条记录用于测试。
performance_test=# insert into test_tbl select generate_series(1,10000000),now(),repeat(md5(random()::text),10); INSERT 0 10000000 Time: 212184.223 ms (03:32.184) 由 count 语句引发的思考 默认情况下 PostgreSQL 不开启 SQL 执行时间的显示，所以需要手动开启一下，方便后面的测试对比。
\timing on count(*) 和 count(1) 的性能区别是经常被讨论的问题，分别使用 count(*) 和 count(1) 执行一次查询。">
  <meta property="og:locale" content="cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2019-04-16T11:25:00+00:00">
    <meta property="article:modified_time" content="2019-04-16T11:25:00+00:00">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="理解 PostgreSQL 的 count 函数的行为">
<meta name="twitter:description" content="关于 count 函数的使用一直存在争议，尤其是在 MySQL 中，作为流行度越来越高的 PostgreSQL 是否也有类似的问题呢，我们通过实践来理解一下 PostgreSQL 中 count 函数的行为。

构建测试数据库
创建测试数据库，并创建测试表。测试表中有自增 ID、创建时间、内容三个字段，自增 ID 字段是主键。
create database performance_test;

create table test_tbl (id serial primary key, created_at timestamp, content varchar(512));
生成测试数据
使用 generate_series 函数生成自增 ID，使用 now() 函数生成 created_at 列，对于 content 列，使用了 repeat(md5(random()::text), 10) 生成 10 个 32 位长度的 md5 字符串。使用下列语句，插入 1000w 条记录用于测试。
performance_test=# insert into test_tbl select generate_series(1,10000000),now(),repeat(md5(random()::text),10);
INSERT 0 10000000
Time: 212184.223 ms (03:32.184)
由 count 语句引发的思考
默认情况下 PostgreSQL 不开启 SQL 执行时间的显示，所以需要手动开启一下，方便后面的测试对比。
\timing on
count(*) 和 count(1) 的性能区别是经常被讨论的问题，分别使用 count(*) 和 count(1) 执行一次查询。">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://simpleapples.com/zh/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "理解 PostgreSQL 的 count 函数的行为",
      "item": "https://simpleapples.com/zh/posts/understanding-postgres-count-function/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "理解 PostgreSQL 的 count 函数的行为",
  "name": "理解 PostgreSQL 的 count 函数的行为",
  "description": "关于 count 函数的使用一直存在争议，尤其是在 MySQL 中，作为流行度越来越高的 PostgreSQL 是否也有类似的问题呢，我们通过实践来理解一下 PostgreSQL 中 count 函数的行为。\n构建测试数据库 创建测试数据库，并创建测试表。测试表中有自增 ID、创建时间、内容三个字段，自增 ID 字段是主键。\ncreate database performance_test; create table test_tbl (id serial primary key, created_at timestamp, content varchar(512)); 生成测试数据 使用 generate_series 函数生成自增 ID，使用 now() 函数生成 created_at 列，对于 content 列，使用了 repeat(md5(random()::text), 10) 生成 10 个 32 位长度的 md5 字符串。使用下列语句，插入 1000w 条记录用于测试。\nperformance_test=# insert into test_tbl select generate_series(1,10000000),now(),repeat(md5(random()::text),10); INSERT 0 10000000 Time: 212184.223 ms (03:32.184) 由 count 语句引发的思考 默认情况下 PostgreSQL 不开启 SQL 执行时间的显示，所以需要手动开启一下，方便后面的测试对比。\n\\timing on count(*) 和 count(1) 的性能区别是经常被讨论的问题，分别使用 count(*) 和 count(1) 执行一次查询。\n",
  "keywords": [
    
  ],
  "articleBody": "关于 count 函数的使用一直存在争议，尤其是在 MySQL 中，作为流行度越来越高的 PostgreSQL 是否也有类似的问题呢，我们通过实践来理解一下 PostgreSQL 中 count 函数的行为。\n构建测试数据库 创建测试数据库，并创建测试表。测试表中有自增 ID、创建时间、内容三个字段，自增 ID 字段是主键。\ncreate database performance_test; create table test_tbl (id serial primary key, created_at timestamp, content varchar(512)); 生成测试数据 使用 generate_series 函数生成自增 ID，使用 now() 函数生成 created_at 列，对于 content 列，使用了 repeat(md5(random()::text), 10) 生成 10 个 32 位长度的 md5 字符串。使用下列语句，插入 1000w 条记录用于测试。\nperformance_test=# insert into test_tbl select generate_series(1,10000000),now(),repeat(md5(random()::text),10); INSERT 0 10000000 Time: 212184.223 ms (03:32.184) 由 count 语句引发的思考 默认情况下 PostgreSQL 不开启 SQL 执行时间的显示，所以需要手动开启一下，方便后面的测试对比。\n\\timing on count(*) 和 count(1) 的性能区别是经常被讨论的问题，分别使用 count(*) 和 count(1) 执行一次查询。\nperformance_test=# select count(*) from test_tbl; count ---------- 10000000 (1 row) Time: 115090.380 ms (01:55.090) performance_test=# select count(1) from test_tbl; count ---------- 10000000 (1 row) Time: 738.502 ms 可以看到两次查询的速度差别非常大，count(1) 真的有这么大的性能提升？接下来再次运行查询语句。\nperformance_test=# select count(*) from test_tbl; count ---------- 10000000 (1 row) Time: 657.831 ms performance_test=# select count(1) from test_tbl; count ---------- 10000000 (1 row) Time: 682.157 ms 可以看到第一次查询时候会非常的慢，后面三次速度非常快并且时间相近，这里就有两个问题出现了：\n为什么第一次查询速度这么慢？ count(*) 和 count(1) 到底存不存在性能差别？ 查询缓存 使用 explain 语句重新执行查询语句\nexplain (analyze,buffers,verbose) select count(*) from test_tbl; 可以看到如下输出：\nFinalize Aggregate (cost=529273.69..529273.70 rows=1 width=8) (actual time=882.569..882.570 rows=1 loops=1) Output: count(*) Buffers: shared hit=96 read=476095 -\u003e Gather (cost=529273.48..529273.69 rows=2 width=8) (actual time=882.492..884.170 rows=3 loops=1) Output: (PARTIAL count(*)) Workers Planned: 2 Workers Launched: 2 Buffers: shared hit=96 read=476095 -\u003e Partial Aggregate (cost=528273.48..528273.49 rows=1 width=8) (actual time=881.014..881.014 rows=1 loops=3) Output: PARTIAL count(*) Buffers: shared hit=96 read=476095 Worker 0: actual time=880.319..880.319 rows=1 loops=1 Buffers: shared hit=34 read=158206 Worker 1: actual time=880.369..880.369 rows=1 loops=1 Buffers: shared hit=29 read=156424 -\u003e Parallel Seq Scan on public.test_tbl (cost=0.00..517856.98 rows=4166598 width=0) (actual time=0.029..662.165 rows=3333333 loops=3) Buffers: shared hit=96 read=476095 Worker 0: actual time=0.026..661.807 rows=3323029 loops=1 Buffers: shared hit=34 read=158206 Worker 1: actual time=0.030..660.197 rows=3285513 loops=1 Buffers: shared hit=29 read=156424 Planning time: 0.043 ms Execution time: 884.207 ms 注意里面的 shared hit，表示命中了内存中缓存的数据，这就可以解释为什么后面的查询会比第一次快很多。接下来去掉缓存，并重启 PostgreSQL。\nservice postgresql stop echo 1 \u003e /proc/sys/vm/drop_caches service postgresql start 重新执行 SQL 语句，速度慢了很多。\nFinalize Aggregate (cost=529273.69..529273.70 rows=1 width=8) (actual time=50604.564..50604.564 rows=1 loops=1) Output: count(*) Buffers: shared read=476191 -\u003e Gather (cost=529273.48..529273.69 rows=2 width=8) (actual time=50604.508..50606.141 rows=3 loops=1) Output: (PARTIAL count(*)) Workers Planned: 2 Workers Launched: 2 Buffers: shared read=476191 -\u003e Partial Aggregate (cost=528273.48..528273.49 rows=1 width=8) (actual time=50591.550..50591.551 rows=1 loops=3) Output: PARTIAL count(*) Buffers: shared read=476191 Worker 0: actual time=50585.182..50585.182 rows=1 loops=1 Buffers: shared read=158122 Worker 1: actual time=50585.181..50585.181 rows=1 loops=1 Buffers: shared read=161123 -\u003e Parallel Seq Scan on public.test_tbl (cost=0.00..517856.98 rows=4166598 width=0) (actual time=92.491..50369.691 rows=3333333 loops=3) Buffers: shared read=476191 Worker 0: actual time=122.170..50362.271 rows=3320562 loops=1 Buffers: shared read=158122 Worker 1: actual time=14.020..50359.733 rows=3383583 loops=1 Buffers: shared read=161123 Planning time: 11.537 ms Execution time: 50606.215 ms shared read 表示没有命中缓存，通过这个现象可以推断出，上一小节的四次查询中，第一次查询没有命中缓存，剩下三次查询都命中了缓存。\ncount(1) 和 count(*) 的区别 接下来探究 count(1) 和 count(*) 的区别是什么，继续思考最开始的四次查询，第一次查询使用了 count(*)，第二次查询使用了 count(1) ，却依然命中了缓存，不正是说明 count(1) 和 count(*) 是一样的吗？\n事实上，PostgreSQL 官方对于 is there a difference performance-wise between select count(1) and select count(*)? 问题的回复也证实了这一点：\nNope. In fact, the latter is converted to the former during parsing.[2]\n既然 count(1) 在性能上没有比 count(*) 更好，那么使用 count(*) 就是更好的选择。\nsequence scan 和 index scan 接下来测试一下，在不同数据量大小的情况下 count(*) 的速度，将查询语句写在 count.sql 文件中，使用 pgbench 进行测试。\npgbench -c 5 -t 20 performance_test -r -f count.sql 分别测试 200w - 1000w 数据量下的 count 语句耗时\n数据大小 count 耗时(ms) 200w 738.758 300w 1035.846 400w 1426.183 500w 1799.866 600w 2117.247 700w 2514.691 800w 2526.441 900w 2568.240 1000w 2650.434 绘制成耗时曲线\n曲线的趋势在 600w - 700w 数据量之间出现了转折，200w - 600w 是线性增长，600w 之后 count 的耗时就基本相同了。使用 explain 语句分别查看 600w 和 700w 数据时的 count 语句执行。\n700w：\nFinalize Aggregate (cost=502185.93..502185.94 rows=1 width=8) (actual time=894.361..894.361 rows=1 loops=1) Output: count(*) Buffers: shared hit=16344 read=352463 -\u003e Gather (cost=502185.72..502185.93 rows=2 width=8) (actual time=894.232..899.763 rows=3 loops=1) Output: (PARTIAL count(*)) Workers Planned: 2 Workers Launched: 2 Buffers: shared hit=16344 read=352463 -\u003e Partial Aggregate (cost=501185.72..501185.73 rows=1 width=8) (actual time=889.371..889.371 rows=1 loops=3) Output: PARTIAL count(*) Buffers: shared hit=16344 read=352463 Worker 0: actual time=887.112..887.112 rows=1 loops=1 Buffers: shared hit=5459 read=118070 Worker 1: actual time=887.120..887.120 rows=1 loops=1 Buffers: shared hit=5601 read=117051 -\u003e Parallel Index Only Scan using test_tbl_pkey on public.test_tbl (cost=0.43..493863.32 rows=2928960 width=0) (actual time=0.112..736.376 rows=2333333 loops=3) Index Cond: (test_tbl.id \u003c 7000000) Heap Fetches: 2328492 Buffers: shared hit=16344 read=352463 Worker 0: actual time=0.107..737.180 rows=2344479 loops=1 Buffers: shared hit=5459 read=118070 Worker 1: actual time=0.133..737.960 rows=2327028 loops=1 Buffers: shared hit=5601 read=117051 Planning time: 0.165 ms Execution time: 899.857 ms 600w：\nFinalize Aggregate (cost=429990.94..429990.95 rows=1 width=8) (actual time=765.575..765.575 rows=1 loops=1) Output: count(*) Buffers: shared hit=13999 read=302112 -\u003e Gather (cost=429990.72..429990.93 rows=2 width=8) (actual time=765.557..770.889 rows=3 loops=1) Output: (PARTIAL count(*)) Workers Planned: 2 Workers Launched: 2 Buffers: shared hit=13999 read=302112 -\u003e Partial Aggregate (cost=428990.72..428990.73 rows=1 width=8) (actual time=763.821..763.821 rows=1 loops=3) Output: PARTIAL count(*) Buffers: shared hit=13999 read=302112 Worker 0: actual time=762.742..762.742 rows=1 loops=1 Buffers: shared hit=4638 read=98875 Worker 1: actual time=763.308..763.308 rows=1 loops=1 Buffers: shared hit=4696 read=101570 -\u003e Parallel Index Only Scan using test_tbl_pkey on public.test_tbl (cost=0.43..422723.16 rows=2507026 width=0) (actual time=0.053..632.199 rows=2000000 loops=3) Index Cond: (test_tbl.id \u003c 6000000) Heap Fetches: 2018490 Buffers: shared hit=13999 read=302112 Worker 0: actual time=0.059..633.156 rows=1964483 loops=1 Buffers: shared hit=4638 read=98875 Worker 1: actual time=0.038..634.271 rows=2017026 loops=1 Buffers: shared hit=4696 read=101570 Planning time: 0.055 ms Execution time: 770.921 ms 根据以上现象推断，PostgreSQL 似乎在 count 的数据量小于数据表长度的某一比例时，才使用 index scan，通过查看官方 wiki 也可以看到相关描述：\nIt is important to realise that the planner is concerned with minimising the total cost of the query. With databases, the cost of I/O typically dominates. For that reason, “count(*) without any predicate” queries will only use an index-only scan if the index is significantly smaller than its table. This typically only happens when the table’s row width is much wider than some indexes’.[3]\n根据 Stackoverflow 上的回答，count 语句查询的数量大于表大小的 3/4 时候就会用使用全表扫描代替索引扫描[4]。\n结论 不要用 count(1) 或 count(列名) 代替 count(*) count 本身是非常耗时的 count 可能是 index scan 也可能是 sequence scan，取决于 count 数量占表大小的比例 参考资料 [1] 深入理解 Postgres 中的 cache\n[2] Re: performance difference in count(1) vs. count(*)?\n[3] Is “count(*)” much faster now?\n[4] PostgreSQL not using index during count(*)\n",
  "wordCount" : "908",
  "inLanguage": "zh",
  "datePublished": "2019-04-16T11:25:00Z",
  "dateModified": "2019-04-16T11:25:00Z",
  "author":{
    "@type": "Person",
    "name": "Zhiya"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://simpleapples.com/zh/posts/understanding-postgres-count-function/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Zhiya's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://simpleapples.com/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://simpleapples.com/zh/" accesskey="h" title="Zhiya&#39;s Blog (Alt + H)">Zhiya&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
                <ul class="lang-switch"><li>|</li>
                    <li>
                        <a href="https://simpleapples.com/en/" title="English"
                            aria-label="English">English</a>
                    </li>
                </ul>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://simpleapples.com/zh/archives/" title="归档">
                    <span>归档</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://simpleapples.com/zh/">主页</a>&nbsp;»&nbsp;<a href="https://simpleapples.com/zh/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      理解 PostgreSQL 的 count 函数的行为
    </h1>
    <div class="post-meta"><span title='2019-04-16 11:25:00 +0000 +0000'>四月 16, 2019</span>&nbsp;·&nbsp;5 分钟&nbsp;·&nbsp;Zhiya

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">目录</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#%e6%9e%84%e5%bb%ba%e6%b5%8b%e8%af%95%e6%95%b0%e6%8d%ae%e5%ba%93" aria-label="构建测试数据库">构建测试数据库</a></li>
                <li>
                    <a href="#%e7%94%9f%e6%88%90%e6%b5%8b%e8%af%95%e6%95%b0%e6%8d%ae" aria-label="生成测试数据">生成测试数据</a></li>
                <li>
                    <a href="#%e7%94%b1-count-%e8%af%ad%e5%8f%a5%e5%bc%95%e5%8f%91%e7%9a%84%e6%80%9d%e8%80%83" aria-label="由 count 语句引发的思考">由 count 语句引发的思考</a></li>
                <li>
                    <a href="#%e6%9f%a5%e8%af%a2%e7%bc%93%e5%ad%98" aria-label="查询缓存">查询缓存</a><ul>
                        
                <li>
                    <a href="#count1-%e5%92%8c-count-%e7%9a%84%e5%8c%ba%e5%88%ab" aria-label="count(1) 和 count(*) 的区别">count(1) 和 count(*) 的区别</a></li></ul>
                </li>
                <li>
                    <a href="#sequence-scan-%e5%92%8c-index-scan" aria-label="sequence scan 和 index scan">sequence scan 和 index scan</a></li>
                <li>
                    <a href="#%e7%bb%93%e8%ae%ba" aria-label="结论">结论</a></li>
                <li>
                    <a href="#%e5%8f%82%e8%80%83%e8%b5%84%e6%96%99" aria-label="参考资料">参考资料</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><p>关于 count 函数的使用一直存在争议，尤其是在 MySQL 中，作为流行度越来越高的 PostgreSQL 是否也有类似的问题呢，我们通过实践来理解一下 PostgreSQL 中 count 函数的行为。</p>
<!-- more -->
<h3 id="构建测试数据库">构建测试数据库<a hidden class="anchor" aria-hidden="true" href="#构建测试数据库">#</a></h3>
<p>创建测试数据库，并创建测试表。测试表中有自增 ID、创建时间、内容三个字段，自增 ID 字段是主键。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">create</span> <span style="color:#66d9ef">database</span> performance_test;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">create</span> <span style="color:#66d9ef">table</span> test_tbl (id serial <span style="color:#66d9ef">primary</span> <span style="color:#66d9ef">key</span>, created_at <span style="color:#66d9ef">timestamp</span>, content varchar(<span style="color:#ae81ff">512</span>));
</span></span></code></pre></div><h3 id="生成测试数据">生成测试数据<a hidden class="anchor" aria-hidden="true" href="#生成测试数据">#</a></h3>
<p>使用 generate_series 函数生成自增 ID，使用 now() 函数生成 created_at 列，对于 content 列，使用了 repeat(md5(random()::text), 10) 生成 10 个 32 位长度的 md5 字符串。使用下列语句，插入 1000w 条记录用于测试。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span>performance_test<span style="color:#f92672">=#</span> <span style="color:#66d9ef">insert</span> <span style="color:#66d9ef">into</span> test_tbl <span style="color:#66d9ef">select</span> generate_series(<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">10000000</span>),now(),repeat(md5(random()::text),<span style="color:#ae81ff">10</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">INSERT</span> <span style="color:#ae81ff">0</span> <span style="color:#ae81ff">10000000</span>
</span></span><span style="display:flex;"><span>Time: <span style="color:#ae81ff">212184</span>.<span style="color:#ae81ff">223</span> ms (<span style="color:#ae81ff">03</span>:<span style="color:#ae81ff">32</span>.<span style="color:#ae81ff">184</span>)
</span></span></code></pre></div><h3 id="由-count-语句引发的思考">由 count 语句引发的思考<a hidden class="anchor" aria-hidden="true" href="#由-count-语句引发的思考">#</a></h3>
<p>默认情况下 PostgreSQL 不开启 SQL 执行时间的显示，所以需要手动开启一下，方便后面的测试对比。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">\</span>timing <span style="color:#66d9ef">on</span>
</span></span></code></pre></div><p>count(*) 和 count(1) 的性能区别是经常被讨论的问题，分别使用 count(*) 和 count(1) 执行一次查询。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span>performance_test<span style="color:#f92672">=#</span> <span style="color:#66d9ef">select</span> <span style="color:#66d9ef">count</span>(<span style="color:#f92672">*</span>) <span style="color:#66d9ef">from</span> test_tbl;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">count</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">----------
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#ae81ff">10000000</span>
</span></span><span style="display:flex;"><span>(<span style="color:#ae81ff">1</span> <span style="color:#66d9ef">row</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Time: <span style="color:#ae81ff">115090</span>.<span style="color:#ae81ff">380</span> ms (<span style="color:#ae81ff">01</span>:<span style="color:#ae81ff">55</span>.<span style="color:#ae81ff">090</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>performance_test<span style="color:#f92672">=#</span> <span style="color:#66d9ef">select</span> <span style="color:#66d9ef">count</span>(<span style="color:#ae81ff">1</span>) <span style="color:#66d9ef">from</span> test_tbl;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">count</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">----------
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#ae81ff">10000000</span>
</span></span><span style="display:flex;"><span>(<span style="color:#ae81ff">1</span> <span style="color:#66d9ef">row</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Time: <span style="color:#ae81ff">738</span>.<span style="color:#ae81ff">502</span> ms
</span></span></code></pre></div><p>可以看到两次查询的速度差别非常大，count(1) 真的有这么大的性能提升？接下来再次运行查询语句。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span>performance_test<span style="color:#f92672">=#</span> <span style="color:#66d9ef">select</span> <span style="color:#66d9ef">count</span>(<span style="color:#f92672">*</span>) <span style="color:#66d9ef">from</span> test_tbl;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">count</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">----------
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#ae81ff">10000000</span>
</span></span><span style="display:flex;"><span>(<span style="color:#ae81ff">1</span> <span style="color:#66d9ef">row</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Time: <span style="color:#ae81ff">657</span>.<span style="color:#ae81ff">831</span> ms
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>performance_test<span style="color:#f92672">=#</span> <span style="color:#66d9ef">select</span> <span style="color:#66d9ef">count</span>(<span style="color:#ae81ff">1</span>) <span style="color:#66d9ef">from</span> test_tbl;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">count</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">----------
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> <span style="color:#ae81ff">10000000</span>
</span></span><span style="display:flex;"><span>(<span style="color:#ae81ff">1</span> <span style="color:#66d9ef">row</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Time: <span style="color:#ae81ff">682</span>.<span style="color:#ae81ff">157</span> ms
</span></span></code></pre></div><p>可以看到第一次查询时候会非常的慢，后面三次速度非常快并且时间相近，这里就有两个问题出现了：</p>
<ul>
<li>为什么第一次查询速度这么慢？</li>
<li>count(*) 和 count(1) 到底存不存在性能差别？</li>
</ul>
<h3 id="查询缓存">查询缓存<a hidden class="anchor" aria-hidden="true" href="#查询缓存">#</a></h3>
<p>使用 explain 语句重新执行查询语句</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#66d9ef">explain</span> (<span style="color:#66d9ef">analyze</span>,buffers,<span style="color:#66d9ef">verbose</span>) <span style="color:#66d9ef">select</span> <span style="color:#66d9ef">count</span>(<span style="color:#f92672">*</span>) <span style="color:#66d9ef">from</span> test_tbl;
</span></span></code></pre></div><p>可以看到如下输出：</p>
<pre tabindex="0"><code> Finalize Aggregate  (cost=529273.69..529273.70 rows=1 width=8) (actual time=882.569..882.570 rows=1 loops=1)
   Output: count(*)
   Buffers: shared hit=96 read=476095
   -&gt;  Gather  (cost=529273.48..529273.69 rows=2 width=8) (actual time=882.492..884.170 rows=3 loops=1)
         Output: (PARTIAL count(*))
         Workers Planned: 2
         Workers Launched: 2
         Buffers: shared hit=96 read=476095
         -&gt;  Partial Aggregate  (cost=528273.48..528273.49 rows=1 width=8) (actual time=881.014..881.014 rows=1 loops=3)
               Output: PARTIAL count(*)
               Buffers: shared hit=96 read=476095
               Worker 0: actual time=880.319..880.319 rows=1 loops=1
                 Buffers: shared hit=34 read=158206
               Worker 1: actual time=880.369..880.369 rows=1 loops=1
                 Buffers: shared hit=29 read=156424
               -&gt;  Parallel Seq Scan on public.test_tbl  (cost=0.00..517856.98 rows=4166598 width=0) (actual time=0.029..662.165 rows=3333333 loops=3)
                     Buffers: shared hit=96 read=476095
                     Worker 0: actual time=0.026..661.807 rows=3323029 loops=1
                       Buffers: shared hit=34 read=158206
                     Worker 1: actual time=0.030..660.197 rows=3285513 loops=1
                       Buffers: shared hit=29 read=156424
 Planning time: 0.043 ms
 Execution time: 884.207 ms
</code></pre><p>注意里面的 shared hit，表示命中了内存中缓存的数据，这就可以解释为什么后面的查询会比第一次快很多。接下来去掉缓存，并重启 PostgreSQL。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>service postgresql stop
</span></span><span style="display:flex;"><span>echo <span style="color:#ae81ff">1</span> &gt; /proc/sys/vm/drop_caches
</span></span><span style="display:flex;"><span>service postgresql start
</span></span></code></pre></div><p>重新执行 SQL 语句，速度慢了很多。</p>
<pre tabindex="0"><code> Finalize Aggregate  (cost=529273.69..529273.70 rows=1 width=8) (actual time=50604.564..50604.564 rows=1 loops=1)
   Output: count(*)
   Buffers: shared read=476191
   -&gt;  Gather  (cost=529273.48..529273.69 rows=2 width=8) (actual time=50604.508..50606.141 rows=3 loops=1)
         Output: (PARTIAL count(*))
         Workers Planned: 2
         Workers Launched: 2
         Buffers: shared read=476191
         -&gt;  Partial Aggregate  (cost=528273.48..528273.49 rows=1 width=8) (actual time=50591.550..50591.551 rows=1 loops=3)
               Output: PARTIAL count(*)
               Buffers: shared read=476191
               Worker 0: actual time=50585.182..50585.182 rows=1 loops=1
                 Buffers: shared read=158122
               Worker 1: actual time=50585.181..50585.181 rows=1 loops=1
                 Buffers: shared read=161123
               -&gt;  Parallel Seq Scan on public.test_tbl  (cost=0.00..517856.98 rows=4166598 width=0) (actual time=92.491..50369.691 rows=3333333 loops=3)
                     Buffers: shared read=476191
                     Worker 0: actual time=122.170..50362.271 rows=3320562 loops=1
                       Buffers: shared read=158122
                     Worker 1: actual time=14.020..50359.733 rows=3383583 loops=1
                       Buffers: shared read=161123
 Planning time: 11.537 ms
 Execution time: 50606.215 ms
</code></pre><p>shared read 表示没有命中缓存，通过这个现象可以推断出，上一小节的四次查询中，第一次查询没有命中缓存，剩下三次查询都命中了缓存。</p>
<h4 id="count1-和-count-的区别">count(1) 和 count(*) 的区别<a hidden class="anchor" aria-hidden="true" href="#count1-和-count-的区别">#</a></h4>
<p>接下来探究 count(1) 和 count(*) 的区别是什么，继续思考最开始的四次查询，第一次查询使用了 count(*)，第二次查询使用了 count(1) ，却依然命中了缓存，不正是说明 count(1) 和 count(*) 是一样的吗？</p>
<p>事实上，PostgreSQL 官方对于 is there a difference performance-wise between select count(1) and select count(*)? 问题的回复也证实了这一点：</p>
<blockquote>
<p>Nope. In fact, the latter is converted to the former during parsing.[2]</p></blockquote>
<p>既然 count(1) 在性能上没有比 count(*) 更好，那么使用 count(*) 就是更好的选择。</p>
<h3 id="sequence-scan-和-index-scan">sequence scan 和 index scan<a hidden class="anchor" aria-hidden="true" href="#sequence-scan-和-index-scan">#</a></h3>
<p>接下来测试一下，在不同数据量大小的情况下 count(*) 的速度，将查询语句写在 count.sql 文件中，使用 pgbench 进行测试。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>pgbench -c <span style="color:#ae81ff">5</span> -t <span style="color:#ae81ff">20</span> performance_test -r -f count.sql
</span></span></code></pre></div><p>分别测试 200w - 1000w 数据量下的 count 语句耗时</p>
<table>
  <thead>
      <tr>
          <th>数据大小</th>
          <th>count 耗时(ms)</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>200w</td>
          <td>738.758</td>
      </tr>
      <tr>
          <td>300w</td>
          <td>1035.846</td>
      </tr>
      <tr>
          <td>400w</td>
          <td>1426.183</td>
      </tr>
      <tr>
          <td>500w</td>
          <td>1799.866</td>
      </tr>
      <tr>
          <td>600w</td>
          <td>2117.247</td>
      </tr>
      <tr>
          <td>700w</td>
          <td>2514.691</td>
      </tr>
      <tr>
          <td>800w</td>
          <td>2526.441</td>
      </tr>
      <tr>
          <td>900w</td>
          <td>2568.240</td>
      </tr>
      <tr>
          <td>1000w</td>
          <td>2650.434</td>
      </tr>
  </tbody>
</table>
<p>绘制成耗时曲线</p>
<p><img loading="lazy" src="/images/20190416_01.png"></p>
<p>曲线的趋势在 600w - 700w 数据量之间出现了转折，200w - 600w 是线性增长，600w 之后 count 的耗时就基本相同了。使用 explain 语句分别查看 600w 和 700w 数据时的 count 语句执行。</p>
<p>700w：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span> Finalize <span style="color:#66d9ef">Aggregate</span>  (cost<span style="color:#f92672">=</span><span style="color:#ae81ff">502185</span>.<span style="color:#ae81ff">93</span>..<span style="color:#ae81ff">502185</span>.<span style="color:#ae81ff">94</span> <span style="color:#66d9ef">rows</span><span style="color:#f92672">=</span><span style="color:#ae81ff">1</span> width<span style="color:#f92672">=</span><span style="color:#ae81ff">8</span>) (actual time<span style="color:#f92672">=</span><span style="color:#ae81ff">894</span>.<span style="color:#ae81ff">361</span>..<span style="color:#ae81ff">894</span>.<span style="color:#ae81ff">361</span> <span style="color:#66d9ef">rows</span><span style="color:#f92672">=</span><span style="color:#ae81ff">1</span> loops<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">Output</span>: <span style="color:#66d9ef">count</span>(<span style="color:#f92672">*</span>)
</span></span><span style="display:flex;"><span>   Buffers: shared hit<span style="color:#f92672">=</span><span style="color:#ae81ff">16344</span> <span style="color:#66d9ef">read</span><span style="color:#f92672">=</span><span style="color:#ae81ff">352463</span>
</span></span><span style="display:flex;"><span>   <span style="color:#f92672">-&gt;</span>  Gather  (cost<span style="color:#f92672">=</span><span style="color:#ae81ff">502185</span>.<span style="color:#ae81ff">72</span>..<span style="color:#ae81ff">502185</span>.<span style="color:#ae81ff">93</span> <span style="color:#66d9ef">rows</span><span style="color:#f92672">=</span><span style="color:#ae81ff">2</span> width<span style="color:#f92672">=</span><span style="color:#ae81ff">8</span>) (actual time<span style="color:#f92672">=</span><span style="color:#ae81ff">894</span>.<span style="color:#ae81ff">232</span>..<span style="color:#ae81ff">899</span>.<span style="color:#ae81ff">763</span> <span style="color:#66d9ef">rows</span><span style="color:#f92672">=</span><span style="color:#ae81ff">3</span> loops<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>         <span style="color:#66d9ef">Output</span>: (<span style="color:#66d9ef">PARTIAL</span> <span style="color:#66d9ef">count</span>(<span style="color:#f92672">*</span>))
</span></span><span style="display:flex;"><span>         Workers Planned: <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>         Workers Launched: <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>         Buffers: shared hit<span style="color:#f92672">=</span><span style="color:#ae81ff">16344</span> <span style="color:#66d9ef">read</span><span style="color:#f92672">=</span><span style="color:#ae81ff">352463</span>
</span></span><span style="display:flex;"><span>         <span style="color:#f92672">-&gt;</span>  <span style="color:#66d9ef">Partial</span> <span style="color:#66d9ef">Aggregate</span>  (cost<span style="color:#f92672">=</span><span style="color:#ae81ff">501185</span>.<span style="color:#ae81ff">72</span>..<span style="color:#ae81ff">501185</span>.<span style="color:#ae81ff">73</span> <span style="color:#66d9ef">rows</span><span style="color:#f92672">=</span><span style="color:#ae81ff">1</span> width<span style="color:#f92672">=</span><span style="color:#ae81ff">8</span>) (actual time<span style="color:#f92672">=</span><span style="color:#ae81ff">889</span>.<span style="color:#ae81ff">371</span>..<span style="color:#ae81ff">889</span>.<span style="color:#ae81ff">371</span> <span style="color:#66d9ef">rows</span><span style="color:#f92672">=</span><span style="color:#ae81ff">1</span> loops<span style="color:#f92672">=</span><span style="color:#ae81ff">3</span>)
</span></span><span style="display:flex;"><span>               <span style="color:#66d9ef">Output</span>: <span style="color:#66d9ef">PARTIAL</span> <span style="color:#66d9ef">count</span>(<span style="color:#f92672">*</span>)
</span></span><span style="display:flex;"><span>               Buffers: shared hit<span style="color:#f92672">=</span><span style="color:#ae81ff">16344</span> <span style="color:#66d9ef">read</span><span style="color:#f92672">=</span><span style="color:#ae81ff">352463</span>
</span></span><span style="display:flex;"><span>               Worker <span style="color:#ae81ff">0</span>: actual time<span style="color:#f92672">=</span><span style="color:#ae81ff">887</span>.<span style="color:#ae81ff">112</span>..<span style="color:#ae81ff">887</span>.<span style="color:#ae81ff">112</span> <span style="color:#66d9ef">rows</span><span style="color:#f92672">=</span><span style="color:#ae81ff">1</span> loops<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>                 Buffers: shared hit<span style="color:#f92672">=</span><span style="color:#ae81ff">5459</span> <span style="color:#66d9ef">read</span><span style="color:#f92672">=</span><span style="color:#ae81ff">118070</span>
</span></span><span style="display:flex;"><span>               Worker <span style="color:#ae81ff">1</span>: actual time<span style="color:#f92672">=</span><span style="color:#ae81ff">887</span>.<span style="color:#ae81ff">120</span>..<span style="color:#ae81ff">887</span>.<span style="color:#ae81ff">120</span> <span style="color:#66d9ef">rows</span><span style="color:#f92672">=</span><span style="color:#ae81ff">1</span> loops<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>                 Buffers: shared hit<span style="color:#f92672">=</span><span style="color:#ae81ff">5601</span> <span style="color:#66d9ef">read</span><span style="color:#f92672">=</span><span style="color:#ae81ff">117051</span>
</span></span><span style="display:flex;"><span>               <span style="color:#f92672">-&gt;</span>  Parallel <span style="color:#66d9ef">Index</span> <span style="color:#66d9ef">Only</span> Scan <span style="color:#66d9ef">using</span> test_tbl_pkey <span style="color:#66d9ef">on</span> <span style="color:#66d9ef">public</span>.test_tbl  (cost<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>.<span style="color:#ae81ff">43</span>..<span style="color:#ae81ff">493863</span>.<span style="color:#ae81ff">32</span> <span style="color:#66d9ef">rows</span><span style="color:#f92672">=</span><span style="color:#ae81ff">2928960</span> width<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>) (actual time<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>.<span style="color:#ae81ff">112</span>..<span style="color:#ae81ff">736</span>.<span style="color:#ae81ff">376</span> <span style="color:#66d9ef">rows</span><span style="color:#f92672">=</span><span style="color:#ae81ff">2333333</span> loops<span style="color:#f92672">=</span><span style="color:#ae81ff">3</span>)
</span></span><span style="display:flex;"><span>                     <span style="color:#66d9ef">Index</span> Cond: (test_tbl.id <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">7000000</span>)
</span></span><span style="display:flex;"><span>                     Heap Fetches: <span style="color:#ae81ff">2328492</span>
</span></span><span style="display:flex;"><span>                     Buffers: shared hit<span style="color:#f92672">=</span><span style="color:#ae81ff">16344</span> <span style="color:#66d9ef">read</span><span style="color:#f92672">=</span><span style="color:#ae81ff">352463</span>
</span></span><span style="display:flex;"><span>                     Worker <span style="color:#ae81ff">0</span>: actual time<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>.<span style="color:#ae81ff">107</span>..<span style="color:#ae81ff">737</span>.<span style="color:#ae81ff">180</span> <span style="color:#66d9ef">rows</span><span style="color:#f92672">=</span><span style="color:#ae81ff">2344479</span> loops<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>                       Buffers: shared hit<span style="color:#f92672">=</span><span style="color:#ae81ff">5459</span> <span style="color:#66d9ef">read</span><span style="color:#f92672">=</span><span style="color:#ae81ff">118070</span>
</span></span><span style="display:flex;"><span>                     Worker <span style="color:#ae81ff">1</span>: actual time<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>.<span style="color:#ae81ff">133</span>..<span style="color:#ae81ff">737</span>.<span style="color:#ae81ff">960</span> <span style="color:#66d9ef">rows</span><span style="color:#f92672">=</span><span style="color:#ae81ff">2327028</span> loops<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>                       Buffers: shared hit<span style="color:#f92672">=</span><span style="color:#ae81ff">5601</span> <span style="color:#66d9ef">read</span><span style="color:#f92672">=</span><span style="color:#ae81ff">117051</span>
</span></span><span style="display:flex;"><span> Planning time: <span style="color:#ae81ff">0</span>.<span style="color:#ae81ff">165</span> ms
</span></span><span style="display:flex;"><span> Execution time: <span style="color:#ae81ff">899</span>.<span style="color:#ae81ff">857</span> ms
</span></span></code></pre></div><p>600w：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span> Finalize <span style="color:#66d9ef">Aggregate</span>  (cost<span style="color:#f92672">=</span><span style="color:#ae81ff">429990</span>.<span style="color:#ae81ff">94</span>..<span style="color:#ae81ff">429990</span>.<span style="color:#ae81ff">95</span> <span style="color:#66d9ef">rows</span><span style="color:#f92672">=</span><span style="color:#ae81ff">1</span> width<span style="color:#f92672">=</span><span style="color:#ae81ff">8</span>) (actual time<span style="color:#f92672">=</span><span style="color:#ae81ff">765</span>.<span style="color:#ae81ff">575</span>..<span style="color:#ae81ff">765</span>.<span style="color:#ae81ff">575</span> <span style="color:#66d9ef">rows</span><span style="color:#f92672">=</span><span style="color:#ae81ff">1</span> loops<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">Output</span>: <span style="color:#66d9ef">count</span>(<span style="color:#f92672">*</span>)
</span></span><span style="display:flex;"><span>   Buffers: shared hit<span style="color:#f92672">=</span><span style="color:#ae81ff">13999</span> <span style="color:#66d9ef">read</span><span style="color:#f92672">=</span><span style="color:#ae81ff">302112</span>
</span></span><span style="display:flex;"><span>   <span style="color:#f92672">-&gt;</span>  Gather  (cost<span style="color:#f92672">=</span><span style="color:#ae81ff">429990</span>.<span style="color:#ae81ff">72</span>..<span style="color:#ae81ff">429990</span>.<span style="color:#ae81ff">93</span> <span style="color:#66d9ef">rows</span><span style="color:#f92672">=</span><span style="color:#ae81ff">2</span> width<span style="color:#f92672">=</span><span style="color:#ae81ff">8</span>) (actual time<span style="color:#f92672">=</span><span style="color:#ae81ff">765</span>.<span style="color:#ae81ff">557</span>..<span style="color:#ae81ff">770</span>.<span style="color:#ae81ff">889</span> <span style="color:#66d9ef">rows</span><span style="color:#f92672">=</span><span style="color:#ae81ff">3</span> loops<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>         <span style="color:#66d9ef">Output</span>: (<span style="color:#66d9ef">PARTIAL</span> <span style="color:#66d9ef">count</span>(<span style="color:#f92672">*</span>))
</span></span><span style="display:flex;"><span>         Workers Planned: <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>         Workers Launched: <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>         Buffers: shared hit<span style="color:#f92672">=</span><span style="color:#ae81ff">13999</span> <span style="color:#66d9ef">read</span><span style="color:#f92672">=</span><span style="color:#ae81ff">302112</span>
</span></span><span style="display:flex;"><span>         <span style="color:#f92672">-&gt;</span>  <span style="color:#66d9ef">Partial</span> <span style="color:#66d9ef">Aggregate</span>  (cost<span style="color:#f92672">=</span><span style="color:#ae81ff">428990</span>.<span style="color:#ae81ff">72</span>..<span style="color:#ae81ff">428990</span>.<span style="color:#ae81ff">73</span> <span style="color:#66d9ef">rows</span><span style="color:#f92672">=</span><span style="color:#ae81ff">1</span> width<span style="color:#f92672">=</span><span style="color:#ae81ff">8</span>) (actual time<span style="color:#f92672">=</span><span style="color:#ae81ff">763</span>.<span style="color:#ae81ff">821</span>..<span style="color:#ae81ff">763</span>.<span style="color:#ae81ff">821</span> <span style="color:#66d9ef">rows</span><span style="color:#f92672">=</span><span style="color:#ae81ff">1</span> loops<span style="color:#f92672">=</span><span style="color:#ae81ff">3</span>)
</span></span><span style="display:flex;"><span>               <span style="color:#66d9ef">Output</span>: <span style="color:#66d9ef">PARTIAL</span> <span style="color:#66d9ef">count</span>(<span style="color:#f92672">*</span>)
</span></span><span style="display:flex;"><span>               Buffers: shared hit<span style="color:#f92672">=</span><span style="color:#ae81ff">13999</span> <span style="color:#66d9ef">read</span><span style="color:#f92672">=</span><span style="color:#ae81ff">302112</span>
</span></span><span style="display:flex;"><span>               Worker <span style="color:#ae81ff">0</span>: actual time<span style="color:#f92672">=</span><span style="color:#ae81ff">762</span>.<span style="color:#ae81ff">742</span>..<span style="color:#ae81ff">762</span>.<span style="color:#ae81ff">742</span> <span style="color:#66d9ef">rows</span><span style="color:#f92672">=</span><span style="color:#ae81ff">1</span> loops<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>                 Buffers: shared hit<span style="color:#f92672">=</span><span style="color:#ae81ff">4638</span> <span style="color:#66d9ef">read</span><span style="color:#f92672">=</span><span style="color:#ae81ff">98875</span>
</span></span><span style="display:flex;"><span>               Worker <span style="color:#ae81ff">1</span>: actual time<span style="color:#f92672">=</span><span style="color:#ae81ff">763</span>.<span style="color:#ae81ff">308</span>..<span style="color:#ae81ff">763</span>.<span style="color:#ae81ff">308</span> <span style="color:#66d9ef">rows</span><span style="color:#f92672">=</span><span style="color:#ae81ff">1</span> loops<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>                 Buffers: shared hit<span style="color:#f92672">=</span><span style="color:#ae81ff">4696</span> <span style="color:#66d9ef">read</span><span style="color:#f92672">=</span><span style="color:#ae81ff">101570</span>
</span></span><span style="display:flex;"><span>               <span style="color:#f92672">-&gt;</span>  Parallel <span style="color:#66d9ef">Index</span> <span style="color:#66d9ef">Only</span> Scan <span style="color:#66d9ef">using</span> test_tbl_pkey <span style="color:#66d9ef">on</span> <span style="color:#66d9ef">public</span>.test_tbl  (cost<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>.<span style="color:#ae81ff">43</span>..<span style="color:#ae81ff">422723</span>.<span style="color:#ae81ff">16</span> <span style="color:#66d9ef">rows</span><span style="color:#f92672">=</span><span style="color:#ae81ff">2507026</span> width<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>) (actual time<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>.<span style="color:#ae81ff">053</span>..<span style="color:#ae81ff">632</span>.<span style="color:#ae81ff">199</span> <span style="color:#66d9ef">rows</span><span style="color:#f92672">=</span><span style="color:#ae81ff">2000000</span> loops<span style="color:#f92672">=</span><span style="color:#ae81ff">3</span>)
</span></span><span style="display:flex;"><span>                     <span style="color:#66d9ef">Index</span> Cond: (test_tbl.id <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">6000000</span>)
</span></span><span style="display:flex;"><span>                     Heap Fetches: <span style="color:#ae81ff">2018490</span>
</span></span><span style="display:flex;"><span>                     Buffers: shared hit<span style="color:#f92672">=</span><span style="color:#ae81ff">13999</span> <span style="color:#66d9ef">read</span><span style="color:#f92672">=</span><span style="color:#ae81ff">302112</span>
</span></span><span style="display:flex;"><span>                     Worker <span style="color:#ae81ff">0</span>: actual time<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>.<span style="color:#ae81ff">059</span>..<span style="color:#ae81ff">633</span>.<span style="color:#ae81ff">156</span> <span style="color:#66d9ef">rows</span><span style="color:#f92672">=</span><span style="color:#ae81ff">1964483</span> loops<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>                       Buffers: shared hit<span style="color:#f92672">=</span><span style="color:#ae81ff">4638</span> <span style="color:#66d9ef">read</span><span style="color:#f92672">=</span><span style="color:#ae81ff">98875</span>
</span></span><span style="display:flex;"><span>                     Worker <span style="color:#ae81ff">1</span>: actual time<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>.<span style="color:#ae81ff">038</span>..<span style="color:#ae81ff">634</span>.<span style="color:#ae81ff">271</span> <span style="color:#66d9ef">rows</span><span style="color:#f92672">=</span><span style="color:#ae81ff">2017026</span> loops<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>                       Buffers: shared hit<span style="color:#f92672">=</span><span style="color:#ae81ff">4696</span> <span style="color:#66d9ef">read</span><span style="color:#f92672">=</span><span style="color:#ae81ff">101570</span>
</span></span><span style="display:flex;"><span> Planning time: <span style="color:#ae81ff">0</span>.<span style="color:#ae81ff">055</span> ms
</span></span><span style="display:flex;"><span> Execution time: <span style="color:#ae81ff">770</span>.<span style="color:#ae81ff">921</span> ms
</span></span></code></pre></div><p>根据以上现象推断，PostgreSQL 似乎在 count 的数据量小于数据表长度的某一比例时，才使用 index scan，通过查看官方 wiki 也可以看到相关描述：</p>
<blockquote>
<p>It is important to realise that the planner is concerned with minimising the total cost of the query. With databases, the cost of I/O typically dominates. For that reason, &ldquo;count(*) without any predicate&rdquo; queries will only use an index-only scan if the index is significantly smaller than its table. This typically only happens when the table&rsquo;s row width is much wider than some indexes&rsquo;.[3]</p></blockquote>
<p>根据 Stackoverflow 上的回答，count 语句查询的数量大于表大小的 3/4 时候就会用使用全表扫描代替索引扫描[4]。</p>
<h3 id="结论">结论<a hidden class="anchor" aria-hidden="true" href="#结论">#</a></h3>
<ol>
<li>不要用 count(1) 或 count(列名) 代替 count(*)</li>
<li>count 本身是非常耗时的</li>
<li>count 可能是 index scan 也可能是 sequence scan，取决于 count 数量占表大小的比例</li>
</ol>
<h3 id="参考资料">参考资料<a hidden class="anchor" aria-hidden="true" href="#参考资料">#</a></h3>
<p>[1] <a href="https://www.cnblogs.com/flying-tiger/p/7885478.html">深入理解 Postgres 中的 cache</a></p>
<p>[2] <a href="https://www.postgresql.org/message-id/11471.1027875769%40sss.pgh.pa.us">Re: performance difference in count(1) vs. count(*)?</a></p>
<p>[3] <a href="https://wiki.postgresql.org/wiki/Index-only_scans#Is_.22count.28.2A.29.22_much_faster_now.3F">Is &ldquo;count(*)&rdquo; much faster now?</a></p>
<p>[4] <a href="https://dba.stackexchange.com/questions/126997/postgresql-not-using-index-during-count">PostgreSQL not using index during count(*)</a></p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
<nav class="paginav">
  <a class="prev" href="https://simpleapples.com/zh/posts/building-docker-image-behind-proxy/">
    <span class="title">« 上一页</span>
    <br>
    <span>使用代理进行 docker build 问题的解决思路</span>
  </a>
  <a class="next" href="https://simpleapples.com/zh/posts/solution-to-problem-of-jwt-token-invalidation/">
    <span class="title">下一页 »</span>
    <br>
    <span>JWT 避坑指南：nbf 验签失效问题的解决</span>
  </a>
</nav>


<ul class="share-buttons">
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 理解 PostgreSQL 的 count 函数的行为 on x"
            href="https://x.com/intent/tweet/?text=%e7%90%86%e8%a7%a3%20PostgreSQL%20%e7%9a%84%20count%20%e5%87%bd%e6%95%b0%e7%9a%84%e8%a1%8c%e4%b8%ba&amp;url=https%3a%2f%2fsimpleapples.com%2fzh%2fposts%2funderstanding-postgres-count-function%2f&amp;hashtags=">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M512 62.554 L 512 449.446 C 512 483.97 483.97 512 449.446 512 L 62.554 512 C 28.03 512 0 483.97 0 449.446 L 0 62.554 C 0 28.03 28.029 0 62.554 0 L 449.446 0 C 483.971 0 512 28.03 512 62.554 Z M 269.951 190.75 L 182.567 75.216 L 56 75.216 L 207.216 272.95 L 63.9 436.783 L 125.266 436.783 L 235.9 310.383 L 332.567 436.783 L 456 436.783 L 298.367 228.367 L 432.367 75.216 L 371.033 75.216 Z M 127.633 110 L 164.101 110 L 383.481 400.065 L 349.5 400.065 Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 理解 PostgreSQL 的 count 函数的行为 on linkedin"
            href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fsimpleapples.com%2fzh%2fposts%2funderstanding-postgres-count-function%2f&amp;title=%e7%90%86%e8%a7%a3%20PostgreSQL%20%e7%9a%84%20count%20%e5%87%bd%e6%95%b0%e7%9a%84%e8%a1%8c%e4%b8%ba&amp;summary=%e7%90%86%e8%a7%a3%20PostgreSQL%20%e7%9a%84%20count%20%e5%87%bd%e6%95%b0%e7%9a%84%e8%a1%8c%e4%b8%ba&amp;source=https%3a%2f%2fsimpleapples.com%2fzh%2fposts%2funderstanding-postgres-count-function%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 理解 PostgreSQL 的 count 函数的行为 on reddit"
            href="https://reddit.com/submit?url=https%3a%2f%2fsimpleapples.com%2fzh%2fposts%2funderstanding-postgres-count-function%2f&title=%e7%90%86%e8%a7%a3%20PostgreSQL%20%e7%9a%84%20count%20%e5%87%bd%e6%95%b0%e7%9a%84%e8%a1%8c%e4%b8%ba">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 理解 PostgreSQL 的 count 函数的行为 on facebook"
            href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fsimpleapples.com%2fzh%2fposts%2funderstanding-postgres-count-function%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 理解 PostgreSQL 的 count 函数的行为 on whatsapp"
            href="https://api.whatsapp.com/send?text=%e7%90%86%e8%a7%a3%20PostgreSQL%20%e7%9a%84%20count%20%e5%87%bd%e6%95%b0%e7%9a%84%e8%a1%8c%e4%b8%ba%20-%20https%3a%2f%2fsimpleapples.com%2fzh%2fposts%2funderstanding-postgres-count-function%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 理解 PostgreSQL 的 count 函数的行为 on telegram"
            href="https://telegram.me/share/url?text=%e7%90%86%e8%a7%a3%20PostgreSQL%20%e7%9a%84%20count%20%e5%87%bd%e6%95%b0%e7%9a%84%e8%a1%8c%e4%b8%ba&amp;url=https%3a%2f%2fsimpleapples.com%2fzh%2fposts%2funderstanding-postgres-count-function%2f">
            <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
                <path
                    d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share 理解 PostgreSQL 的 count 函数的行为 on ycombinator"
            href="https://news.ycombinator.com/submitlink?t=%e7%90%86%e8%a7%a3%20PostgreSQL%20%e7%9a%84%20count%20%e5%87%bd%e6%95%b0%e7%9a%84%e8%a1%8c%e4%b8%ba&u=https%3a%2f%2fsimpleapples.com%2fzh%2fposts%2funderstanding-postgres-count-function%2f">
            <svg version="1.1" xml:space="preserve" width="30px" height="30px" viewBox="0 0 512 512" fill="currentColor"
                xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape">
                <path
                    d="M449.446 0C483.971 0 512 28.03 512 62.554L512 449.446C512 483.97 483.97 512 449.446 512L62.554 512C28.03 512 0 483.97 0 449.446L0 62.554C0 28.03 28.029 0 62.554 0L449.446 0ZM183.8767 87.9921H121.8427L230.6673 292.4508V424.0079H281.3328V292.4508L390.1575 87.9921H328.1233L256 238.2489z" />
            </svg>
        </a>
    </li>
</ul>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://simpleapples.com/zh/">Zhiya&#39;s Blog</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = '复制';

        function copyingDone() {
            copybutton.innerHTML = '已复制！';
            setTimeout(() => {
                copybutton.innerHTML = '复制';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
