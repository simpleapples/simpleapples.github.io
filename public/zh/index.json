[{"content":"在大厂（就是那种用户多、数据量大、需求快速迭代的地方），如果不是对账那种一分钱不能错的业务，想着靠数据库的 UNIQUE INDEX（唯一索引）来拦重复数据，说实话，效果不一定好，伺候它的成本还很高。更好的办法是把去重的主要活儿放应用层，数据库那个唯一索引，能不用就先别用，或者想清楚了再用。\n一、 为啥我开始琢磨唯一索引这事儿？因为坑踩了 数据库唯一索引，听着挺靠谱，对吧？保证数据不重复的最后一道防线。以前我也是这么想的，表里哪个字段不让重，随手就给它来个唯一索引。\n直到被现实狠狠摩擦了。\n很久之前，当我头发还很茂密的时候，给一个千万级的表加个组合唯一索引（比如 tenant_id 和 is_deleted 这俩字段不能重复）。听着简单吧？结果呢，整个变更从头到尾折腾了几天！这期间，主从延迟跟过山车似的，时不时还得担心线上服务会不会抖一下。事儿完了我在想，就为了数据库层面这个“唯一”，搭进去这么多工夫、担这么大风险，值吗？\n还有个事儿也挺别扭。 业务上，我们都知道 user@example.com 和 USER@EXAMPLE.COM 其实是一个邮箱，你注册的时候，应用代码肯定也会把它们统一处理成小写再判断有没有重复。结果呢，数据库里的唯一索引（区分大小写）不认这个账。有时候因为一些历史数据或者旁路数据同步没做好规范化，数据库里就存了两种大小写格式的“同一个”邮箱。这时候，唯一索引它要么“眼瞎”发现不了这种业务上的重复，要么在你修数据的时候，因为它那死板的规矩，反而碍手碍脚。\n更别提业务迭代了。 比如，以前光是“邮箱唯一”就行，现在要改成“租户 ID+邮箱唯一”。好家伙，应用代码得改吧？数据库的唯一索引也得跟着 DROP 旧的 CREATE 新的吧？这两拨操作怎么配合？谁先谁后？万一中间出岔子怎么办？在大表上搞这种操作，每次都跟拆炸弹似的，提心吊胆。\n就这些事儿搞得我不得不琢磨：数据量大、并发高、需求又变得快，唯一索引这一套，是不是该重新掂量掂量了？它带来的麻烦，是不是已经比它的好处多了？\n这篇文章，就是想跟大家伙儿聊聊我的反思。\n二、 UNIQUE INDEX：我们为啥那么信它？ 在吐槽之前，咱也得公平点，说说唯一索引为啥那么招人待见，它确实有几个看上去不错的点：\n数据不跑偏的最后保险： 防止数据重复的最后一道关卡。 上手简单： 建表的时候或者后来加个 DDL，几行 SQL 就搞定了。 表结构一看就懂： Schema 里标着呢，这字段不能重。 顺便还能快点查： 反正也是个索引，按这个键查数据能快点。 这些好处，在小项目或者数据量不大、业务不复杂的时候，确实挺香。但一到大数据量+快速迭代“修罗场”，情况就变了。\n三、 大厂滤镜下的UNIQUE INDEX：那些“好处”还好使吗？ 接下来咱们挨个盘盘上面说的那些“好处”，看看在大厂这环境下，它们是不是还那么“美”。\n“最后保险”？这保险靠谱吗？保的是啥险？\n业务上的“重复”它认不全啊！就像前面说的邮箱大小写，还有手机号带不带+86，用户名清不清除特殊字符……这些业务上才认的“一样”，数据库那简单粗暴的“字节必须一样”的唯一索引根本管不过来。它防不住业务层面的“逻辑重复”。\n应用层反正要干活。 既然这些复杂的“一样不一样”都得在应用代码里判断（总不能直接把数据库报错丢给用户吧？），那应用层才是真正保证“业务数据不重复”的主力军。数据库那个唯一索引，充其量是个标准可能还跟业务不一致的“辅警”。\n分布式系统里它就是个“本地保镖”。在分布式场景下一旦分表，表内的唯一索引，管不了全局唯一性。全局唯一还得靠 ID 生成服务或者应用层的全局校验。这时候，数据库本地那点“保险”作用就更小了。\n这个“最后保险”既可能保不到点子上，覆盖面也有限，全指望它优点悬。\n“上手简单”？一次上线，一周折腾\n新表新加个唯一索引，确实就一条 SQL。但更多的时候是给已经跑了好久、数据堆成山的旧表改规则。你想给千万行的表改个唯一索引（比如从一个字段唯一改成俩字段组合唯一），可能就是几分钟的锁表！在线 DDL 工具，也只是让你不用停服务，但整个过程照样漫长、耗资源、有风险。\n敏捷？快不起来啊！在快速迭代+多区域同步+合规要求的场景下。数据库这儿一个唯一索引的变更就要卡你好几天，啥敏捷都白搭。\n所以开始那一下“简单”，跟后来改起来的“要老命”比，简直是钓鱼。\n“表结构一看就懂”？懂的可能跟实际要的不一样啊！\n唯一索引在表结构里写着，是，算是一种“技术文档”。可是“文档”可能误导人，如果这个唯一索引定义的“唯一”跟业务上实际的、更复杂的唯一规则对不上（比如大小写问题），那这份“文档”不光没用，还可能误导后来的开发。 如果改这份“文档”（就是改唯一索引）就要经历九九八十一难，那我们为啥不把业务规则好好写在真正的设计文档、Wiki 或者代码注释里呢？那些地方改起来可方便多了。\n“顺便还能快点查”？为了这点醋，才包的这顿饺子？\n这是个很常见的误解，或者说是一个被过分强调的“附加值”。如果你只是想让某个字段或某几个字段的查询快一点，你完全可以给它们建一个普普通通的、非唯一的索引（Non-Unique Index）啊！非唯一索引照样能嗖嗖地提高查询速度，而且它还没有唯一性约束带来的那些写入开销、DDL 痛苦和业务逻辑的死板限制。\n主从索引不一致，复制立马“瘫痪”：\n我见过好几次，主库的唯一索引配置更新了（比如加了个字段，或者改了约束），从库的索引没同步改。那主库那边数据一有变化（比如插了条在从库看来会重复的数据，或者主库能写进去但在从库因为有那个错误的/未更新的索引而写不进去），binlog 传到从库，咣当一下，Slave_SQL_Running: No，复制直接挂掉！这种事儿一出，数据延迟，读写分离受影响，甚至影响故障切换，你说闹不闹心？\n四、 把活儿交给应用层，专业！ 既然数据库唯一索引这么多毛病，数据唯一性这事儿，主要还得靠咱应用层自己来扛。\n应用层搞唯一性的好处，那可太多了：\n灵活、精准： 业务说啥样算重，咱就按啥样写逻辑，大小写、格式化、各种复杂条件，想咋玩咋玩。 用户体验好： 用户输错了，咱能给出明确提示，比如“这手机号注册过了，要不要直接登录？” 而不是冷冰冰的数据库错误。 效率高，先拦住： 在数据还没到数据库呢，在服务接口那层甚至网关层就给它拦下来，省得白跑一趟数据库。 接口幂等性： 这是防止重复操作的大杀器。用户手抖点了两下提交，网络不好重试了一下，应用层做好幂等，数据就不会重。这事儿唯一索引可管不了。 总结 只有当唯一索引带来的那点好处（通常是极端情况下的数据兜底），明确地、大大地超过它在大数据量+快速迭代的复杂环境里带来的各种麻烦（影响敏捷、运维痛苦）时，再考虑用它。优先把应用层的唯一性保障机制（前置校验、异步处理、幂等性、全局 ID 等等）做扎实。数据库那个唯一索引，能省则省，实在要用，也得想清楚了，当成个“特殊工具”来对待，别当成“标配”。\n","permalink":"https://simpleapples.com/zh/posts/think-twice-on-unique-key/","summary":"\u003cp\u003e在大厂（就是那种用户多、数据量大、需求快速迭代的地方），如果不是对账那种一分钱不能错的业务，想着靠数据库的 \u003ccode\u003eUNIQUE INDEX\u003c/code\u003e（唯一索引）来拦重复数据，说实话，效果不一定好，伺候它的成本还很高。更好的办法是把去重的主要活儿放应用层，数据库那个唯一索引，能不用就先别用，或者想清楚了再用。\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"一-为啥我开始琢磨唯一索引这事儿因为坑踩了\"\u003e一、 为啥我开始琢磨唯一索引这事儿？因为坑踩了\u003c/h2\u003e\n\u003cp\u003e数据库唯一索引，听着挺靠谱，对吧？保证数据不重复的最后一道防线。以前我也是这么想的，表里哪个字段不让重，随手就给它来个唯一索引。\u003c/p\u003e\n\u003cp\u003e直到被现实狠狠摩擦了。\u003c/p\u003e\n\u003cp\u003e很久之前，当我头发还很茂密的时候，给一个千万级的表加个组合唯一索引（比如 \u003ccode\u003etenant_id\u003c/code\u003e 和 \u003ccode\u003eis_deleted\u003c/code\u003e 这俩字段不能重复）。听着简单吧？结果呢，整个变更从头到尾折腾了几天！这期间，主从延迟跟过山车似的，时不时还得担心线上服务会不会抖一下。事儿完了我在想，就为了数据库层面这个“唯一”，搭进去这么多工夫、担这么大风险，值吗？\u003c/p\u003e\n\u003cp\u003e还有个事儿也挺别扭。 业务上，我们都知道 \u003ccode\u003euser@example.com\u003c/code\u003e 和 \u003ccode\u003eUSER@EXAMPLE.COM\u003c/code\u003e 其实是一个邮箱，你注册的时候，应用代码肯定也会把它们统一处理成小写再判断有没有重复。结果呢，数据库里的唯一索引（区分大小写）不认这个账。有时候因为一些历史数据或者旁路数据同步没做好规范化，数据库里就存了两种大小写格式的“同一个”邮箱。这时候，唯一索引它要么“眼瞎”发现不了这种业务上的重复，要么在你修数据的时候，因为它那死板的规矩，反而碍手碍脚。\u003c/p\u003e\n\u003cp\u003e更别提业务迭代了。 比如，以前光是“邮箱唯一”就行，现在要改成“租户 ID+邮箱唯一”。好家伙，应用代码得改吧？数据库的唯一索引也得跟着 \u003ccode\u003eDROP\u003c/code\u003e 旧的 \u003ccode\u003eCREATE\u003c/code\u003e 新的吧？这两拨操作怎么配合？谁先谁后？万一中间出岔子怎么办？在大表上搞这种操作，每次都跟拆炸弹似的，提心吊胆。\u003c/p\u003e\n\u003cp\u003e就这些事儿搞得我不得不琢磨：数据量大、并发高、需求又变得快，唯一索引这一套，是不是该重新掂量掂量了？它带来的麻烦，是不是已经比它的好处多了？\u003c/p\u003e\n\u003cp\u003e这篇文章，就是想跟大家伙儿聊聊我的反思。\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"二-unique-index我们为啥那么信它\"\u003e二、 \u003ccode\u003eUNIQUE INDEX\u003c/code\u003e：我们为啥那么信它？\u003c/h2\u003e\n\u003cp\u003e在吐槽之前，咱也得公平点，说说唯一索引为啥那么招人待见，它确实有几个看上去不错的点：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e数据不跑偏的最后保险：\u003c/strong\u003e 防止数据重复的最后一道关卡。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e上手简单：\u003c/strong\u003e 建表的时候或者后来加个 DDL，几行 SQL 就搞定了。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e表结构一看就懂：\u003c/strong\u003e Schema 里标着呢，这字段不能重。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e顺便还能快点查：\u003c/strong\u003e 反正也是个索引，按这个键查数据能快点。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e这些好处，在小项目或者数据量不大、业务不复杂的时候，确实挺香。但一到大数据量+快速迭代“修罗场”，情况就变了。\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"三-大厂滤镜下的unique-index那些好处还好使吗\"\u003e三、 大厂滤镜下的\u003ccode\u003eUNIQUE INDEX\u003c/code\u003e：那些“好处”还好使吗？\u003c/h2\u003e\n\u003cp\u003e接下来咱们挨个盘盘上面说的那些“好处”，看看在大厂这环境下，它们是不是还那么“美”。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e“最后保险”？这保险靠谱吗？保的是啥险？\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e业务上的“重复”它认不全啊！就像前面说的邮箱大小写，还有手机号带不带\u003ccode\u003e+86\u003c/code\u003e，用户名清不清除特殊字符……这些业务上才认的“一样”，数据库那简单粗暴的“字节必须一样”的唯一索引根本管不过来。它防不住业务层面的“逻辑重复”。\u003c/p\u003e\n\u003cp\u003e应用层反正要干活。 既然这些复杂的“一样不一样”都得在应用代码里判断（总不能直接把数据库报错丢给用户吧？），那应用层才是真正保证“业务数据不重复”的主力军。数据库那个唯一索引，充其量是个标准可能还跟业务不一致的“辅警”。\u003c/p\u003e\n\u003cp\u003e分布式系统里它就是个“本地保镖”。在分布式场景下一旦分表，表内的唯一索引，管不了全局唯一性。全局唯一还得靠 ID 生成服务或者应用层的全局校验。这时候，数据库本地那点“保险”作用就更小了。\u003c/p\u003e\n\u003cp\u003e这个“最后保险”既可能保不到点子上，覆盖面也有限，全指望它优点悬。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e“上手简单”？一次上线，一周折腾\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e新表新加个唯一索引，确实就一条 SQL。但更多的时候是给已经跑了好久、数据堆成山的旧表改规则。你想给千万行的表改个唯一索引（比如从一个字段唯一改成俩字段组合唯一），可能就是几分钟的锁表！在线 DDL 工具，也只是让你不用停服务，但整个过程照样漫长、耗资源、有风险。\u003c/p\u003e\n\u003cp\u003e敏捷？快不起来啊！在快速迭代+多区域同步+合规要求的场景下。数据库这儿一个唯一索引的变更就要卡你好几天，啥敏捷都白搭。\u003c/p\u003e\n\u003cp\u003e所以开始那一下“简单”，跟后来改起来的“要老命”比，简直是钓鱼。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e“表结构一看就懂”？懂的可能跟实际要的不一样啊！\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e唯一索引在表结构里写着，是，算是一种“技术文档”。可是“文档”可能误导人，如果这个唯一索引定义的“唯一”跟业务上实际的、更复杂的唯一规则对不上（比如大小写问题），那这份“文档”不光没用，还可能误导后来的开发。 如果改这份“文档”（就是改唯一索引）就要经历九九八十一难，那我们为啥不把业务规则好好写在真正的设计文档、Wiki 或者代码注释里呢？那些地方改起来可方便多了。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003e“顺便还能快点查”？为了这点醋，才包的这顿饺子？\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e这是个很常见的误解，或者说是一个被过分强调的“附加值”。如果你只是想让某个字段或某几个字段的查询快一点，你完全可以给它们建一个普普通通的、非唯一的索引（Non-Unique Index）啊！非唯一索引照样能嗖嗖地提高查询速度，而且它还没有唯一性约束带来的那些写入开销、DDL 痛苦和业务逻辑的死板限制。\u003c/p\u003e","title":"唯一索引这玩意儿，真得好好掂量掂量"},{"content":"最近羊了个羊比较火，但是难度非常高，打了几天几十盘都通不过，所以犯了职业病，想看看有没有科技手段，实践有效后整理出来方便大家科技通关。\n原理 科技通关的原理比较简单，游戏每天都有两幅地图，第一个地图是练手的可以无脑通过，第二个是难度爆表的版本，所以只要能够把第二个地图改成第一个，就可以实现通关。\n准备工作 实现科技通关需要一个 Web 调试代理 App，在 iOS 上可以用 HTTP Catcher（需要内购），Storm Sniffer（三天试用），Android 上也可以找类似的软件。以 HTTP Catcher 为例，安装好之后需要安装并启用 Root 证书，以实现 HTTPS 解密。\n步骤 首先需要启动 HTTP Catcher，打开羊了个羊进入游戏开始挑战，然后返回 HTTP Catcher，筛选 JSON 类型的请求，找到包含 map_info_ex 的请求。\n点进这个请求里的 Response，可以看到返回内容里有个 map_md5 的列表，里面有两个 md5 值，分别对应第一个地图和第二个地图，我们要做的就是把返回值里第二个地图的 md5 替换成第一个的。\n接下来返回上一个界面，左滑选择更多，新建重写，在弹出的界面中新增规则。\n按下图的选择 Response 和 Body，将第二张地图的 md5（可以提前复制好）填入 Find，将第二张地图的 md5 填入 Replace，然后一路保存。\n接下来重新启动 HTTP Catcher，回到羊了个羊重新开始游戏，第二关就变成和第一关一样简单的地图了。\n","permalink":"https://simpleapples.com/zh/posts/yang-le-ge-yang-crack/","summary":"\u003cp\u003e最近羊了个羊比较火，但是难度非常高，打了几天几十盘都通不过，所以犯了职业病，想看看有没有科技手段，实践有效后整理出来方便大家科技通关。\u003c/p\u003e\n\u003ch1 id=\"原理\"\u003e原理\u003c/h1\u003e\n\u003cp\u003e科技通关的原理比较简单，游戏每天都有两幅地图，第一个地图是练手的可以无脑通过，第二个是难度爆表的版本，所以只要能够把第二个地图改成第一个，就可以实现通关。\u003c/p\u003e\n\u003ch1 id=\"准备工作\"\u003e准备工作\u003c/h1\u003e\n\u003cp\u003e实现科技通关需要一个 Web 调试代理 App，在 iOS 上可以用 HTTP Catcher（需要内购），Storm Sniffer（三天试用），Android 上也可以找类似的软件。以 HTTP Catcher 为例，安装好之后需要安装并启用 Root 证书，以实现 HTTPS 解密。\u003c/p\u003e\n\u003ch1 id=\"步骤\"\u003e步骤\u003c/h1\u003e\n\u003cp\u003e首先需要启动 HTTP Catcher，打开羊了个羊进入游戏开始挑战，然后返回 HTTP Catcher，筛选 JSON 类型的请求，找到包含 map_info_ex 的请求。\u003c/p\u003e\n\u003ccenter\u003e\u003cimg style=\"margin: 0 10px\" src=\"/images/20220920_01.png\" width=\"200\"/\u003e\u003c/center\u003e\n\u003cp\u003e点进这个请求里的 Response，可以看到返回内容里有个 map_md5 的列表，里面有两个 md5 值，分别对应第一个地图和第二个地图，我们要做的就是把返回值里第二个地图的 md5 替换成第一个的。\u003c/p\u003e\n\u003ccenter\u003e\u003cimg style=\"margin: 0 10px\" src=\"/images/20220920_02.png\" width=\"200\"/\u003e\u003c/center\u003e\n\u003cp\u003e接下来返回上一个界面，左滑选择更多，新建重写，在弹出的界面中新增规则。\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/images/20220920_03.png\"\u003e\u003c/p\u003e\n\u003cp\u003e按下图的选择 Response 和 Body，将第二张地图的 md5（可以提前复制好）填入 Find，将第二张地图的 md5 填入 Replace，然后一路保存。\u003c/p\u003e\n\u003ccenter\u003e\u003cimg style=\"margin: 0 10px\" src=\"/images/20220920_04.png\" width=\"200\"/\u003e\u003c/center\u003e\n\u003cp\u003e接下来重新启动 HTTP Catcher，回到羊了个羊重新开始游戏，第二关就变成和第一关一样简单的地图了。\u003c/p\u003e\n\u003ccenter\u003e\u003cimg style=\"margin: 0 10px\" src=\"/images/20220920_05.png\" width=\"200\"/\u003e\u003c/center\u003e","title":"羊了个羊科技通关攻略"},{"content":"经过这些年的发展，Go 语言已经成为一门被广泛使用在各个领域的编程语言。从 k8s、docker 等基础组件，到业务领域的微服务，都可以用 Go 构建。在构建这些 Go 项目时，采用哪种架构模式和代码布局，是一个仁者见仁智者见智的事情。有 Java Spring 经验的可能会采用 MVC 模式，有 Python Flask 经验的可能会采用 MTV 模式。加上 Go 语言领域并没有出现主流的企业级开发框架，很多项目甚至没有明确的架构模式。\nClean Architecture Clean Architecture 是 Uncle Bob 提出的适用于复杂业务系统的架构模式，其核心思想是将业务复杂度与技术复杂度解藕，相比于 MVC、MTV 等模式，Clean Architecture 除了进行分层，还通过约定依赖原则，明确了与外部依赖的交互方式，以及外部依赖与业务逻辑的边界。感兴趣的朋友可以直接阅读作者原文https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html。\n由于 Clean Architecture 具有脱离语言和框架的灵活性，作者在提出时也没有规定实现细节，给 Clean Architecture 的落地带来了困难，接下来以一个例子来说明如何在 Go 项目中应用 Clean Architecture 的思想。\n布局 作为一个 Go 项目，不管用哪种架构模式，建议都建立 app 和 scripts 这两个路径。app 存放启动 Go 项目的入口文件，通常是 main.go。而 scripts 可以放一些构建和部署时候用到的脚本。\nclean_architecture_demo ├── README.md ├── app │ └── main.go ├── scripts │ ├── build.sh │ └── run.sh ├── go.mod ├── go.sum └── usecases 接下来是代码部分，分为 entities、usecases、adapters 三个部分。\nentities：存储领域实体。用一个博客系统举例，领域实体可能有用户（user）和文章（article） usecases：存储业务逻辑。用博客系统举例，可能会有用户相关的业务逻辑（signup_user、signin_user、add_user、delete_user)和文章相关的业务逻辑（add_article、show_article、delete_article） adapters：存储适配器逻辑。适配器是连接业务逻辑与外部依赖的层，博客以 Web 形式提供服务，就需要一个 http_adapter 来封装 Web 服务；同时保存文章到数据库，需要封装一个 db_adapter 来连接。 下面是项目的布局结构。\nclean_architecture_demo ├── README.md ├── adapters │ ├── api │ ├── db │ └── log ├── app │ └── main.go ├── scripts │ ├── build.sh │ └── run.sh ├── entities │ ├── article.go │ └── user.go ├── go.mod ├── go.sum └── usecases 数据流向 用一个查询文章的请求来描述一下调用链路。\n用户通过 HTTP 服务的调用 WebAdapter 的 ShowArticleHandler 方法 由于是文章相关的逻辑，ShowArticleHandler 调用 ArticleUsecase 的 ShowArticle 方法 需要从 DB 中查询文章，ArticleUsecase 会调用 DBAdapter 的 GetArticle 方法 DBAdapter 的 GetArticle 从 MySQL 中查询出文章内容返回给 ArticleUsecase ArticleUsecase 返回给 WebAdapter WebAdapter 通过 HTTP 服务返回给用户 代码示例 为了更清晰的说分层和架构，我在 Github 上发布了一个示例项目，感兴趣的朋友可以直接去看源码：https://github.com/simpleapples/go-clean-architecture\n结论 由于 Clean Architecture 没有规定实现细节，所以上述的分层和布局方式只是一种参考，还有众多的实践方式。例如 Adapter 层可以根据外部依赖的类型细分成平行的 Presenter+Gateway 层，在复杂项目中，更细致的分层可以把代码拆的更细致，大家可以根据自己的项目规模来调整分层和布局，这里就不做赘述了。\n","permalink":"https://simpleapples.com/zh/posts/go-project-with-clean-architecture/","summary":"\u003cp\u003e经过这些年的发展，Go 语言已经成为一门被广泛使用在各个领域的编程语言。从 k8s、docker 等基础组件，到业务领域的微服务，都可以用 Go 构建。在构建这些 Go 项目时，采用哪种架构模式和代码布局，是一个仁者见仁智者见智的事情。有 Java Spring 经验的可能会采用 MVC 模式，有 Python Flask 经验的可能会采用 MTV 模式。加上 Go 语言领域并没有出现主流的企业级开发框架，很多项目甚至没有明确的架构模式。\u003c/p\u003e\n\u003ch1 id=\"clean-architecture\"\u003eClean Architecture\u003c/h1\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/images/20211212_01.png\"\u003e\u003c/p\u003e\n\u003cp\u003eClean Architecture 是 Uncle Bob 提出的适用于复杂业务系统的架构模式，其核心思想是将业务复杂度与技术复杂度解藕，相比于 MVC、MTV 等模式，Clean Architecture 除了进行分层，还通过约定依赖原则，明确了与外部依赖的交互方式，以及外部依赖与业务逻辑的边界。感兴趣的朋友可以直接阅读作者原文\u003ca href=\"https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html\"\u003ehttps://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html\u003c/a\u003e。\u003c/p\u003e\n\u003cp\u003e由于 Clean Architecture 具有脱离语言和框架的灵活性，作者在提出时也没有规定实现细节，给 Clean Architecture 的落地带来了困难，接下来以一个例子来说明如何在 Go 项目中应用 Clean Architecture 的思想。\u003c/p\u003e\n\u003ch1 id=\"布局\"\u003e布局\u003c/h1\u003e\n\u003cp\u003e作为一个 Go 项目，不管用哪种架构模式，建议都建立 app 和 scripts 这两个路径。app 存放启动 Go 项目的入口文件，通常是 main.go。而 scripts 可以放一些构建和部署时候用到的脚本。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eclean_architecture_demo\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e├── README.md\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e├── app\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e│   └── main.go\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e├── scripts\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e│   ├── build.sh\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e│   └── run.sh\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e├── go.mod\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e├── go.sum\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e└── usecases\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e接下来是代码部分，分为 entities、usecases、adapters 三个部分。\u003c/p\u003e","title":"基于Clean Architecture的Go项目架构实践"},{"content":"背景 在一个古老的系统中，有这样一段代码：\nscope = dict(globals(), **locals()) exec( \u0026#34;\u0026#34;\u0026#34; global_a = 123 def func_a(): print(global_a) \u0026#34;\u0026#34;\u0026#34; , scope) exec(\u0026#34;func_a()\u0026#34;, scope) 第一段用户代码定义了函数，第二段用户代码执行函数（不要问为什么这么做，因为用户永远是正确的）。第一个代码段执行后，func_a 和 global_a 都会被加入作用域 scope，由于第二个代码段也使用同一个 scope，所以第二个代码段调用 func_a 是可以正确输出 123 的。\n但是使用 exec 执行用户代码毕竟不优雅，也很危险，于是把 exec 函数封装在了一个 Python 沙箱环境中（简单理解就是另一个 Python 服务，将 code 和 scope 传给这个服务后，服务会在沙箱环境调用 exec(code,scope)执行代码），相当于每一次对 exec 调用都替换成了对沙箱服务的 RPC 请求。\n于是代码变成了这个样子：\nscope = dict(globals(), **locals()) scope = call_sandbox( \u0026#34;\u0026#34;\u0026#34; global_a = 123 def func_a(): print(global_a) \u0026#34;\u0026#34;\u0026#34; , scope) call_sandbox(\u0026#34;func_a()\u0026#34;, scope) 作用域跨服务传递问题 由于多次 RPC 调用需要使用同一个作用域，所以沙箱服务返回了新的 scope，以保证下次调用时作用域不会丢失。但是执行代码会发现第二次 call_sandbox 调用时候，会返回错误：\nglobal name \u0026lsquo;global_a\u0026rsquo; is not defined\n首先怀疑第一次调用后 scope 没有更新，但是如果 scope 没有更新，应该会报找不到 func_a 才对，这个报错说明，第二次调用时候，作用域里的 func_a 是存在的，但是 func_a 找不到变量 global_a。通过输出第二次 call_sandbox 前的 scope，会发现 global_a 和 func_a 都是存在的：\nprint(scope.keys()) # [\u0026#39;__name__\u0026#39;, \u0026#39;__doc__\u0026#39;, \u0026#39;__package__\u0026#39;, \u0026#39;__loader__\u0026#39;, \u0026#39;__spec__\u0026#39;, \u0026#39;__file__\u0026#39;, \u0026#39;__cached__\u0026#39;, # \u0026#39;__builtins__\u0026#39;, \u0026#39;global_a\u0026#39;, \u0026#39;func_a\u0026#39;] call_sandbox(\u0026#34;func_a()\u0026#34;, scope) 证明在第二次 call_sandbox 时，scope 被正确的传入了，没有报找不到 func_a 也印证了这个结论。在 func_a 里获取并输出一下 globals()和 locals()：\ndef func_a(): inner_scope = dict(globals(), **locals() print(inner_scope.keys()) # [\u0026#39;__builtins__\u0026#39;] 可以看到在 func_a 外作用域是正常的，但是 func_a 内的作用域就只有builtins了，相当于作用域被清空了。猜测是函数的 caller 指向的是沙箱环境内的作用域，当 scope 回传回来后，caller 没有更新，所以在函数内找不到函数外的作用域，查看一下 Python 函数的魔术方法：\n发现有一个globals变量，指向的就是所在作用域，相当于函数的 caller，通过如下代码验证调用沙箱服务后的 scope 里的 func_a 的globals是否和当前作用域的一样：\nscope[\u0026#34;func_a\u0026#34;].__globals__ == globals() # False 确实不一样，接下来试试把 scope[\u0026ldquo;func_a\u0026rdquo;].globals置为 globals()，应该就可以跑通了。\n优化作用域更新逻辑 到这里问题的根源已经搞清了：\n第一个 exec 语句和第二个 exec 语句分别在 Python 服务 A 和 B 中执行，第一个 exec 语句中定义的 func_a 所在的作用域是服务 A（func_a.globals == A） 在 scope 回传到服务 B 后，global_a 和 func_a 被拷贝到了服务 B 所在作用域，但是 func_a.globals还是指向服务 A 的作用域，所以出现可以调用到 func_a 但在 func_a 里找不到 global_a 将 func_a.globals置为 B，就可以使代码在服务 B 正确执行 如文档所述，函数globals是一个只读变量，所以不能直接赋值，需要通过拷贝函数的方式实现，定义一个拷贝函数的方法：\nimport copy import types import functools def copy_func(f, globals=None, module=None): if globals is None: globals = f.__globals__ g = types.FunctionType(f.__code__, globals, name=f.__name__, argdefs=f.__defaults__, closure=f.__closure__) g = functools.update_wrapper(g, f) if module is not None: g.__module__ = module return g 更新调用沙箱后回传的 scope，如果 scope 中的 value 是一个 function，就通过复制的方式更新它的globals为 scope：\nscope = dict(globals(), **locals()) scope = call_sandbox( \u0026#34;\u0026#34;\u0026#34; global_a = 123 def func_a(): print(global_a) \u0026#34;\u0026#34;\u0026#34; , scope) for k, v in scope: if isinstance(v, types.FunctionType): scope[k] = copy_func(v, scope, __name__) call_sandbox(\u0026#34;func_a()\u0026#34;, scope) 重新运行，两个 call_sandbox 都可以正常执行，问题解决。\n参考文档 https://docs.python.org/3/reference/datamodel.html\nhttps://stackoverflow.com/questions/49076566/override-globals-in-function-imported-from-another-module\nhttps://stackoverflow.com/questions/2904274/globals-and-locals-in-python-exec/2906198\n","permalink":"https://simpleapples.com/zh/posts/python-cross-scope-issue/","summary":"\u003ch1 id=\"背景\"\u003e背景\u003c/h1\u003e\n\u003cp\u003e在一个古老的系统中，有这样一段代码：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003escope \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e dict(globals(), \u003cspan style=\"color:#f92672\"\u003e**\u003c/span\u003elocals())\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eexec(\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;\u0026#34;\u0026#34;\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#e6db74\"\u003eglobal_a = 123\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#e6db74\"\u003edef func_a():\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#e6db74\"\u003e    print(global_a)\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;\u0026#34;\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e, scope)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eexec(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;func_a()\u0026#34;\u003c/span\u003e, scope)\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e第一段用户代码定义了函数，第二段用户代码执行函数（不要问为什么这么做，因为用户永远是正确的）。第一个代码段执行后，func_a 和 global_a 都会被加入作用域 scope，由于第二个代码段也使用同一个 scope，所以第二个代码段调用 func_a 是可以正确输出 123 的。\u003c/p\u003e\n\u003cp\u003e但是使用 exec 执行用户代码毕竟不优雅，也很危险，于是把 exec 函数封装在了一个 Python 沙箱环境中（简单理解就是另一个 Python 服务，将 code 和 scope 传给这个服务后，服务会在沙箱环境调用 exec(code,scope)执行代码），相当于每一次对 exec 调用都替换成了对沙箱服务的 RPC 请求。\u003c/p\u003e\n\u003cp\u003e于是代码变成了这个样子：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003escope \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e dict(globals(), \u003cspan style=\"color:#f92672\"\u003e**\u003c/span\u003elocals())\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003escope \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e call_sandbox(\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;\u0026#34;\u0026#34;\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#e6db74\"\u003eglobal_a = 123\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#e6db74\"\u003edef func_a():\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#e6db74\"\u003e    print(global_a)\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;\u0026#34;\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e, scope)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ecall_sandbox(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;func_a()\u0026#34;\u003c/span\u003e, scope)\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch1 id=\"作用域跨服务传递问题\"\u003e作用域跨服务传递问题\u003c/h1\u003e\n\u003cp\u003e由于多次 RPC 调用需要使用同一个作用域，所以沙箱服务返回了新的 scope，以保证下次调用时作用域不会丢失。但是执行代码会发现第二次 call_sandbox 调用时候，会返回错误：\u003c/p\u003e","title":"Python跨服务传递作用域的坑"},{"content":"我住的小区使用了一个叫守望领域的智能门禁系统，可以通过手机 App 开小区门禁和单元门，但是用 App 开门需要经过四五步：打开 App→ 进入开门界面 → 找到需要开的门 → 点击开门。\n加上戴口罩时候解锁手机需要输入密码，导致整个流程非常耗时，经常需要站在小区门口和单元门口操作半天，有一段时间我甚至养成了携带实体门禁卡的习惯，实体门禁卡开门要快很多。\n最近又开始忘带门禁卡，苦恼之余发现 iOS 在锁屏界面右划可以免解锁直接进入 spotlight 界面，这个界面可以添加捷径，如果能写一个捷径去调用守望领域 App 的 API 开门，就可以实现手机免解锁一键开门。\n查找 API 首先需要通过 Charles 之类的软件查找 App 调用的 API，配置 Charles 查看 App 请求的方式不再赘述，Google 一下可以看到很多教程。直接看结果 Charles 的结果，可以看到 api.lookdoor.cn 是这个软件所请求的 API 域名。\n打开软件发的请求非常多，经过操作和请求的对比可以看到，发送开门指令调用的 API 是：/func/hjapp/house/v1/pushOpenDoorBySn.json?equipmentId=xxxxxx 这个路径。\n详细查看这个请求可以发现，equipmentId 指的就是小区门的 Id，接口使用 cookie 做认证，只要将 cookie 带上就可以模拟开门指令。\n第一次尝试 打开 iOS 捷径 App，创建一个新捷径，App 调用 API 使用了 POST 请求，搜索 Get contents of 这个动作来实现发送 POST 请求。\n通过 Charles 找到要开的门的 URL 填入，Method 选择 POST，Headers 里填入 Cookie 进行认证，内容直接从 Charles 复制就可以，尝试运行，it works!\n接下来把这个捷径添加到 Spotlight 界面，锁屏界面右划点一下，就可以实现一键开小区门禁，和打开 App 的四五步操作相比，确实省时省力。拿着新配好的捷径去上班，下班回到小区想试一把一键开门，结果又被困到门口了，上午还正常的捷径竟然失效了，打开一看 API 报登录超时，有可能是 Cookie 里的 SESSION_ID 过期了。\n分析登录过程 再次用 Charles 抓包，分析登录相关的 API，会发现主要是这两个：\n/func/hjapp/user/v2/getPasswordAndKey.json：获取 AES Key 的 API /func/hjapp/user/v2/login.json?password=xxxxxx：登录 API 通过分析，用时序图来表示这部分的交互逻辑：\n登录过程清楚了，但是其中使用 AES_KEY 对密码进行加密的配置还是不清楚的，使用一个工具来尝试通过密文和 AES_KEY 来解密：http://tool.chacuo.net/cryptaes\n输入密钥和密文，使用各种配置进行解密，当能够解出内容的时候，证明我们找到了加密的配置，可以看到 BlockSize=128，padder 使用的是 pkcs7padding，加密模式是 ECB。解密出来的字符并不是我们的密码，看着像是 md5 过的，用 echo -n xxxxxx | md5sum 把密码 md5 一下，对上了。看来服务端校验的是单次 md5 后的密码。\n到这里登录逻辑已经搞清了，但是 iOS 捷径无法实现 AES 加密，单纯依托捷径来实现开门已经不可行了，需要搭建一个后端服务来计算密文。既然躲不过麻烦要搭建服务，不如把登录、开门整个流程都放在服务上，这样 iOS 捷径只需要一个请求就可以完成开门动作了。\n考虑到登录开门的逻辑很简单，也就是 3 个 HTTP 请求+AES 加密，直接在裸服务器上从 0 搭建步骤多成本高，要自己申请虚机、部署 HTTP Server、Web App，还需要申请 SSL 证书，不仅初次搭建要搞个一两天，后续对机器和证书的维护也需要大量时间，成本极高。\n最好是有服务能直接托管一段 Python 代码，第一时间想到的是 Leancloud，一个 Serverless 服务提供商，但是实操过程中发现，由于政策要求 Leancloud 已经不提供域名了，绑定自己的域名也需要进行备案。这意味着只能选择一家海外 Serverless 服务商，看来看去 AWS Lambda 应该可以满足要求，试一下。\n使用 AWS Lambda 搭建服务 AWS Lambda 是一个 Serverless 服务，可以直接托管一段函数，省去配置服务和基础设施的麻烦。搭建一个 Python 的 Serverless 服务需要准备这么几件事：\n新建函数，编写代码 添加 API Gateway Trigger，确保函数可以通过 HTTP 请求调用 配置函数的运行环境，增加一个层（Layer），这个层里打包进 AES 加密需要的 cryptography 和 HTTP 请求需要的 requests 1. 函数代码 首先上代码，需要填写自己的手机号、md5 后的密码、设备 ID（可以用 Charles 获取）等字段，粘贴到 Lambda 的在线编辑器中。\nimport json import requests import base64 import urllib.parse from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes from cryptography.hazmat.primitives import padding PHONE = \u0026#39;\u0026#39; PASSWORD_MD5 = \u0026#39;\u0026#39; DEVICE_ID = \u0026#39;\u0026#39; def encrypt(key, msg): cipher = Cipher(algorithms.AES(str.encode(key)), modes.ECB()) encryptor = cipher.encryptor() padder = padding.PKCS7(128).padder() msg = padder.update(str.encode(msg)) + padder.finalize() ct = encryptor.update(msg) + encryptor.finalize() return base64.b64encode(ct) def lambda_handler(event, context): resp = requests.post(\u0026#39;https://api.lookdoor.cn:443/func/hjapp/user/v2/getPasswordAesKey.json?\u0026#39;) cookie = resp.headers[\u0026#39;set-cookie\u0026#39;] aes_key = resp.json()[\u0026#39;data\u0026#39;][\u0026#39;aesKey\u0026#39;] password_encypted = urllib.parse.quote_plus(encrypt(aes_key, PASSWORD_MD5)) url = f\u0026#39;https://api.lookdoor.cn:443/func/hjapp/user/v2/login.json?password={password_encypted}\u0026amp;deviceId={DEVICE_ID}\u0026amp;loginNumber={PHONE}\u0026amp;equipmentFlag=1\u0026#39; requests.post(url, headers={\u0026#39;cookie\u0026#39;: cookie}) equipment_id = event[\u0026#39;queryStringParameters\u0026#39;][\u0026#39;equipment_id\u0026#39;] url = f\u0026#39;https://api.lookdoor.cn:443/func/hjapp/house/v1/pushOpenDoorBySn.json?equipmentId={equipment_id}\u0026#39; resp = requests.post(url, headers={\u0026#39;cookie\u0026#39;: cookie}) return resp.json() 代码首先通过 API 获取 AES_KEY 和 SESSION_ID，然后使用 AES_KEY 对密码进行加密，接下来调用登录接口将获取的 SESSION_ID 绑定到当前账户，接下来根据请求传入的设备 ID（门的 ID）来发送开门指令。\n点击 Deploy 部署，然后运行测试，会出现超时的报错，这是因为 Lambda 函数默认的执行器内存大小是 128MB，超时时间是 3s，在配置页面把内存改大一些，超时时间设置为 10s 就可以了。\n2. 添加 API Gateway Trigger 一个 Lambda 函数可以被多种形式触发执行，因为要使用捷径通过 HTTP 请求调用，所以加一个 API Gateway Trigger，添加后会自动为函数生成一个 URL，通过这个 URL 就可以直接调用函数。\n3. 添加包含依赖的 Layer 代码中使用了 requests 和 cryptography 这两个第三方库，Lambda 不支持使用 pip 直接安装这些依赖，而是需要我们在把依赖打成 zip 包上传成为容器的一层 Layer，添加到函数镜像中。需要注意的是，Lambda 函数执行的环境是 Linux，对于 cryptography 这个库需要打包 Linux 版的才可以正常使用。\n由于日常使用的是 Mac，所以在 AWS 上申请一台 Ubuntu 20 的 EC2 实例，登录实例后使用如下命令安装依赖，并打包成 zip 文件：\nmkdir python pip install -t python cryptography pip install -t python requests zip -r python/* 在 AWS 上创建一个新的 Layer，并将生成的 python.zip 上传到 Layer 上。尝试通过 URL 访问写好的 Lambda 函数，可以看到开门指令已经成功下发。\n配置 iOS 捷径 打开 iOS 捷径 App，创建一个新捷径，搜索 Get contents of 这个动作，填入 Lambda 函数的 URL 和门的 ID。由于 API Gateway 并没有配置认证，所以其他参数默认即可。如果有安全方面的顾虑，可以自己实现一个简单的 Token 认证或添加 Lambda 提供的 JWT 认证。点击执行，接口返回成功，证明整个流程已经跑通，以后就可以用这个捷径给自己和外卖小哥开门了。\n总结 一开始本想用自定义一个 iOS 捷径的方式来实现一键开门禁，但为了实现 SESSION_ID 自动更新，不得不基于 AWS Lambda 搭了一个后端服务来模拟 App 的行为，所幸 AWS Lambda 提供了低成本的构建方案，包括搭建服务和配置 SSL 证书都可以几乎 0 成本的完成，免费套餐政策也能让这个服务长期跑着而不产生任何实际花费。\n","permalink":"https://simpleapples.com/zh/posts/one-click-open-door-based-on-aws-lambda-and-ios-shortcut/","summary":"\u003cp\u003e我住的小区使用了一个叫守望领域的智能门禁系统，可以通过手机 App 开小区门禁和单元门，但是用 App 开门需要经过四五步：打开 App→ 进入开门界面 → 找到需要开的门 → 点击开门。\u003c/p\u003e\n\u003ccenter\u003e\u003cimg style=\"margin: 0 10px\" src=\"/images/20211019_01.png\" width=\"200\"/\u003e\u003cimg style=\"margin: 0 10px\" src=\"/images/20211019_02.png\" width=\"200\"/\u003e\u003cimg style=\"margin: 0 10px\" src=\"/images/20211019_03.png\" width=\"200\"/\u003e\u003c/center\u003e\n\u003cp\u003e加上戴口罩时候解锁手机需要输入密码，导致整个流程非常耗时，经常需要站在小区门口和单元门口操作半天，有一段时间我甚至养成了携带实体门禁卡的习惯，实体门禁卡开门要快很多。\u003c/p\u003e\n\u003cp\u003e最近又开始忘带门禁卡，苦恼之余发现 iOS 在锁屏界面右划可以免解锁直接进入 spotlight 界面，这个界面可以添加捷径，如果能写一个捷径去调用守望领域 App 的 API 开门，就可以实现手机免解锁一键开门。\u003c/p\u003e\n\u003ccenter\u003e\u003cimg src=\"/images/20211019_04.gif\" width=\"300\"/\u003e\u003c/center\u003e\n\u003ch1 id=\"查找-api\"\u003e查找 API\u003c/h1\u003e\n\u003cp\u003e首先需要通过 Charles 之类的软件查找 App 调用的 API，配置 Charles 查看 App 请求的方式不再赘述，Google 一下可以看到很多教程。直接看结果 Charles 的结果，可以看到 api.lookdoor.cn 是这个软件所请求的 API 域名。\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/images/20211019_05.png\"\u003e\u003c/p\u003e\n\u003cp\u003e打开软件发的请求非常多，经过操作和请求的对比可以看到，发送开门指令调用的 API 是：/func/hjapp/house/v1/pushOpenDoorBySn.json?equipmentId=xxxxxx 这个路径。\u003c/p\u003e\n\u003cp\u003e详细查看这个请求可以发现，equipmentId 指的就是小区门的 Id，接口使用 cookie 做认证，只要将 cookie 带上就可以模拟开门指令。\u003c/p\u003e\n\u003ch1 id=\"第一次尝试\"\u003e第一次尝试\u003c/h1\u003e\n\u003cp\u003e打开 iOS 捷径 App，创建一个新捷径，App 调用 API 使用了 POST 请求，搜索 Get contents of 这个动作来实现发送 POST 请求。\u003c/p\u003e","title":"利用AWS Lambda和iOS捷径实现手机一键开小区门禁"},{"content":"在Understanding Real-World Concurrency Bugs in Go这篇论文中，几名研究人员分析了常见的Go并发bug，并在最流行的几个Go开源项目中进行了验证。本文梳理了论文中提到的常见的bug并给出解决方法的分析。\n论文中对bugs进行了分类，分为阻塞式和非阻塞式两种： 阻塞式：goroutine发生阻塞无法继续执行（例如死锁） 非阻塞式：不会阻塞执行，但存在潜在的数据冲突（例如并发写）\n阻塞式bug 阻塞式bug发生的根因有两种，一种是共享内存（例如卡在了意图保护共享内存的锁操作上），一种是消息传递（比如等待chan）。同时研究发现共享内存和消息传递导致的bug数量不想上下，但是共享这种方法的使用量比消息传递使用的更频繁，所以也得出了共享内存方式更不容易导致bug的结论。\n读写锁优先级导致的死锁 在Go中的写锁优先级高于读锁优先级，假设一个goroutine（goroutine A）连续获取两次读锁，而另一个goroutine（goroutine B）在gouroutine A两次获取读锁中间获取了写锁，就会导致死锁的发生。论文中没有针对这个bug给出示例代码，我写了一个简单的代码示意一下。\nfunc gouroutine1() { m.RLock() m.RLock() } func gouroutine2() { m.WLock() } f1和f2都在goroutine中执行，当f1执行完第一个l.RLock()语句后，假设这时f2的m.WLock执行，由于写锁是排它的，WLock本身被f1的第一个m.RLock()阻塞，写锁操作本身又会阻塞f1中的第二个m.RLock\nWaitGroup误用导致的死锁 这种情况就是比较典型的WaitGroup的误用了，提前执行group.Wait()会导致部分group.Done()无法执行到，进而导致程序被阻塞。\nvar group sync.WaitGroup group.Add(len(pm.plugins)) for _, p := range pm.plugins { go func(p *plugin) { defer group.Done() } group.Wait() // blocked } // group.Wait() should be here for循环内的group.Wait()执行到的时候，循环内的部分goroutine还没有被创建出来，其中的group.Done()也就永远没法执行到，所以会导致永远阻塞在这一句，正确的写法是将group.Wait()移到for循环外。\nChannel的误用 Channel是go支持并发的一个非常重要的特性，Channel虽然在很多场景下非常解决问题，但是误用也是不容易发现的。\nfunc goroutine1() { m.Lock() ch \u0026lt;- request // blocked m.Unlock() } func goroutine2() { for { m.Lock() // 阻塞 m.Unlock() request \u0026lt;- ch } } 这段代码的业务语义是goroutine1会通过ch接收goroutine2发送的消息，但是当goroutine1执行到ch \u0026lt;- request时候会阻塞并等待ch，此时由于goroutine1没有释放锁，goroutine2的m.Lock()也会阻塞，形成死锁。\n特殊库的误用 hctx, hcancel := context.WithCancel(ctx) if timeout \u0026gt; 0 { hctx, hcancel = context.WithTimeout(ctx, timeout) } 除了显式的使用channel，go提供了一些lib来在goroutine之间传递消息，上面代码在执行hctx, hcancel := context.WithCancel(ctx)时会创建一个goroutine出来，而当timeout\u0026gt;0时又回创建新的channel赋给同一个变量hcancel，这会导致第一行创建出的channel不会被关闭，也不能再给这个channel发消息。\n非阻塞式bug 和阻塞式bug类似，非阻塞式bug也由共享内存和消息传递引起：当试图保护一个共享变量失败时候，或消息传递使用不当时候，都可能造成非阻塞式的bug。\n匿名函数 虽然论文中将这一类错误归结为匿名函数的不正确使用，但实际上产生这类bug的原因是工程师忽略了实际上在跨goroutine共享的变量。\nfor i := 17; i \u0026lt;= 21; i++ { // write go func() { /* Create a new goroutine */ apiVersion := fmt.Sprintf(\u0026#34;v1.%d\u0026#34;, i) // read ... }() } 如这段代码（也经常出现在面试中），由于变量i在匿名函数构建出的goroutine和主goroutine共享，又不能保证goroutine什么时候执行，所以goroutine中拿到的i并不确定（大概率这几个循环创建出的goroutine拿到的都是21）。\nWaitGroup的误用 func (p *peer) send() { p.mu.Lock() defer p.mu.Unlock() switch p.status { case idle: go func() { p.wg.Add(1) ... p.wg.Done() }() case stopped: } } func (p * peer) stop() { p.mu.Lock() p.status = stopped p.mu.Unlock() p.wg.Wait() } 上面这段代码中，由于不能保证send方法的goroutine什么时候执行，所以可能导致stop函数的p.wg.Wait()在send函数的p.wg.Add(1)之前执行。\n特殊库的误用 诸如context这样被设计会在多个goroutine间传递数据的库，在使用时也需要特别注意，可能会导致数据竞争。\nChannel的误用 select { case \u0026lt;- c.closed: default: close(c.closed) } 由于default语句可能被多次触发，导致一个channel可能被多次关闭，进而造成panic。\nticker := time.NewTicker() for{ f() // heavy function select { case \u0026lt;- stopCh: return case \u0026lt;- ticker: } } 对于上面这段代码，当f是一个耗时函数时，很可能出现一次for循环后stopCh和ticker两个case同时满足，这时是没法确认先进哪个case的。\n特殊库的误用 timer := time.NewTimer(0) if dur \u0026gt; 0 { timer = time.NewTimer(dur) } select { case \u0026lt;- timer.C: case \u0026lt;- ctx.Done(): return nil } 上面这段代码中，第一行创建的timer由于超时时间是0，所以会立刻触发select中的第一个case，导致和期望不符合的行为。\n总结 Go的特性使得线程的创建和数据传递都非常容易，但是容易的背后线程间通信的那些坑依然是存在的，论文认为go的消息传递机制会导致更多的bug出现。在我看来，go的消息传递机制相比于传统的共享内存机制，相当于多了一层逻辑层面的封装，这种特性有时会让传统的多线程编程经验不能直接发挥价值，但是只要把握住底层的机制，可以很快积累基于go的语言特性的并发编程经验。\n","permalink":"https://simpleapples.com/zh/posts/avoid-concurrency-bugs-in-go/","summary":"\u003cp\u003e在\u003ca href=\"https://cseweb.ucsd.edu/~yiying/GoStudy-ASPLOS19.pdf\"\u003eUnderstanding Real-World Concurrency Bugs in Go\u003c/a\u003e这篇论文中，几名研究人员分析了常见的Go并发bug，并在最流行的几个Go开源项目中进行了验证。本文梳理了论文中提到的常见的bug并给出解决方法的分析。\u003c/p\u003e\n\u003cp\u003e论文中对bugs进行了分类，分为阻塞式和非阻塞式两种：\n阻塞式：goroutine发生阻塞无法继续执行（例如死锁）\n非阻塞式：不会阻塞执行，但存在潜在的数据冲突（例如并发写）\u003c/p\u003e\n\u003ch1 id=\"阻塞式bug\"\u003e阻塞式bug\u003c/h1\u003e\n\u003cp\u003e阻塞式bug发生的根因有两种，一种是共享内存（例如卡在了意图保护共享内存的锁操作上），一种是消息传递（比如等待chan）。同时研究发现共享内存和消息传递导致的bug数量不想上下，但是共享这种方法的使用量比消息传递使用的更频繁，所以也得出了共享内存方式更不容易导致bug的结论。\u003c/p\u003e\n\u003ch2 id=\"读写锁优先级导致的死锁\"\u003e读写锁优先级导致的死锁\u003c/h2\u003e\n\u003cp\u003e在Go中的写锁优先级高于读锁优先级，假设一个goroutine（goroutine A）连续获取两次读锁，而另一个goroutine（goroutine B）在gouroutine A两次获取读锁中间获取了写锁，就会导致死锁的发生。论文中没有针对这个bug给出示例代码，我写了一个简单的代码示意一下。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-go\" data-lang=\"go\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003efunc\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003egouroutine1\u003c/span\u003e() {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#a6e22e\"\u003em\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eRLock\u003c/span\u003e()\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#a6e22e\"\u003em\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eRLock\u003c/span\u003e()\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003efunc\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003egouroutine2\u003c/span\u003e() {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#a6e22e\"\u003em\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eWLock\u003c/span\u003e()\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003ef1和f2都在goroutine中执行，当f1执行完第一个l.RLock()语句后，假设这时f2的m.WLock执行，由于写锁是排它的，WLock本身被f1的第一个m.RLock()阻塞，写锁操作本身又会阻塞f1中的第二个m.RLock\u003c/p\u003e\n\u003ch2 id=\"waitgroup误用导致的死锁\"\u003eWaitGroup误用导致的死锁\u003c/h2\u003e\n\u003cp\u003e这种情况就是比较典型的WaitGroup的误用了，提前执行group.Wait()会导致部分group.Done()无法执行到，进而导致程序被阻塞。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-go\" data-lang=\"go\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003evar\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003egroup\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003esync\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eWaitGroup\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#a6e22e\"\u003egroup\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eAdd\u003c/span\u003e(len(\u003cspan style=\"color:#a6e22e\"\u003epm\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eplugins\u003c/span\u003e))\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003efor\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003e_\u003c/span\u003e, \u003cspan style=\"color:#a6e22e\"\u003ep\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e:=\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003erange\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003epm\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eplugins\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003ego\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003efunc\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003ep\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003e\u003cspan style=\"color:#a6e22e\"\u003eplugin\u003c/span\u003e) {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003edefer\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003egroup\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eDone\u003c/span\u003e()\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#a6e22e\"\u003egroup\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eWait\u003c/span\u003e()  \u003cspan style=\"color:#75715e\"\u003e// blocked\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e// group.Wait() should be here\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003efor循环内的group.Wait()执行到的时候，循环内的部分goroutine还没有被创建出来，其中的group.Done()也就永远没法执行到，所以会导致永远阻塞在这一句，正确的写法是将group.Wait()移到for循环外。\u003c/p\u003e\n\u003ch2 id=\"channel的误用\"\u003eChannel的误用\u003c/h2\u003e\n\u003cp\u003eChannel是go支持并发的一个非常重要的特性，Channel虽然在很多场景下非常解决问题，但是误用也是不容易发现的。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-go\" data-lang=\"go\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003efunc\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003egoroutine1\u003c/span\u003e() {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#a6e22e\"\u003em\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eLock\u003c/span\u003e()\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#a6e22e\"\u003ech\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e\u0026lt;-\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003erequest\u003c/span\u003e  \u003cspan style=\"color:#75715e\"\u003e// blocked\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#a6e22e\"\u003em\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eUnlock\u003c/span\u003e()\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003efunc\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003egoroutine2\u003c/span\u003e() {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003efor\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#a6e22e\"\u003em\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eLock\u003c/span\u003e()  \u003cspan style=\"color:#75715e\"\u003e// 阻塞\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#a6e22e\"\u003em\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eUnlock\u003c/span\u003e()\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#a6e22e\"\u003erequest\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e\u0026lt;-\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ech\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e这段代码的业务语义是goroutine1会通过ch接收goroutine2发送的消息，但是当goroutine1执行到ch \u0026lt;- request时候会阻塞并等待ch，此时由于goroutine1没有释放锁，goroutine2的m.Lock()也会阻塞，形成死锁。\u003c/p\u003e","title":"规避 Go 中的常见并发 bug"},{"content":"一个偶然的机会，发现一条 SQL 语句在不同的 MySQL 实例上执行得到了不同的结果。\n问题描述 创建商品表 product_tbl 和商品操作记录表 product_operation_tbl 两个表，来模拟下业务场景，结构和数据如下：\n接下来需要查询所有商品最新的修改时间，使用如下语句：\nselect t1.id, t1.name, t2.product_id, t2.created_at from product_tbl t1 left join (select * from product_operation_log_tbl order by created_at desc) t2 on t1.id = t2.product_id group by t1.id; 通过结果可以看到，子查询先将 product_operation_log_tbl 里的所有记录按创建时间(created_at)逆序，然后和 product_tbl 进行 join 操作，进而查询出的商品的最新修改时间。\n在区域 A 的 MySQL 实例上，查询商品最新修改时间可以得到正确结果，但是在区域 B 的 MySQL 实例上，得到的修改时间并不是最新的，而是最老的。通过对语句进行简化，发现是子查询中的 order by created_at desc 语句在区域 B 的实例上没有生效。\n排查过程 难道区域会影响 MySQL 的行为？经过 DBA 排查，区域 A 的 MySQL 是 5.6 版，区域 B 的 MySQL 是 5.7 版，并且找到了这篇文章：\nmysql 5.7 5.6 排序mysql 5.6 升级到 5.7 之后 子查询里面的 order 排序无效火锅与理想的博客-CSDN 博客\n根据文章的描述，MySQL 5.7 版会忽略掉子查询中的 order by 语句，可令人疑惑的是，我们模拟业务场景的 MySQL 是 8.0 版，并没有出现这个问题。使用 docker 分别启动 MySQL 5.6、5.7、8.0 三个实例，来重复上面的操作，结果如下：\n可以看到，只有 MySQL 5.7 版忽略了子查询中的 order by。有没有可能是 5.7 引入了 bug，后续版本又修复了呢？\n问题根因 继续搜索文档和资料，发现官方论坛中有这样一段描述：\nA \u0026ldquo;table\u0026rdquo; (and subquery in the FROM clause too) is - according to the SQL standard - an unordered set of rows. Rows in a table (or in a subquery in the FROM clause) do not come in any specific order. That\u0026rsquo;s why the optimizer can ignore the ORDER BY clause that you have specified. In fact, SQL standard does not even allow the ORDER BY clause to appear in this subquery (we allow it, because ORDER BY \u0026hellip; LIMIT \u0026hellip; changes the result, the set of rows, not only their order). You need to treat the subquery in the FROM clause, as a set of rows in some unspecified and undefined order, and put the ORDER BY on the top-level SELECT.\n问题的原因清晰了，原来 SQL 标准中，table 的定义是一个未排序的数据集合，而一个 SQL 子查询是一个临时的 table，根据这个定义，子查询中的 order by 会被忽略。同时，官方回复也给出了解决方案：将子查询的 order by 移动到最外层的 select 语句中。\n总结 在 SQL 标准中，子查询中的 order by 是不生效的 MySQL 5.7 由于在这个点上遵循了 SQL 标准导致问题暴露，而在 MySQL 5.6/8.0 中这种写法依然是生效的 参考文档 https://stackoverflow.com/questions/26372511/mysql-mariadb-order-by-inside-subquery\nhttps://mariadb.com/kb/en/why-is-order-by-in-a-from-subquery-ignored/\n","permalink":"https://simpleapples.com/zh/posts/orderby-invalid-in-subquery/","summary":"\u003cp\u003e一个偶然的机会，发现一条 SQL 语句在不同的 MySQL 实例上执行得到了不同的结果。\u003c/p\u003e\n\u003ch1 id=\"问题描述\"\u003e问题描述\u003c/h1\u003e\n\u003cp\u003e创建商品表 product_tbl 和商品操作记录表 product_operation_tbl 两个表，来模拟下业务场景，结构和数据如下：\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/images/20210729_01.png\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/images/20210729_02.png\"\u003e\u003c/p\u003e\n\u003cp\u003e接下来需要查询所有商品最新的修改时间，使用如下语句：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-sql\" data-lang=\"sql\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eselect\u003c/span\u003e t1.id, t1.name, t2.product_id, t2.created_at  \u003cspan style=\"color:#66d9ef\"\u003efrom\u003c/span\u003e product_tbl t1 \u003cspan style=\"color:#66d9ef\"\u003eleft\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003ejoin\u003c/span\u003e (\u003cspan style=\"color:#66d9ef\"\u003eselect\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003efrom\u003c/span\u003e product_operation_log_tbl \u003cspan style=\"color:#66d9ef\"\u003eorder\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003eby\u003c/span\u003e created_at \u003cspan style=\"color:#66d9ef\"\u003edesc\u003c/span\u003e) t2 \u003cspan style=\"color:#66d9ef\"\u003eon\u003c/span\u003e t1.id \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e t2.product_id \u003cspan style=\"color:#66d9ef\"\u003egroup\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003eby\u003c/span\u003e t1.id;\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e通过结果可以看到，子查询先将 product_operation_log_tbl 里的所有记录按创建时间(created_at)逆序，然后和 product_tbl 进行 join 操作，进而查询出的商品的最新修改时间。\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/images/20210729_03.png\"\u003e\u003c/p\u003e\n\u003cp\u003e在区域 A 的 MySQL 实例上，查询商品最新修改时间可以得到正确结果，但是在区域 B 的 MySQL 实例上，得到的修改时间并不是最新的，而是最老的。通过对语句进行简化，发现是子查询中的 order by created_at desc 语句在区域 B 的实例上没有生效。\u003c/p\u003e\n\u003ch1 id=\"排查过程\"\u003e排查过程\u003c/h1\u003e\n\u003cp\u003e难道区域会影响 MySQL 的行为？经过 DBA 排查，区域 A 的 MySQL 是 5.6 版，区域 B 的 MySQL 是 5.7 版，并且找到了这篇文章：\u003c/p\u003e","title":"MySQL 子查询中order by不生效问题"},{"content":"在 WSL2 环境中 clone 一个很大的 git 项目，不走代理速度很慢，所以研究了一下怎么让 WSL2 走 Windows 的代理客户端。\nWSL1 和 WSL2 网络的区别 在 WSL1 时代，由于 Linux 子系统和 Windows 共享了网络端口，所以访问 Windows 的代理非常简单。例如 Windows 的代理客户端监听了 8000 端口，那么只需要在 Linux 子系统中执行如下命令，就可以让当前 session 中的请求通过代理访问互联网。\nexport ALL_PROXY=\u0026#34;http://127.0.0.1:8000\u0026#34; 但是 WSL2 基于 Hyper-V 运行，导致 Linux 子系统和 Windows 在网络上是两台各自独立的机器，从 Linux 子系统访问 Windows 首先需要找到 Windows 的 IP。\n配置 WSL2 访问 Windows 上的代理 有两个关键步骤：\nWSL2 中配置的代理要指向 Windows 的 IP； Windows 上的代理客户端需要允许来自本地局域网的请求； 由于 Linux 子系统也是通过 Windows 访问网络，所以 Linux 子系统中的网关指向的是 Windows，DNS 服务器指向的也是 Windows，基于这两个特性，我们可以将 Windows 的 IP 读取出来。\n例如，在 Ubuntu 子系统中，通过 cat /etc/resolv.conf 查看 DNS 服务器 IP。\n# This file was automatically generated by WSL. To stop automatic generation of this file, add the following entry to /etc/wsl.conf:# [network]# generateResolvConf = falsenameserver 172.19.80.1 可以看到 DNS 服务器是 172.19.80.1，通过环境变量 ALL_PROXY 配置代理：\nexport ALL_PROXY=\u0026#34;http://172.19.80.1:7890\u0026#34; 7890 是 Windows 上运行的代理客户端的端口，记得要在 Windows 代理客户端上配置允许本地局域网请求。\n一键配置脚本 将上面的过程写入一个 bash 脚本，可以轻松的实现一键配置代理：\n#!/bin/bash host_ip=$(cat /etc/resolv.conf |grep \u0026#34;nameserver\u0026#34; |cut -f 2 -d \u0026#34; \u0026#34;) export ALL_PROXY=\u0026#34;http://$host_ip:7890\u0026#34; 脚本通过 cat /etc/resolv.conf 来获取 DNS 服务器，也就是 Windows 的 IP，再将其中的 IP 部分截取出来，加上代理客户端的端口（我的是 7890，可以根据自己实际情况修改），使用 export 写入环境变量中。\n脚本也可以从这里下载.proxyrc，使用时只需要 source .proxyrc 就可以生效。\n","permalink":"https://simpleapples.com/zh/posts/one-click-setting-proxy-for-wsl2/","summary":"\u003cp\u003e在 WSL2 环境中 clone 一个很大的 git 项目，不走代理速度很慢，所以研究了一下怎么让 WSL2 走 Windows 的代理客户端。\u003c/p\u003e\n\u003ch3 id=\"wsl1-和-wsl2-网络的区别\"\u003eWSL1 和 WSL2 网络的区别\u003c/h3\u003e\n\u003cp\u003e在 WSL1 时代，由于 Linux 子系统和 Windows 共享了网络端口，所以访问 Windows 的代理非常简单。例如 Windows 的代理客户端监听了 8000 端口，那么只需要在 Linux 子系统中执行如下命令，就可以让当前 session 中的请求通过代理访问互联网。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eexport ALL_PROXY\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;http://127.0.0.1:8000\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e但是 WSL2 基于 Hyper-V 运行，导致 Linux 子系统和 Windows 在网络上是两台各自独立的机器，从 Linux 子系统访问 Windows 首先需要找到 Windows 的 IP。\u003c/p\u003e\n\u003ch3 id=\"配置-wsl2-访问-windows-上的代理\"\u003e配置 WSL2 访问 Windows 上的代理\u003c/h3\u003e\n\u003cp\u003e有两个关键步骤：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eWSL2 中配置的代理要指向 Windows 的 IP；\u003c/li\u003e\n\u003cli\u003eWindows 上的代理客户端需要允许来自本地局域网的请求；\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e由于 Linux 子系统也是通过 Windows 访问网络，所以 Linux 子系统中的网关指向的是 Windows，DNS 服务器指向的也是 Windows，基于这两个特性，我们可以将 Windows 的 IP 读取出来。\u003c/p\u003e","title":"为 WSL2 一键设置代理"},{"content":"为什么要使用 Windows 做开发 一直以来 macOS 以类 unix 的特性，获得了程序员的青睐，但是近几年 Apple 在硬件领域少有让人耳目一新的产品，加上取消 Esc、使用蝶式键盘、基本为 0 的硬件可升级性、系统权限的收紧等骚操作，让 Mac 从软件到硬件都不如以前适合编程。另一方面，PC 阵营在软件层面保持开放的基础上，硬件体验也逐步赶上甚至超越 Mac，我也不想在用 Mac 做开发，用 PC 玩游戏，希望用一台电脑兼顾游戏和开发，所以选择回到了 PC 阵营。\n随着微软拥抱开源领域，Windows 也开始变得程序员友好。Windows 10 2004 发布后，WSL2 也可以在正式版 Windows 10 中使用，相比于 macOS，WSL2 是一个原生 Linux 环境而非类 unix 环境，甚至可以在 App 商店中选择所需要的发行版。而相比于 WSL1，WSL2 采用了 HyperV 虚拟机的方式，解决了 WSL1 不能安装 Docker 等问题。\nWSL1 和 WSL2 相比于 WSL1，WSL2 通过虚拟机的方式带来了更完整的 Linux 内核，但这种方式也引入了一些问题，微软给出了下面的图表来展示这些不同：\nWSL2 不能和 VMWarework Station、VirtualBox 同时运行这一条已经过时了，VirtualBox 和 VMWare Workstation 都发布了支持 WSL2 和 Hyper-V 的新版。\nWSL2 跨 OS 的磁盘性能的确低的令人发指，尤其是小文件，安装一个 Python 依赖可能需要等几分钟，安装一个 NodeJS 依赖\u0026hellip;当我没说\u0026hellip;相关 ISSUE 底下有无数吐槽，不过目前还没有人出来解决，在这里：https://github.com/microsoft/WSL/issues/4197）。不过微软在文档里也说了，有很多方式可以避免跨 OS 使用文件系统，比如使用 VSCode 的 remote deployment 功能，我认为这也是更好的实践，并且也这么做了。当然，如果你必须跨 OS 使用文件系统，还是乖乖留在 WSL1 吧（WSL1 太渣了，还是留在 VirtualBox 吧）。\n除了表格里说的，我认为 WSL2 最大的问题在于\u0026hellip;资源占用太大了\u0026hellip;我是一台 16G 内存的电脑，使用 WSL2 后开机就要吃掉 11G 的内存，虽然可以使用 wsl --shutdown 关闭虚拟机释放资源，但是相比于 VirtualBox 和 WSL1，WSL2 的资源占用可以说翻倍了。\n微软提供了限制 WSL2 资源的方式，参见https://docs.microsoft.com/en-us/windows/wsl/release-notes#build-18945\n要做些什么 好了，搞清楚 WSL2 是什么之后接下来的问题就是怎么做了，这篇文章会指导你完成如下的安装流程：\n升级 Windows 10 到 2004 启用 WSL2 并安装 Linux 以及一些最佳实践：\n网络互通 文件系统互通 使用 Docker 最后会聊聊 WSL2 的未来。\n升级 Windows 10 2004 升级到 Windows 10 2004 有多种方法，最靠谱的还是从设置 - 更新和安全里进行 OTA 升级，但是 Windows 的更新是分批推送的，2004 更新有可能等到一两个月后才会出现在你的更新界面中。\n另一种更快速的方法是从官方地址下载镜像升级，访问这个地址下载运行就可以升级到最新的版本 https://www.microsoft.com/software-download/windows10，需要注意的是，发布初期可能 bug 含量会高一些，介意的还是再等等。\n启用 WSL2 升级 Windows 10 的过程不会碰到太多问题，升级后还需要进行一些配置才可以使用 WSL2，首先要启用 Windows 子系统功能，使用管理员权限打开一个 PowerShell 窗口，输入以下命令，并重启系统：\ndism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart 重启后，Windows 默认启用的是 WSL1，还需要再启用虚拟机平台功能，在 PowerShell 中输入以下命令，并再次重启系统：\ndism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart 重启后，在 PowerShell 中输入以下命令，将 WSL 默认版本改为 WSL2:\nwsl --set-default-version 2 接下来在 Microsoft Store 中找一个 Linux 发行版进行安装，安装后在 PowerShell 中执行 wsl -l -v 可以看到当前的发行版是否跑在 WSL2 中，如果显示版本是 1\u0026hellip;请重复上面的安装步骤。\n设置 WSL 版本为 WSL2 报错时，请访问 https://docs.microsoft.com/en-us/windows/wsl/wsl2-kernel 下载 WSL2 Kernel。\n网络互通 WSL2 不和 Windows 共享一个 localhost，所以不像 WSL1 中 Linux 和 Windows 有无感知的网络互通性。\nWindows 访问 WSL2 启动的网络服务，可以直接使用 localhost，但是 Linux 访问 Windows 启动的网络服务这种方式就不行了，可以使用如下脚本获取 Windows 的 IP，并使用 IP 访问 Windows：\nip route | grep default | awk \u0026#39;{print $3}\u0026#39; 文件系统互通 WSL2 访问 Windows 文件系统依然通过挂载分区的方式，Windows 下的磁盘会被挂载在 /mnt 下，例如 /mnt/c。\n相比于 WSL1，这次增加了 Windows 访问 Linux 分区的能力，可以在资源管理器中输入 \\\\wsl$\\\u0026lt;子系统名\u0026gt; 访问对应的子系统分区，为了方便也可以在资源管理器中把 Linux 分区挂载成一个磁盘。\n更加方便的一个方式是，在 Terminal 中，使用 explorer.exe . 可以直接调用资源管理器打开当前目录，有点类似 Mac 下的 open .。\n使用 Docker WSL2 带来了完整的 Linux 内核，所以可以参照 Docker 在 Linux 上安装的过程安装 Docker，并且可以正常使用，但是会有一个小瑕疵。WSL2 的 systemd 吧\u0026hellip;还不是原生的，也就是在 WSL1 上就有的无法启动服务守护进程的问题依然存在，Docker 服务自然也不能幸免。\n解决这个问题有三种方案：\n可以让 Windows 执行开机脚本，通过脚本启动 WSL2 中的 Docker，参见https://blog.csdn.net/XhyEax/article/details/105560377，这种方案在 WSL1 时代就有，我自己使用过没碰到过问题。\n第二种方案是使用第三方工具运行 systemd，参见 https://github.com/arkane-systems/genie，原理是提供了一个单独的 namespace 跑 systemd。\n第三种方案是使用 Docker Desktop，2.3.0.2 以上版本已经支持 WSL2 和 Hyper-V，免去一些折腾。\nGPU 支持 Build 2020 发出消息说 WSL2 要支持 GPU，Nvidia 也发出了 CUDA on WSL2 的预览版，在这里：https://developer.nvidia.com/cuda/wsl。\n这意味着以后可以直接在 Windows 上使用 GPU 加速训练模型了，虽然支持成都还很有限，但是相比于 Mac 可领先了一个身位都不只了。\n总结 在体系结构上 WSL2 没有太大的创新，本质就是一台跑在 Hyper-V 上的虚拟机，你可以使用 VMWare Workstation 或 VirtualBox，经过简单的配置实现其 100% 的功能，并且会有更高的性能，更少的资源占用，但是毕竟 WSL2 是一项原生功能，其配置上的便利性和兼容性，大大减少了使用者花在配置上的精力，最大程度的实现开箱即用，这也是 Apple 一直以来吸引开发者的主要原因。在这个时间点，使用 Windows + WSL2 来构建开发环境已经可以满足大部分的需求。\n参考 https://github.com/microsoft/WSL/issues/4197\nhttps://docs.microsoft.com/en-us/windows/wsl/wsl2-kernel\nhttps://docs.microsoft.com/en-us/windows/wsl/install-win10\nhttps://github.com/arkane-systems/genie\nhttps://docs.microsoft.com/en-us/windows/wsl/release-notes#build-18945\nhttps://developer.nvidia.com/cuda/wsl\nhttps://devblogs.microsoft.com/directx/directx-heart-linux/\n","permalink":"https://simpleapples.com/zh/posts/wsl2-guideline-for-developers/","summary":"\u003ch3 id=\"为什么要使用-windows-做开发\"\u003e为什么要使用 Windows 做开发\u003c/h3\u003e\n\u003cp\u003e一直以来 macOS 以类 unix 的特性，获得了程序员的青睐，但是近几年 Apple 在硬件领域少有让人耳目一新的产品，加上取消 Esc、使用蝶式键盘、基本为 0 的硬件可升级性、系统权限的收紧等骚操作，让 Mac 从软件到硬件都不如以前适合编程。另一方面，PC 阵营在软件层面保持开放的基础上，硬件体验也逐步赶上甚至超越 Mac，我也不想在用 Mac 做开发，用 PC 玩游戏，希望用一台电脑兼顾游戏和开发，所以选择回到了 PC 阵营。\u003c/p\u003e\n\u003cp\u003e随着微软拥抱开源领域，Windows 也开始变得程序员友好。Windows 10 2004 发布后，WSL2 也可以在正式版 Windows 10 中使用，相比于 macOS，WSL2 是一个原生 Linux 环境而非类 unix 环境，甚至可以在 App 商店中选择所需要的发行版。而相比于 WSL1，WSL2 采用了 HyperV 虚拟机的方式，解决了 WSL1 不能安装 Docker 等问题。\u003c/p\u003e\n\u003ch3 id=\"wsl1-和-wsl2\"\u003eWSL1 和 WSL2\u003c/h3\u003e\n\u003cp\u003e相比于 WSL1，WSL2 通过虚拟机的方式带来了更完整的 Linux 内核，但这种方式也引入了一些问题，微软给出了下面的图表来展示这些不同：\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/images/20200601_01.png\"\u003e\u003c/p\u003e\n\u003cp\u003eWSL2 不能和 VMWarework Station、VirtualBox 同时运行这一条已经过时了，VirtualBox 和 VMWare Workstation 都发布了支持 WSL2 和 Hyper-V 的新版。\u003c/p\u003e","title":"面向开发者的 WSL2 安装指南"},{"content":"问题描述 在 Python 项目中使用 gRPC 进行通信，跨进程使用时，会出现阻塞或报错的情况（根据 gRPC.io 的版本不同，现象不同）。下面代码展示了一个跨进程使用的 DEMO，主进程向 30001 端口上的 gRPC 服务器发送请求，子进程也向相同的服务器发送请求。\ndef send(): channel = grpc.insecure_channel(\u0026#39;localhost:30001\u0026#39;) stub = message_pb2_grpc.GreeterStub(channel) response = stub.SayHello(message_pb2.HelloRequest(name=\u0026#39;you\u0026#39;)) print(f\u0026#34;Greeter client received 1: \u0026#34; + response.message) def main(): channel = grpc.insecure_channel(\u0026#39;localhost:30001\u0026#39;) stub = message_pb2_grpc.GreeterStub(channel) response = stub.SayHello2(message_pb2.HelloRequest(name=\u0026#39;you\u0026#39;)) print(\u0026#34;Greeter client received 2: \u0026#34; + response.message) p = multiprocessing.Process(target=send) p.start() p.join() if __name__ == \u0026#39;__main__\u0026#39;: main() 使用 gRPC.io 1.28.1 的情况下，会发生报错，主进程可以正常收到服务器的返回，但是子进程报 Socket operation on non-socket。\nraise _InactiveRpcError(state) grpc._channel._InactiveRpcError: \u0026lt;_InactiveRpcError of RPC that terminated with: status = StatusCode.UNAVAILABLE details = \u0026#34;Socket operation on non-socket\u0026#34; debug_error_string = \u0026#34;{\u0026#34;created\u0026#34;:\u0026#34;@1587481625.192071231\u0026#34;,\u0026#34;description\u0026#34;:\u0026#34;Error received from peer ipv6:[::1]:50051\u0026#34;,\u0026#34;file\u0026#34;:\u0026#34;src/core/lib/surface/call.cc\u0026#34;,\u0026#34;file_line\u0026#34;:1056,\u0026#34;grpc_message\u0026#34;:\u0026#34;Socket operation on non-socket\u0026#34;,\u0026#34;grpc_status\u0026#34;:14}\u0026#34; \u0026gt; 排查过程 根据代码，主进程和子进程分别创建了自己的 Channel，看上去逻辑没什么问题，没有什么思路，所以多尝试几种情况先测试一下吧。首先尝试了一下主进程和子进程请求不同的server，在 30001 和 30002 端口分别启动两个 gRPC Server，然后将客户端代码改为主进程请求 30001 端口，子进程请求 30002 端口，代码可以正常运行。测试到这里就更摸不着头脑了，代码明明写的是主进程子进程分别创建 Channel，现在的现象看上去像是在请求相同服务器的情况下，子进程复用了主进程的socket连接。gRPC 底层使用的是 HTTP2，而 HTTP2 使用了长连接，会不会是这个原因？\n有了新的分帧机制后，HTTP/2 不再依赖多个 TCP 连接去并行复用数据流；每个数据流都拆分成很多帧，而这些帧可以交错，还可以分别设定优先级。 因此，所有 HTTP/2 连接都是永久的，而且仅需要每个来源一个连接，随之带来诸多性能优势。 —— HTTP/2 简介\n从 HTTP2 原理上来看还是说的过去的，恰好 gRPC 项目中有 Issue 提到了跨进程使用的问题，参见 Failed to run grpc python on multiprocessing #18321，开发者在其中说明了像 Demo 那样使用报错的原因。\ngRPC Core\u0026rsquo;s API for fork support A process may fork after invoking grpc_init() and use gRPC in the child if and only if the child process first destroys all gRPC resources inherited from the parent process and invokes grpc_shutdown(). Subsequent to this, the child will be able to re-initialize and use gRPC. After fork, the parent process will be able to continue to use existing gRPC resources such as channels and calls without interference from the child process.\ngRPC Python behavior at fork() To facilitate gRPC Python applications meeting the above constraints, gRPC Python will automatically destroy and shutdown all gRPC Core resources in the child\u0026rsquo;s post-fork handler, including cancelling in-flight calls. From the client\u0026rsquo;s perspective, the child process is now free to create new channels and use gRPC.\n简化的说，在 gRPC Core API 的层面，子进程使用 gRPC 需要先销毁掉从父进程 fork 过来的 gRPC 资源，重新创建连接才可以正常使用，否则可能陷入死锁。\n同时，gRPC 对于 fork 行为的支持也有一个专门的文档。https://github.com/grpc/grpc/blob/master/doc/fork_support.md\nThe background Python thread was removed entirely. This allows forking after creating a channel. However, the channel must not have issued any RPCs prior to the fork. Attempting to fork with an active channel that has been used can result in deadlocks/corrupted wire data.\n从文档和 Issue 的描述看，当主进程有活动状态的 gRPC 连接时，是不可以 fork 的，会引发死锁或者报错（可能和 HTTP2 的长连接机制有关系），如果要 fork，需要先关闭掉活动的连接，在 fork 出的子进程中重新建立 gRPC 连接（也就是主子进程各自持有各自的 HTTP2 连接）。\n实践方案 综合文档和开发者在 Issue 中提到的方法，要想让 Demo 可以运行有如下三种方法。\n在环境变量中设置 GRPC_ENABLE_FORK_SUPPORT=1（参见https://github.com/grpc/grpc/blob/master/doc/fork_support.md#111）\n在 fork 子进程前使用 channel.close() 关闭活动的 gRPC 连接（参见https://grpc.github.io/grpc/python/grpc.html#grpc.Channel.close）\ndef main(): channel = grpc.insecure_channel(\u0026#39;localhost:30001\u0026#39;) stub = message_pb2_grpc.GreeterStub(channel) response = stub.SayHello2(message_pb2.HelloRequest(name=\u0026#39;you\u0026#39;)) print(\u0026#34;Greeter client received 2: \u0026#34; + response.message) channel.close() # 关闭 channel，再 fork p = multiprocessing.Process(target=send) p.start() p.join() 使用 with 语句，语句结束后会自动关闭活动的 gRPC 连接（参见https://github.com/grpc/grpc/blob/master/examples/python/helloworld/greeter_client.py#L29) def main(): # 使用 with 语句 with grpc.insecure_channel(\u0026#39;localhost:30001\u0026#39;) as channel: stub = message_pb2_grpc.GreeterStub(channel) response = stub.SayHello2(message_pb2.HelloRequest(name=\u0026#39;you\u0026#39;)) print(\u0026#34;Greeter client received 2: \u0026#34; + response.message) p = multiprocessing.Process(target=send) p.start() p.join() 参考资料 https://grpc.github.io/grpc/python/grpc.html#channel-object\nhttps://developers.google.com/web/fundamentals/performance/http2?hl=zh-cn\nhttps://github.com/grpc/grpc/issues/18321\nhttps://github.com/grpc/grpc/pull/16264\nhttps://github.com/grpc/grpc/blob/master/doc/fork_support.md#111\nhttps://grpc.github.io/grpc/python/grpc.html#grpc.Channel.close\n","permalink":"https://simpleapples.com/zh/posts/grpc-fork-support/","summary":"\u003ch3 id=\"问题描述\"\u003e问题描述\u003c/h3\u003e\n\u003cp\u003e在 Python 项目中使用 gRPC 进行通信，跨进程使用时，会出现阻塞或报错的情况（根据 gRPC.io 的版本不同，现象不同）。下面代码展示了一个跨进程使用的 DEMO，主进程向 30001 端口上的 gRPC 服务器发送请求，子进程也向相同的服务器发送请求。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003edef\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003esend\u003c/span\u003e():\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    channel \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e grpc\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003einsecure_channel(\u003cspan style=\"color:#e6db74\"\u003e\u0026#39;localhost:30001\u0026#39;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    stub \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e message_pb2_grpc\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003eGreeterStub(channel)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    response \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e stub\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003eSayHello(message_pb2\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003eHelloRequest(name\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e\u0026#39;you\u0026#39;\u003c/span\u003e))\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    print(\u003cspan style=\"color:#e6db74\"\u003ef\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;Greeter client received 1: \u0026#34;\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e+\u003c/span\u003e response\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003emessage)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003edef\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003emain\u003c/span\u003e():\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    channel \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e grpc\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003einsecure_channel(\u003cspan style=\"color:#e6db74\"\u003e\u0026#39;localhost:30001\u0026#39;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    stub \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e message_pb2_grpc\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003eGreeterStub(channel)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    response \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e stub\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003eSayHello2(message_pb2\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003eHelloRequest(name\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e\u0026#39;you\u0026#39;\u003c/span\u003e))\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    print(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;Greeter client received 2: \u0026#34;\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e+\u003c/span\u003e response\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003emessage)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    p \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e multiprocessing\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003eProcess(target\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003esend)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    p\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003estart()\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    p\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003ejoin()\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e __name__ \u003cspan style=\"color:#f92672\"\u003e==\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;__main__\u0026#39;\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    main()\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e使用 gRPC.io 1.28.1 的情况下，会发生报错，主进程可以正常收到服务器的返回，但是子进程报 \u003ccode\u003eSocket operation on non-socket\u003c/code\u003e。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eraise _InactiveRpcError\u003cspan style=\"color:#f92672\"\u003e(\u003c/span\u003estate\u003cspan style=\"color:#f92672\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003egrpc._channel._InactiveRpcError: \u0026lt;_InactiveRpcError of RPC that terminated with:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        status \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e StatusCode.UNAVAILABLE\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        details \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;Socket operation on non-socket\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        debug_error_string \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;{\u0026#34;\u003c/span\u003ecreated\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;:\u0026#34;\u003c/span\u003e@1587481625.192071231\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;,\u0026#34;\u003c/span\u003edescription\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;:\u0026#34;\u003c/span\u003eError received from peer ipv6:\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003e::1\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e:50051\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;,\u0026#34;\u003c/span\u003efile\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;:\u0026#34;\u003c/span\u003esrc/core/lib/surface/call.cc\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;,\u0026#34;\u003c/span\u003efile_line\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;:1056,\u0026#34;\u003c/span\u003egrpc_message\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;:\u0026#34;\u003c/span\u003eSocket operation on non-socket\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;,\u0026#34;\u003c/span\u003egrpc_status\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;:14}\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"排查过程\"\u003e排查过程\u003c/h3\u003e\n\u003cp\u003e根据代码，主进程和子进程分别创建了自己的 Channel，看上去逻辑没什么问题，没有什么思路，所以多尝试几种情况先测试一下吧。首先尝试了一下主进程和子进程请求不同的server，在 30001 和 30002 端口分别启动两个 gRPC Server，然后将客户端代码改为主进程请求 30001 端口，子进程请求 30002 端口，代码可以正常运行。测试到这里就更摸不着头脑了，代码明明写的是主进程子进程分别创建 Channel，现在的现象看上去\u003cstrong\u003e像是在请求相同服务器的情况下，子进程复用了主进程的socket连接\u003c/strong\u003e。gRPC 底层使用的是 HTTP2，而 HTTP2 使用了长连接，会不会是这个原因？\u003c/p\u003e","title":"gRPC 跨进程使用引发的问题"},{"content":"问题描述 vscode 无法以 run 模式运行 go 项目（只能以 debug 模式调试），并且有如下报错。\n图中被遮盖的部分是项目内的 package，并非第三方 package，也就是说在以 run 模式运行 go 项目时无法找到其他的 go 文件，只能找到入口文件。\n初步排查 找不到其他文件，首先想到的是 GO_PATH 的问题，但是项目使用了 go mod，允许在 GO_PATH 之外的路径创建项目，所以这个怀疑点排除。接下来怀疑 vscode 的配置有问题，每个 vscode 项目中都有 .launch.json 文件，配置运行代码时的环境，下面是项目中的 .launch.json。\n{ // Use IntelliSense to learn about possible attributes. // Hover to view descriptions of existing attributes. // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387 \u0026#34;version\u0026#34;: \u0026#34;0.2.0\u0026#34;, \u0026#34;configurations\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;Launch\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;go\u0026#34;, \u0026#34;request\u0026#34;: \u0026#34;launch\u0026#34;, \u0026#34;mode\u0026#34;: \u0026#34;auto\u0026#34;, \u0026#34;program\u0026#34;: \u0026#34;${workspaceRoot}/src/main.go\u0026#34;, \u0026#34;env\u0026#34;: {}, \u0026#34;args\u0026#34;: [] } ] } 可以看到 .launch.json 里没有指定程序的工作目录，debug 模式和 run 模式会不会默认的工作路径不同呢？于是在 main 函数里使用 os.Getwd() 打印一下当前的路径，结果如下：\ndebug 模式：项目所在目录 run 模式：用户目录 基本可以确认，run 模式下的工作路径设置不正确，导致找不到路径。在 .launch.json 中加入 cwd 参数，手动填入项目路径。\n{ // Use IntelliSense to learn about possible attributes. // Hover to view descriptions of existing attributes. // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387 \u0026#34;version\u0026#34;: \u0026#34;0.2.0\u0026#34;, \u0026#34;configurations\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;Launch\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;go\u0026#34;, \u0026#34;request\u0026#34;: \u0026#34;launch\u0026#34;, \u0026#34;mode\u0026#34;: \u0026#34;auto\u0026#34;, \u0026#34;program\u0026#34;: \u0026#34;${workspaceRoot}/src/main.go\u0026#34;, \u0026#34;cwd\u0026#34;: \u0026#34;${workspaceRoot}\u0026#34;, \u0026#34;env\u0026#34;: {}, \u0026#34;args\u0026#34;: [] } ] } 但是修改 .launch.json 后运行程序，输出的工作目录仍然是用户目录，cwd 参数并没有生效。\n探究 vscode 的 debug 流程 至此，bug 的气息越来越浓厚，cwd 参数没有生效，肯定有问题！\n一不做二不休，索性看看 vscode 的调试流程吧，用一个很暴力的方式，看看点击运行按钮后，vscode 到底是如何运行 go 程序的。\npackage main import \u0026#34;time\u0026#34; func main() { time.Sleep(10000000000) } 运行程序后，使用 ps -ef|grep go 查看进程。\n截图中三个进程从上到下均是父子关系，也就是说在 vscode 中即便使用 run 模式运行，也不是直接执行 go run xxxx.go，这与 Goland 等其他 IDE 的行为是不同的。vscode 首先调用了 language server 中的 node，执行了 go extention（vscode 的 go 扩展，安装后才支持 go 语言项目）中的一个 goDebug.js，而后 goDebug.js 中调用了 go run xxxx.go。（图中 /tmp 路径下的 main 文件是 go run 执行过程中生成的二进制文件）\n接下来查看 goDebug.js 的逻辑，找到了调用 go run 的代码。\nthis.debugProcess = spawn(getBinPathWithPreferredGopath(\u0026#34;go\u0026#34;, []), runArgs, { env, }); 查看代码上面几行的逻辑，根据参数的命名，可以猜测出来，.launch.json 中的配置在这里是可以获取到的。接下来直接修改 js 文件，进行调试，证实上述的猜测，由于我们无法直接看到 node goDebug.js 的输出，所以通过写入文件的方式进行调试。\nfs.writeFile(\u0026#39;test.log\u0026#39;, this.debugProcess.cwd(), function (err) {} 加入这句后再次运行，我们可以看到 test.log 文件中已经打印出了这个进程的工作路径，也就是 go run 的工作路径，是用户目录。至此，可以将问题缩小到：在 node 调用 go run 时没有将 .launch.json 文件中的 cwd 传给子进程（go run）。\nspawn 是 nodejs 中的函数，看一下 spawn 的文档可以发现，spawn 有三个参数 child_process.spawn(command[, args][, options]) 第三个参数 options 中可以指定 cwd 工作路径。而 goDebug.js 这段启动子进程的代码并没有设置 cwd，只设置了env 参数，这就是 run 模式无法运行 go 程序的原因。\n解决方案 在发现这个问题时，vscode go extention 的最新版本是 0.13，这个问题暂时只能通过修改 goDebug.js 的源码解决，如下图所示加入注释中的代码，将 cwd 参数传入子进程，就可以解决问题。\n同时，这个 bug 已经被解决，可以参考 ISSUE #3096，程序员在解决另一个问题这个 ISSUE 的问题时，“顺手”把 cwd 的问题修复了。在 vscode go extention 0.14 版发布后（已发布），将 go extension 更新到最新版就可以正常运行和调试 go 项目了。\n参考资料 Debugging in Visual Studio Code\nNode.js v13.13.0 Documentation\nDebug: add \u0026ldquo;go run .\u0026rdquo; support #3096\n","permalink":"https://simpleapples.com/zh/posts/vscode-cant-run-go-project/","summary":"\u003ch3 id=\"问题描述\"\u003e问题描述\u003c/h3\u003e\n\u003cp\u003evscode 无法以 \u003ccode\u003erun\u003c/code\u003e 模式运行 go 项目（只能以 \u003ccode\u003edebug\u003c/code\u003e 模式调试），并且有如下报错。\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/images/20200420_01.png\"\u003e\u003c/p\u003e\n\u003cp\u003e图中被遮盖的部分是项目内的 package，并非第三方 package，也就是说在以 \u003ccode\u003erun\u003c/code\u003e 模式运行 go 项目时无法找到其他的 go 文件，只能找到入口文件。\u003c/p\u003e\n\u003ch3 id=\"初步排查\"\u003e初步排查\u003c/h3\u003e\n\u003cp\u003e找不到其他文件，首先想到的是 GO_PATH 的问题，但是项目使用了 go mod，允许在 GO_PATH 之外的路径创建项目，所以这个怀疑点排除。接下来怀疑 vscode 的配置有问题，每个 vscode 项目中都有 .launch.json 文件，配置运行代码时的环境，下面是项目中的 .launch.json。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-json\" data-lang=\"json\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e{\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#75715e\"\u003e// Use IntelliSense to learn about possible attributes.\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#75715e\"\u003e// Hover to view descriptions of existing attributes.\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#75715e\"\u003e// For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e\u003c/span\u003e  \u003cspan style=\"color:#f92672\"\u003e\u0026#34;version\u0026#34;\u003c/span\u003e: \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;0.2.0\u0026#34;\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#f92672\"\u003e\u0026#34;configurations\u0026#34;\u003c/span\u003e: [\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      \u003cspan style=\"color:#f92672\"\u003e\u0026#34;name\u0026#34;\u003c/span\u003e: \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;Launch\u0026#34;\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      \u003cspan style=\"color:#f92672\"\u003e\u0026#34;type\u0026#34;\u003c/span\u003e: \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;go\u0026#34;\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      \u003cspan style=\"color:#f92672\"\u003e\u0026#34;request\u0026#34;\u003c/span\u003e: \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;launch\u0026#34;\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      \u003cspan style=\"color:#f92672\"\u003e\u0026#34;mode\u0026#34;\u003c/span\u003e: \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;auto\u0026#34;\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      \u003cspan style=\"color:#f92672\"\u003e\u0026#34;program\u0026#34;\u003c/span\u003e: \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;${workspaceRoot}/src/main.go\u0026#34;\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      \u003cspan style=\"color:#f92672\"\u003e\u0026#34;env\u0026#34;\u003c/span\u003e: {},\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e      \u003cspan style=\"color:#f92672\"\u003e\u0026#34;args\u0026#34;\u003c/span\u003e: []\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  ]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e可以看到 .launch.json 里没有指定程序的工作目录，\u003ccode\u003edebug\u003c/code\u003e 模式和 \u003ccode\u003erun\u003c/code\u003e 模式会不会默认的工作路径不同呢？于是在 main 函数里使用 \u003ccode\u003eos.Getwd()\u003c/code\u003e 打印一下当前的路径，结果如下：\u003c/p\u003e","title":"探究vscode debug流程，解决无法运行go程序的问题"},{"content":"问题描述 Viper （本文环境是 Viper 1.1.0）是 Go 应用程序的完整配置解决方案，在很多项目中都有应用。etcd是一个分布式 KV 存储，最直接的应用是配置中心。\nViper 除了支持从文件中读取配置，还支持从远程的配置中心读取配置，使用下面的代码进行配置。\nviper.AddRemoteProvider(\u0026#34;etcd\u0026#34;, \u0026#34;http://127.0.0.1:2379\u0026#34;, \u0026#34;conf.toml\u0026#34;) viper.SetConfigType(\u0026#34;toml\u0026#34;) err := viper.ReadRemoteConfig() if err != nil { panic(err) } 运行后报错panic: Remote Configurations Error: No Files Found，检查后发现 etcd 开启了 tls，所以需要用 https 协议访问 etcd 的 API，更新代码如下。\nviper.AddSecureRemoteProvider(\u0026#34;etcd\u0026#34;, \u0026#34;https://127.0.0.1:2379\u0026#34;, \u0026#34;conf.toml\u0026#34;, \u0026#34;key_path\u0026#34;) viper.SetConfigType(\u0026#34;toml\u0026#34;) err := viper.ReadRemoteConfig() if err != nil { panic(err) } 使用AddSecureRemoteProvider方法替换AddRemoteProvider方法，问题依旧。\n定位问题 跟踪源码发现，最终像 etcd 发送请求的是go-etcd包（目前 go-etcd 已经不维护），在 go-etcd 的 requests.go 文件中找到了相关的源码，go-etcd 调用了 net/http 包向 etcd 发送请求。\n这个时候忽然想到 etcd 的证书是自签名的，访问自签名证书的 https 接口应该会报错啊，怎么会请求到内容呢？如下图，在 Chrome 中访问 etcd 的自签名 https 接口，会提示证书无效。\n我们自己使用 go 实现一段请求 etcd https 接口的代码，看看到底是什么回事，代码如下。\nresp, err := http.Get(\u0026#34;https://127.0.0.1:2379/v2/keys/conf.toml?quorum=false\u0026amp;recursive=false\u0026amp;sorted=false\u0026#34;) if err != nil { // handle error fmt.Println(err) } defer resp.Body.Close() body, err := ioutil.ReadAll(resp.Body) if err != nil { fmt.Println(err) } fmt.Println(string(body)) 果然不一样，我们的代码会报错x509: certificate signed by unknown authority，因为是自签名证书，客户端无法验证证书真假，所以这个报错是可以理解的，go-etcd 代码和我们的测试代码表现不一致，一定是我们落下了什么，重新梳理 go-etcd 源码终于发现了原因。\n在 client.go 文件的 initHTTPSClient 方法中，发现允许绕过证书验证，这就可以解释为什么证书无效也能获取到数据了，绕过了证书的验证环节，相当于不管证书真假都拿来用。现在可以解释使用AddRemoteProvider方法访问 https 接口为什么可以获取到内容，但是无法解释AddSecureRemoteProvider方法为什么无法从 https 接口获取内容，因为两个方法在发送 http 请求阶段的代码是一致的，都忽略了证书验证。\n查看AddSecureRemoteProvider的注释，发现了原因。\n原来\u0026hellip;AddSecureRemoteProvider这个 Secure 指的并不是使用安全链接 https，而是在请求到内容后加了一个解密的步骤（Secure 指请求的是加密过的内容，而不是使用加密链接请求），最后一个参数接收的也并不是客户端证书，而是解密的 gpg key\u0026hellip; 根据 viper 的文档，这个 gpg key 是可选的，我们这个例子中，如果给 gpg key 传入一个空字符串，也是可以正常执行的\u0026hellip;\n必须吐槽一下 viper 的命名，哪里是AddSecureRemoteProvider，明明应该叫AddEncryptedRemoteProvider\n总结 出现这个问题，主要是误会了AddSecureRemoteProvider接口表达的意思，并且 go-etcd 允许忽略证书验证，也让问题变得更加离奇。\n当然 go-etcd 的这种配置是非常合理的，内部系统使用自签名证书是一个很正常的行为。\n","permalink":"https://simpleapples.com/zh/posts/viper-read-from-etcd-failed/","summary":"\u003ch3 id=\"问题描述\"\u003e问题描述\u003c/h3\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/spf13/viper\"\u003eViper\u003c/a\u003e （本文环境是 Viper 1.1.0）是 Go 应用程序的完整配置解决方案，在很多项目中都有应用。\u003ca href=\"https://github.com/etcd-io/etcd\"\u003eetcd\u003c/a\u003e是一个分布式 KV 存储，最直接的应用是配置中心。\u003c/p\u003e\n\u003cp\u003eViper 除了支持从文件中读取配置，还支持从远程的配置中心读取配置，使用下面的代码进行配置。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-go\" data-lang=\"go\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#a6e22e\"\u003eviper\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eAddRemoteProvider\u003c/span\u003e(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;etcd\u0026#34;\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;http://127.0.0.1:2379\u0026#34;\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;conf.toml\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#a6e22e\"\u003eviper\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eSetConfigType\u003c/span\u003e(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;toml\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#a6e22e\"\u003eerr\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e:=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eviper\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eReadRemoteConfig\u003c/span\u003e()\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eerr\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e!=\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003enil\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    panic(\u003cspan style=\"color:#a6e22e\"\u003eerr\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e运行后报错\u003ccode\u003epanic: Remote Configurations Error: No Files Found\u003c/code\u003e，检查后发现 etcd 开启了 tls，所以需要用 https 协议访问 etcd 的 API，更新代码如下。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-go\" data-lang=\"go\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#a6e22e\"\u003eviper\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eAddSecureRemoteProvider\u003c/span\u003e(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;etcd\u0026#34;\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;https://127.0.0.1:2379\u0026#34;\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;conf.toml\u0026#34;\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;key_path\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#a6e22e\"\u003eviper\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eSetConfigType\u003c/span\u003e(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;toml\u0026#34;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#a6e22e\"\u003eerr\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e:=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eviper\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eReadRemoteConfig\u003c/span\u003e()\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eerr\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e!=\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003enil\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    panic(\u003cspan style=\"color:#a6e22e\"\u003eerr\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e使用\u003ccode\u003eAddSecureRemoteProvider\u003c/code\u003e方法替换\u003ccode\u003eAddRemoteProvider\u003c/code\u003e方法，问题依旧。\u003c/p\u003e\n\u003ch3 id=\"定位问题\"\u003e定位问题\u003c/h3\u003e\n\u003cp\u003e跟踪源码发现，最终像 etcd 发送请求的是\u003ca href=\"https://github.com/coreos/go-etcd/\"\u003ego-etcd\u003c/a\u003e包（目前 go-etcd 已经不维护），在 go-etcd 的 requests.go 文件中找到了相关的源码，go-etcd 调用了 net/http 包向 etcd 发送请求。\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/images/20200416_01.jpg\"\u003e\u003c/p\u003e\n\u003cp\u003e这个时候忽然想到 etcd 的证书是自签名的，访问自签名证书的 https 接口应该会报错啊，怎么会请求到内容呢？如下图，在 Chrome 中访问 etcd 的自签名 https 接口，会提示证书无效。\u003c/p\u003e","title":"viper从etcd读取配置失败的问题"},{"content":"很多语言都提供了环境隔离的支持，例如nodejs的node_module，golang的go mod，python也有virtualenv和pyvenv等机制。为了建立依赖快照，通常会用pip freeze \u0026gt; requirements.txt 命令生成一个requirements.txt文件，在一些场景下这种方式就可以满足需求，但是在复杂场景下requirements.txt就力不从心了。\nrequirements.txt appdirs==1.4.3 astroid==2.3.3 attrs==19.3.0 black==19.3b0 certifi==2019.11.28 chardet==3.0.4 click==7.1.1 et-xmlfile==1.0.1 Flask==1.1.1 gevent==1.4.0 greenlet==0.4.15 idna==2.9 isort==4.3.21 itsdangerous==1.1.0 jdcal==1.4.1 Jinja2==2.11.1 lazy-object-proxy==1.4.3 MarkupSafe==1.1.1 mccabe==0.6.1 numpy==1.18.2 openpyxl==3.0.3 pandas==1.0.3 pylint==2.4.4 python-dateutil==2.8.1 pytz==2019.3 requests==2.23.0 six==1.14.0 tinydb==3.15.2 toml==0.10.0 typed-ast==1.4.1 urllib3==1.25.8 Werkzeug==1.0.0 wrapt==1.11.2 requirements.txt文件中只记录了依赖的版本，所以如果遇到官方的pypi源下载速度慢，需要使用更快的国内镜像下载，通常只能使用pip install -i安装或者修改全局的pip.conf文件。\n当某个项目使用确定的python版本，这个版本也并不能在requirements.txt中体现，只能通过readme或者文档来记录，并且需要在创建虚拟环境时手动调用正确的python版本。\n项目需要使用flake8、pylint、black等代码优化工具时，这些依赖也会被pip freeze命令写入requirements.txt中，然而这些依赖是不需要出现在生产环境的。\nPipfile Pipenv的出现，一举解决了上面的问题，Pipenv是Kenneth Reitz在2017年1月发布的Python依赖管理工具，他所基于的Pipfile则用来替代requirements.txt。\n[[source]] name = \u0026#34;pypi\u0026#34; url = \u0026#34;https://pypi.doubanio.com/simple\u0026#34; verify_ssl = false [dev-packages] isort = \u0026#34;*\u0026#34; black = \u0026#34;==19.3b0\u0026#34; pylint = \u0026#34;*\u0026#34; [packages] flask = \u0026#34;*\u0026#34; tinydb = \u0026#34;*\u0026#34; pandas = \u0026#34;*\u0026#34; requests = \u0026#34;*\u0026#34; gevent = \u0026#34;*\u0026#34; openpyxl = \u0026#34;*\u0026#34; [requires] python_version = \u0026#34;3.6\u0026#34; 好处1：记录内容更详细 相比于requirements.txt，Pipfile多了pip源的设置，可以针对不同项目使用不同环境。并且将依赖分为dev和默认环境，例如pylint、flake8、black等依赖，可以将他们放入dev依赖中。\n好处2：减少手动激活虚拟环境次数 pipenv将virtualenv、pyvenv和pip命令整合使用，pipenv减少了手动激活虚拟环境的次数，使用pyvenv模块运行main.py，需要先执行source venv/bin/activate激活虚拟环境，然后再执行python main.py，而pipenv只需要在项目根目录执行pipenv run main.py ，就可以自动激活当前虚拟环境并执行main.py。如果需要安装依赖的，直接执行pipenv install xxx，也不需要先激活虚拟环境，再使用pip install xxx安装。\n好处3：锁机制 从Pipfile文件添加或删除安装的包，会生成Pipfile.lock来锁定安装包的版本和依赖信息，通过pipfile.lock文件，可以精确恢复以来的版本。\n常用命令 # 初始化虚拟环境（可自己指定python版本） $ pipenv --python 3.6.9 # 激活当前项目虚拟环境 $ pipenv shell # 安装开发依赖包 $ pipenv install black --dev # 生成lock文件 $ pipenv lock ","permalink":"https://simpleapples.com/zh/posts/use-pipfile-instead-of-requirements/","summary":"\u003cp\u003e很多语言都提供了环境隔离的支持，例如nodejs的node_module，golang的go mod，python也有virtualenv和pyvenv等机制。为了建立依赖快照，通常会用\u003ccode\u003epip freeze \u0026gt; requirements.txt\u003c/code\u003e 命令生成一个requirements.txt文件，在一些场景下这种方式就可以满足需求，但是在复杂场景下requirements.txt就力不从心了。\u003c/p\u003e\n\u003ch3 id=\"requirementstxt\"\u003erequirements.txt\u003c/h3\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eappdirs==1.4.3\nastroid==2.3.3\nattrs==19.3.0\nblack==19.3b0\ncertifi==2019.11.28\nchardet==3.0.4\nclick==7.1.1\net-xmlfile==1.0.1\nFlask==1.1.1\ngevent==1.4.0\ngreenlet==0.4.15\nidna==2.9\nisort==4.3.21\nitsdangerous==1.1.0\njdcal==1.4.1\nJinja2==2.11.1\nlazy-object-proxy==1.4.3\nMarkupSafe==1.1.1\nmccabe==0.6.1\nnumpy==1.18.2\nopenpyxl==3.0.3\npandas==1.0.3\npylint==2.4.4\npython-dateutil==2.8.1\npytz==2019.3\nrequests==2.23.0\nsix==1.14.0\ntinydb==3.15.2\ntoml==0.10.0\ntyped-ast==1.4.1\nurllib3==1.25.8\nWerkzeug==1.0.0\nwrapt==1.11.2\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003erequirements.txt文件中只记录了依赖的版本，所以如果遇到官方的pypi源下载速度慢，需要使用更快的国内镜像下载，通常只能使用\u003ccode\u003epip install -i\u003c/code\u003e安装或者修改全局的pip.conf文件。\u003c/p\u003e\n\u003cp\u003e当某个项目使用确定的python版本，这个版本也并不能在requirements.txt中体现，只能通过readme或者文档来记录，并且需要在创建虚拟环境时手动调用正确的python版本。\u003c/p\u003e\n\u003cp\u003e项目需要使用flake8、pylint、black等代码优化工具时，这些依赖也会被\u003ccode\u003epip freeze\u003c/code\u003e命令写入requirements.txt中，然而这些依赖是不需要出现在生产环境的。\u003c/p\u003e\n\u003ch3 id=\"pipfile\"\u003ePipfile\u003c/h3\u003e\n\u003cp\u003ePipenv的出现，一举解决了上面的问题，Pipenv是Kenneth Reitz在2017年1月发布的Python依赖管理工具，他所基于的Pipfile则用来替代requirements.txt。\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e[[source]]\nname = \u0026#34;pypi\u0026#34;\nurl = \u0026#34;https://pypi.doubanio.com/simple\u0026#34;\nverify_ssl = false\n\n[dev-packages]\nisort = \u0026#34;*\u0026#34;\nblack = \u0026#34;==19.3b0\u0026#34;\npylint = \u0026#34;*\u0026#34;\n\n[packages]\nflask = \u0026#34;*\u0026#34;\ntinydb = \u0026#34;*\u0026#34;\npandas = \u0026#34;*\u0026#34;\nrequests = \u0026#34;*\u0026#34;\ngevent = \u0026#34;*\u0026#34;\nopenpyxl = \u0026#34;*\u0026#34;\n\n[requires]\npython_version = \u0026#34;3.6\u0026#34;\n\u003c/code\u003e\u003c/pre\u003e\u003ch4 id=\"好处1记录内容更详细\"\u003e好处1：记录内容更详细\u003c/h4\u003e\n\u003cp\u003e相比于requirements.txt，Pipfile多了pip源的设置，可以针对不同项目使用不同环境。并且将依赖分为dev和默认环境，例如pylint、flake8、black等依赖，可以将他们放入dev依赖中。\u003c/p\u003e","title":"使用Pipfile代替reqirements.txt"},{"content":"问题现象 在制作 docker 镜像时，有复制某一个路径下所有文件和文件夹到镜像的需求，写下了如下 dockerfile：\nFROM alpine WORKDIR /root/test_docker_proj COPY * ./ 原始目录结构是这样的：\n/projects/test_docker_proj ├── Dockerfile ├── dir1 │ ├── dir11 │ │ └── file11 │ └── file1 └── file2 然而复制到 docker 镜像里的目录结构变成了这样：\n/root/test_docker_proj ├── Dockerfile ├── dir11 │ └── file11 ├── file1 └── file2 可以看到 dir1 这个文件夹并没有被复制到镜像里，但是 dir1 中的子文件夹和文件都被复制进来了，和 dir1 同级的文件也被复制了。也就是说，在 COPY 执行的过程中，第一层文件夹被「解包」了。\nCOPY/ADD 行为逻辑 为了确定 COPY 和相似的 ADD 命令的行为，做了以下测试：\nFROM alpine WORKDIR /root/test_docker_proj_1 COPY * ./ WORKDIR /root/test_docker_proj_2 ADD * ./ WORKDIR /root/test_docker_proj_3 COPY ./ ./ WORKDIR /root/test_docker_proj_4 ADD ./ ./ WORKDIR /root/test_docker_proj_5 COPY ./dir* ./ WORKDIR /root/test_docker_proj_6 ADD ./dir* ./ 通过测试可以发现 COPY/ADD 命令有这么几个规则：\nADD 命令和 COPY 命令在复制文件时行为一致 使用 * 作为 COPY/ADD 命令的源时候表示的是 ./* COPY/ADD 命令的源如果是文件夹，复制的是文件夹的内容而不是其本身 COPY ./* target 中的 * 会被翻译成如下的逻辑： COPY ./sub_dir1 target COPY ./sub_dir2 target COPY ./file1 target COPY ./file2 target 文件系统里的文件夹和文件，本质上都是文件，我们熟悉的操作系统的 cp 命令在执行 cp * target 时会把文件夹当成文件一股脑的复制到目标路径下，可以认为复制了文件本身，而 docker 的 COPY/ADD 在复制文件夹时复制的是其内容。\ndocker 的这种「奇怪」的逻辑已经被诟病许久了，但是似乎还没有要改变的意思，最新的进展可以参考下面两个 issue，在 docker 做出修改之前，只能在写 dockerfile 时候注意一下了。\n参考文档 https://stackoverflow.com/questions/30256386/how-to-copy-multiple-files-in-one-layer-using-a-dockerfile\nhttps://github.com/moby/moby/issues/15858\nhttps://github.com/moby/moby/issues/29211\n","permalink":"https://simpleapples.com/zh/posts/dockers-creepy-behaviour-in-copying-folders/","summary":"\u003ch3 id=\"问题现象\"\u003e问题现象\u003c/h3\u003e\n\u003cp\u003e在制作 docker 镜像时，有复制某一个路径下所有文件和文件夹到镜像的需求，写下了如下 dockerfile：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-dockerfile\" data-lang=\"dockerfile\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eFROM\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e alpine\u003c/span\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eWORKDIR\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e /root/test_docker_proj\u003c/span\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eCOPY\u003c/span\u003e * ./\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e原始目录结构是这样的：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e/projects/test_docker_proj\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e├── Dockerfile\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e├── dir1\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e│   ├── dir11\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e│   │   └── file11\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e│   └── file1\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e└── file2\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e然而复制到 docker 镜像里的目录结构变成了这样：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e/root/test_docker_proj\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e├── Dockerfile\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e├── dir11\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e│   └── file11\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e├── file1\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e└── file2\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c!-- more --\u003e\n\u003cp\u003e可以看到 dir1 这个文件夹并没有被复制到镜像里，但是 dir1 中的子文件夹和文件都被复制进来了，和 dir1 同级的文件也被复制了。也就是说，在 COPY 执行的过程中，第一层文件夹被「解包」了。\u003c/p\u003e\n\u003ch3 id=\"copyadd-行为逻辑\"\u003eCOPY/ADD 行为逻辑\u003c/h3\u003e\n\u003cp\u003e为了确定 COPY 和相似的 ADD 命令的行为，做了以下测试：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-dockerfile\" data-lang=\"dockerfile\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eFROM\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e alpine\u003c/span\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eWORKDIR\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e /root/test_docker_proj_1\u003c/span\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eCOPY\u003c/span\u003e * ./\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eWORKDIR\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e /root/test_docker_proj_2\u003c/span\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eADD\u003c/span\u003e * ./\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eWORKDIR\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e /root/test_docker_proj_3\u003c/span\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eCOPY\u003c/span\u003e ./ ./\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eWORKDIR\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e /root/test_docker_proj_4\u003c/span\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eADD\u003c/span\u003e ./ ./\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eWORKDIR\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e /root/test_docker_proj_5\u003c/span\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eCOPY\u003c/span\u003e ./dir* ./\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eWORKDIR\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e /root/test_docker_proj_6\u003c/span\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eADD\u003c/span\u003e ./dir* ./\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e通过测试可以发现 \u003ccode\u003eCOPY/ADD\u003c/code\u003e 命令有这么几个规则：\u003c/p\u003e","title":"Docker COPY 复制文件夹的诡异行为"},{"content":"问题描述 使用 Pandas 的 read_excel 方法读取一个 16 万行的 Excel 文件报 AssertionError 错误：\n\u0026#34;/Users/XXX/excel_test/venv/lib/python3.7/site-packages/xlrd/xlsx.py\u0026#34;, line 637, in do_row assert 0 \u0026lt;= self.rowx \u0026lt; X12_MAX_ROWS AssertionError 背后原理 Excel 文件有两种默认格式，在 Excel 2007 以前，使用扩展名为 .xls 格式的文件，这种文件格式是一种特定的二进制格式，最多支持 65,536 行（在 Excel 97 之前支持的最大行数是 16,384），256 列表格。从 Excel 2007 版开始，默认采用了基于 XML 的新的文件格式 .xlsx，支持的表格行数达到了 1,048,576，列数达到了 16,384。需要注意的是，将 .xlsx 格式的文件转换为 .xls 格式的文件时，65,536 行和 256 列之后的数据都会被丢弃。\n版本 最大行数 最大列数 文件格式 Excel 97 之前 16,384 256 .xls Excel 97 到 Excel 2003 65,536 256 .xls Excel 2007 及以后版本 1,048,576 16,384 .xlsx Pandas 读取 Excel 文件的引擎是 xlrd，xlrd 在读取 Excel 文件时，xlrd/xlsx.py 文件的 637 行会对行号做断言，判断行号是否在 0 - 1,048,576（Excel支持的最大行数） 的范围内。这段代码是这样的：\nrow_number = row_elem.get(\u0026#39;r\u0026#39;) if row_number is None: # Yes, it\u0026#39;s optional. self.rowx += 1 explicit_row_number = 0 if self.verbosity and not self.warned_no_row_num: self.dumpout(\u0026#34;no row number; assuming rowx=%d\u0026#34;, self.rowx) self.warned_no_row_num = 1 else: self.rowx = row_number - 1 explicit_row_number = 1 assert 0 \u0026lt;= self.rowx \u0026lt; X12_MAX_ROWS 代码会从 Excel 文件中获取 row_number，这个 row_number 是每一行的行号，正常文件行号从 1 开始，而出现问题的文件行号从 0 开始，当行号为 0，进入 else 语句，导致越界问题。\n解决办法 除了 xlrd， Pandas 还支持 openpyxl（0.25 版），openpyxl 是一个专门用来操作 .xlsx 格式文件的 Python 库，和 xlrd 相比它的速度会慢一些，但是不会碰到上面所说的问题。这是 openpyxl 中 reader/excel.py 文件处理行的代码：\ndef parse_row(self, row): attrs = dict(row.attrib) if \u0026#34;r\u0026#34; in attrs: self.max_row = int(attrs[\u0026#39;r\u0026#39;]) else: self.max_row += 1 keys = set(attrs) for key in keys: if key.startswith(\u0026#39;{\u0026#39;): del attrs[key] keys = set(attrs) if keys != set([\u0026#39;r\u0026#39;, \u0026#39;spans\u0026#39;]) and keys != set([\u0026#39;r\u0026#39;]): # don\u0026#39;t create dimension objects unless they have relevant information self.row_dimensions[attrs[\u0026#39;r\u0026#39;]] = attrs cells = [self.parse_cell(el) for el in row] return self.max_row, cells openpyxl 在处理行时，并没有对行号进行断言，即使行号第一位是 0，也不会导致报错，但这会导致第一行数据的缺失，需要进行额外处理。\n使用 Pandas + openpyxl 读取 Excel 文件 首先安装 openpyxl：\npip install openpyxl Pandas 的 read_excel 方法中，有 engine 字段，可以指定所使用的处理 Excel 文件的引擎，填入 openpyxl，再读取文件就可以了。\nimport pandas as pd df = pd.read_excel(\u0026#39;./data.xlsx\u0026#39;, engine=\u0026#39;openpyxl\u0026#39;) print(len(df)) # 160000 参考文档 https://office-watch.com/2010/excel-a-history-of-rows-and-columns/\nhttps://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.read_excel.html\nhttps://github.com/python-excel/xlrd/\nhttps://bitbucket.org/openpyxl/openpyxl/src\n","permalink":"https://simpleapples.com/zh/posts/solution-for-pandas-assertion-error-while-reading-an-excel-file/","summary":"\u003ch3 id=\"问题描述\"\u003e问题描述\u003c/h3\u003e\n\u003cp\u003e使用 Pandas 的 \u003ccode\u003eread_excel\u003c/code\u003e 方法读取一个 16 万行的 Excel 文件报 \u003ccode\u003eAssertionError\u003c/code\u003e 错误：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e  \u0026#34;/Users/XXX/excel_test/venv/lib/python3.7/site-packages/xlrd/xlsx.py\u0026#34;, line 637, in do_row\n    assert 0 \u0026lt;= self.rowx \u0026lt; X12_MAX_ROWS\nAssertionError\n\u003c/code\u003e\u003c/pre\u003e\u003c!-- more --\u003e \n\u003ch3 id=\"背后原理\"\u003e背后原理\u003c/h3\u003e\n\u003cp\u003eExcel 文件有两种默认格式，在 Excel 2007 以前，使用扩展名为 \u003ccode\u003e.xls\u003c/code\u003e 格式的文件，这种文件格式是一种特定的二进制格式，最多支持 65,536 行（在 Excel 97 之前支持的最大行数是 16,384），256 列表格。从 Excel 2007 版开始，默认采用了基于 XML 的新的文件格式 \u003ccode\u003e.xlsx\u003c/code\u003e，支持的表格行数达到了 1,048,576，列数达到了 16,384。需要注意的是，将 \u003ccode\u003e.xlsx\u003c/code\u003e 格式的文件转换为 \u003ccode\u003e.xls\u003c/code\u003e 格式的文件时，65,536 行和 256 列之后的数据都会被丢弃。\u003c/p\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003e版本\u003c/th\u003e\n          \u003cth\u003e最大行数\u003c/th\u003e\n          \u003cth\u003e最大列数\u003c/th\u003e\n          \u003cth\u003e文件格式\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eExcel 97 之前\u003c/td\u003e\n          \u003ctd\u003e16,384\u003c/td\u003e\n          \u003ctd\u003e256\u003c/td\u003e\n          \u003ctd\u003e.xls\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eExcel 97 到 Excel 2003\u003c/td\u003e\n          \u003ctd\u003e65,536\u003c/td\u003e\n          \u003ctd\u003e256\u003c/td\u003e\n          \u003ctd\u003e.xls\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003eExcel 2007 及以后版本\u003c/td\u003e\n          \u003ctd\u003e1,048,576\u003c/td\u003e\n          \u003ctd\u003e16,384\u003c/td\u003e\n          \u003ctd\u003e.xlsx\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003ePandas 读取 Excel 文件的引擎是 \u003ccode\u003exlrd\u003c/code\u003e，\u003ccode\u003exlrd\u003c/code\u003e 在读取 Excel 文件时，\u003ca href=\"https://github.com/python-excel/xlrd/blob/master/xlrd/xlsx.py\"\u003e\u003ccode\u003exlrd/xlsx.py\u003c/code\u003e\u003c/a\u003e 文件的 637 行会对行号做断言，判断行号是否在 0 - 1,048,576（Excel支持的最大行数） 的范围内。这段代码是这样的：\u003c/p\u003e","title":"探究 Pandas 读取 Excel 文件报错问题"},{"content":"问题描述 在使用 docker build 打包镜像时，遇到了需要使用代理访问网络的需求。使用如下的 Dockerfile 来模拟这个场景：\nFROM golang:1.12 RUN curl www.google.com --max-time 3 国内一般网络环境下，curl www.google.com 是无法正常返回的，加入 \u0026ndash;max-time 让 curl 的耗时不要太长。\n配置 http_proxy 变量 首先需要在环境变量中设置 http_proxy 和 https_proxy，使得访问网络的命令（这里使用 curl 来代表）能够通过环境变量中配置的代理服务器访问 www.google.com。\ndocker build 命令虽然是在 docker 所在的宿主机上执行的，看上去像是直接使用了宿主机的网络环境，但实际上 docker build 也是启动了一个 container 进行构建，所以在构建过程中的所有命令都是在 container 中执行的，http_proxy 和 https_proxy 的配置也应该是在 container 中进行的。可以使用 ENV 来配置 container 中的环境变量。\n代理服务器启动在宿主机的 1087 端口上，修改 dockerfile 文件：\nFROM golang:1.12 ENV http_proxy \u0026#34;http://127.0.0.1:1087\u0026#34; ENV HTTP_PROXY \u0026#34;http://127.0.0.1:1087\u0026#34; ENV https_proxy \u0026#34;http://127.0.0.1:1087\u0026#34; ENV HTTPS_PROXY \u0026#34;http://127.0.0.1:1087\u0026#34; RUN curl www.google.com --max-time 3 重新执行 docker build 会发现 curl 依旧无法访问 www.google.com，从报错信息上可以看到 127.0.0.1 上的 1087 端口上并没有服务。\n访问宿主机 由于 container 默认是桥接网络，宿主机和 container 是平级的，被放在了一个虚拟的网段里。访问宿主机上的代理服务器，对于 container 来说实际上是访问另一台机器上的服务器，127.0.0.1 指向的是 container 本身。在 docker 默认的桥接网络中，宿主机的 IP 一般是 172.17.0.1（Linux），或者 192.168.65.1（MacOS），可以将 http_proxy 中的 IP 换成 172.17.0.1/192.168.65.1，来实现通过宿主的代理服务器访问网络，修改 dockerfile：\nFROM golang:1.12 ENV http_proxy \u0026#34;http://172.17.0.1:1087\u0026#34; ENV HTTP_PROXY \u0026#34;http://172.17.0.1:1087\u0026#34; ENV https_proxy \u0026#34;http://172.17.0.1:1087\u0026#34; ENV HTTPS_PROXY \u0026#34;http://172.17.0.1:1087\u0026#34; RUN curl www.google.com --max-time 3 虽然使用这种方式可以达到目的，但是如果编译环境变了或者代理服务器的配置变了，哪怕只是操作系统从 Linux 变成了 MacOS，都得修改 dockerfile，显然不够解耦，也不方便。\n配置网络模式 docker 中还有一种 host 网络模式，就是让 container 使用宿主机的网络，相当于 container 在网络层面和宿主机不做隔离，使用这种网络模式执行 docker build，就不需要在 dockerfile 中添加 http_proxy 环境变量，container 可以直接读取宿主上的环境变量。\n首先在宿主上导入 http_proxy 环境变量：\nexport http_proxy=\u0026#34;http://127.0.0.1:1087\u0026#34; export HTTP_PROXY=\u0026#34;http://127.0.0.1:1087\u0026#34; export https_proxy=\u0026#34;http://127.0.0.1:1087\u0026#34; export HTTPS_PROXY=\u0026#34;http://127.0.0.1:1087\u0026#34; 接下来将 dockerfile 简化：\nFROM golang:1.12 RUN curl www.google.com --max-time 3 重新执行 docker build，加上参数 \u0026ndash;network host，使用宿主网络：\ndocker build --network host . 执行后 curl 就可以像在宿主上直接执行一样，通过代理访问 www.google.com 了。\n","permalink":"https://simpleapples.com/zh/posts/building-docker-image-behind-proxy/","summary":"\u003ch3 id=\"问题描述\"\u003e问题描述\u003c/h3\u003e\n\u003cp\u003e在使用 docker build 打包镜像时，遇到了需要使用代理访问网络的需求。使用如下的 Dockerfile 来模拟这个场景：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-dockerfile\" data-lang=\"dockerfile\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eFROM\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e golang:1.12\u003c/span\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eRUN\u003c/span\u003e curl www.google.com --max-time \u003cspan style=\"color:#ae81ff\"\u003e3\u003c/span\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e国内一般网络环境下，curl \u003ca href=\"https://www.google.com\"\u003ewww.google.com\u003c/a\u003e 是无法正常返回的，加入 \u0026ndash;max-time 让 curl 的耗时不要太长。\u003c/p\u003e\n\u003c!-- more --\u003e\n\u003ch3 id=\"配置-http_proxy-变量\"\u003e配置 http_proxy 变量\u003c/h3\u003e\n\u003cp\u003e首先需要在环境变量中设置 http_proxy 和 https_proxy，使得访问网络的命令（这里使用 curl 来代表）能够通过环境变量中配置的代理服务器访问 \u003ca href=\"https://www.google.com\"\u003ewww.google.com\u003c/a\u003e。\u003c/p\u003e\n\u003cp\u003edocker build 命令虽然是在 docker 所在的宿主机上执行的，看上去像是直接使用了宿主机的网络环境，但实际上 docker build 也是启动了一个 container 进行构建，所以在构建过程中的所有命令都是在 container 中执行的，http_proxy 和 https_proxy 的配置也应该是在 container 中进行的。可以使用 ENV 来配置 container 中的环境变量。\u003c/p\u003e\n\u003cp\u003e代理服务器启动在宿主机的 1087 端口上，修改 dockerfile 文件：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-dockerfile\" data-lang=\"dockerfile\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eFROM\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e golang:1.12\u003c/span\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eENV\u003c/span\u003e http_proxy \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;http://127.0.0.1:1087\u0026#34;\u003c/span\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eENV\u003c/span\u003e HTTP_PROXY \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;http://127.0.0.1:1087\u0026#34;\u003c/span\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eENV\u003c/span\u003e https_proxy \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;http://127.0.0.1:1087\u0026#34;\u003c/span\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eENV\u003c/span\u003e HTTPS_PROXY \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;http://127.0.0.1:1087\u0026#34;\u003c/span\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eRUN\u003c/span\u003e curl www.google.com --max-time \u003cspan style=\"color:#ae81ff\"\u003e3\u003c/span\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e重新执行 docker build 会发现 curl 依旧无法访问 \u003ca href=\"https://www.google.com\"\u003ewww.google.com\u003c/a\u003e，从报错信息上可以看到 127.0.0.1 上的 1087 端口上并没有服务。\u003c/p\u003e","title":"使用代理进行 docker build 问题的解决思路"},{"content":"关于 count 函数的使用一直存在争议，尤其是在 MySQL 中，作为流行度越来越高的 PostgreSQL 是否也有类似的问题呢，我们通过实践来理解一下 PostgreSQL 中 count 函数的行为。\n构建测试数据库 创建测试数据库，并创建测试表。测试表中有自增 ID、创建时间、内容三个字段，自增 ID 字段是主键。\ncreate database performance_test; create table test_tbl (id serial primary key, created_at timestamp, content varchar(512)); 生成测试数据 使用 generate_series 函数生成自增 ID，使用 now() 函数生成 created_at 列，对于 content 列，使用了 repeat(md5(random()::text), 10) 生成 10 个 32 位长度的 md5 字符串。使用下列语句，插入 1000w 条记录用于测试。\nperformance_test=# insert into test_tbl select generate_series(1,10000000),now(),repeat(md5(random()::text),10); INSERT 0 10000000 Time: 212184.223 ms (03:32.184) 由 count 语句引发的思考 默认情况下 PostgreSQL 不开启 SQL 执行时间的显示，所以需要手动开启一下，方便后面的测试对比。\n\\timing on count(*) 和 count(1) 的性能区别是经常被讨论的问题，分别使用 count(*) 和 count(1) 执行一次查询。\nperformance_test=# select count(*) from test_tbl; count ---------- 10000000 (1 row) Time: 115090.380 ms (01:55.090) performance_test=# select count(1) from test_tbl; count ---------- 10000000 (1 row) Time: 738.502 ms 可以看到两次查询的速度差别非常大，count(1) 真的有这么大的性能提升？接下来再次运行查询语句。\nperformance_test=# select count(*) from test_tbl; count ---------- 10000000 (1 row) Time: 657.831 ms performance_test=# select count(1) from test_tbl; count ---------- 10000000 (1 row) Time: 682.157 ms 可以看到第一次查询时候会非常的慢，后面三次速度非常快并且时间相近，这里就有两个问题出现了：\n为什么第一次查询速度这么慢？ count(*) 和 count(1) 到底存不存在性能差别？ 查询缓存 使用 explain 语句重新执行查询语句\nexplain (analyze,buffers,verbose) select count(*) from test_tbl; 可以看到如下输出：\nFinalize Aggregate (cost=529273.69..529273.70 rows=1 width=8) (actual time=882.569..882.570 rows=1 loops=1) Output: count(*) Buffers: shared hit=96 read=476095 -\u0026gt; Gather (cost=529273.48..529273.69 rows=2 width=8) (actual time=882.492..884.170 rows=3 loops=1) Output: (PARTIAL count(*)) Workers Planned: 2 Workers Launched: 2 Buffers: shared hit=96 read=476095 -\u0026gt; Partial Aggregate (cost=528273.48..528273.49 rows=1 width=8) (actual time=881.014..881.014 rows=1 loops=3) Output: PARTIAL count(*) Buffers: shared hit=96 read=476095 Worker 0: actual time=880.319..880.319 rows=1 loops=1 Buffers: shared hit=34 read=158206 Worker 1: actual time=880.369..880.369 rows=1 loops=1 Buffers: shared hit=29 read=156424 -\u0026gt; Parallel Seq Scan on public.test_tbl (cost=0.00..517856.98 rows=4166598 width=0) (actual time=0.029..662.165 rows=3333333 loops=3) Buffers: shared hit=96 read=476095 Worker 0: actual time=0.026..661.807 rows=3323029 loops=1 Buffers: shared hit=34 read=158206 Worker 1: actual time=0.030..660.197 rows=3285513 loops=1 Buffers: shared hit=29 read=156424 Planning time: 0.043 ms Execution time: 884.207 ms 注意里面的 shared hit，表示命中了内存中缓存的数据，这就可以解释为什么后面的查询会比第一次快很多。接下来去掉缓存，并重启 PostgreSQL。\nservice postgresql stop echo 1 \u0026gt; /proc/sys/vm/drop_caches service postgresql start 重新执行 SQL 语句，速度慢了很多。\nFinalize Aggregate (cost=529273.69..529273.70 rows=1 width=8) (actual time=50604.564..50604.564 rows=1 loops=1) Output: count(*) Buffers: shared read=476191 -\u0026gt; Gather (cost=529273.48..529273.69 rows=2 width=8) (actual time=50604.508..50606.141 rows=3 loops=1) Output: (PARTIAL count(*)) Workers Planned: 2 Workers Launched: 2 Buffers: shared read=476191 -\u0026gt; Partial Aggregate (cost=528273.48..528273.49 rows=1 width=8) (actual time=50591.550..50591.551 rows=1 loops=3) Output: PARTIAL count(*) Buffers: shared read=476191 Worker 0: actual time=50585.182..50585.182 rows=1 loops=1 Buffers: shared read=158122 Worker 1: actual time=50585.181..50585.181 rows=1 loops=1 Buffers: shared read=161123 -\u0026gt; Parallel Seq Scan on public.test_tbl (cost=0.00..517856.98 rows=4166598 width=0) (actual time=92.491..50369.691 rows=3333333 loops=3) Buffers: shared read=476191 Worker 0: actual time=122.170..50362.271 rows=3320562 loops=1 Buffers: shared read=158122 Worker 1: actual time=14.020..50359.733 rows=3383583 loops=1 Buffers: shared read=161123 Planning time: 11.537 ms Execution time: 50606.215 ms shared read 表示没有命中缓存，通过这个现象可以推断出，上一小节的四次查询中，第一次查询没有命中缓存，剩下三次查询都命中了缓存。\ncount(1) 和 count(*) 的区别 接下来探究 count(1) 和 count(*) 的区别是什么，继续思考最开始的四次查询，第一次查询使用了 count(*)，第二次查询使用了 count(1) ，却依然命中了缓存，不正是说明 count(1) 和 count(*) 是一样的吗？\n事实上，PostgreSQL 官方对于 is there a difference performance-wise between select count(1) and select count(*)? 问题的回复也证实了这一点：\nNope. In fact, the latter is converted to the former during parsing.[2]\n既然 count(1) 在性能上没有比 count(*) 更好，那么使用 count(*) 就是更好的选择。\nsequence scan 和 index scan 接下来测试一下，在不同数据量大小的情况下 count(*) 的速度，将查询语句写在 count.sql 文件中，使用 pgbench 进行测试。\npgbench -c 5 -t 20 performance_test -r -f count.sql 分别测试 200w - 1000w 数据量下的 count 语句耗时\n数据大小 count 耗时(ms) 200w 738.758 300w 1035.846 400w 1426.183 500w 1799.866 600w 2117.247 700w 2514.691 800w 2526.441 900w 2568.240 1000w 2650.434 绘制成耗时曲线\n曲线的趋势在 600w - 700w 数据量之间出现了转折，200w - 600w 是线性增长，600w 之后 count 的耗时就基本相同了。使用 explain 语句分别查看 600w 和 700w 数据时的 count 语句执行。\n700w：\nFinalize Aggregate (cost=502185.93..502185.94 rows=1 width=8) (actual time=894.361..894.361 rows=1 loops=1) Output: count(*) Buffers: shared hit=16344 read=352463 -\u0026gt; Gather (cost=502185.72..502185.93 rows=2 width=8) (actual time=894.232..899.763 rows=3 loops=1) Output: (PARTIAL count(*)) Workers Planned: 2 Workers Launched: 2 Buffers: shared hit=16344 read=352463 -\u0026gt; Partial Aggregate (cost=501185.72..501185.73 rows=1 width=8) (actual time=889.371..889.371 rows=1 loops=3) Output: PARTIAL count(*) Buffers: shared hit=16344 read=352463 Worker 0: actual time=887.112..887.112 rows=1 loops=1 Buffers: shared hit=5459 read=118070 Worker 1: actual time=887.120..887.120 rows=1 loops=1 Buffers: shared hit=5601 read=117051 -\u0026gt; Parallel Index Only Scan using test_tbl_pkey on public.test_tbl (cost=0.43..493863.32 rows=2928960 width=0) (actual time=0.112..736.376 rows=2333333 loops=3) Index Cond: (test_tbl.id \u0026lt; 7000000) Heap Fetches: 2328492 Buffers: shared hit=16344 read=352463 Worker 0: actual time=0.107..737.180 rows=2344479 loops=1 Buffers: shared hit=5459 read=118070 Worker 1: actual time=0.133..737.960 rows=2327028 loops=1 Buffers: shared hit=5601 read=117051 Planning time: 0.165 ms Execution time: 899.857 ms 600w：\nFinalize Aggregate (cost=429990.94..429990.95 rows=1 width=8) (actual time=765.575..765.575 rows=1 loops=1) Output: count(*) Buffers: shared hit=13999 read=302112 -\u0026gt; Gather (cost=429990.72..429990.93 rows=2 width=8) (actual time=765.557..770.889 rows=3 loops=1) Output: (PARTIAL count(*)) Workers Planned: 2 Workers Launched: 2 Buffers: shared hit=13999 read=302112 -\u0026gt; Partial Aggregate (cost=428990.72..428990.73 rows=1 width=8) (actual time=763.821..763.821 rows=1 loops=3) Output: PARTIAL count(*) Buffers: shared hit=13999 read=302112 Worker 0: actual time=762.742..762.742 rows=1 loops=1 Buffers: shared hit=4638 read=98875 Worker 1: actual time=763.308..763.308 rows=1 loops=1 Buffers: shared hit=4696 read=101570 -\u0026gt; Parallel Index Only Scan using test_tbl_pkey on public.test_tbl (cost=0.43..422723.16 rows=2507026 width=0) (actual time=0.053..632.199 rows=2000000 loops=3) Index Cond: (test_tbl.id \u0026lt; 6000000) Heap Fetches: 2018490 Buffers: shared hit=13999 read=302112 Worker 0: actual time=0.059..633.156 rows=1964483 loops=1 Buffers: shared hit=4638 read=98875 Worker 1: actual time=0.038..634.271 rows=2017026 loops=1 Buffers: shared hit=4696 read=101570 Planning time: 0.055 ms Execution time: 770.921 ms 根据以上现象推断，PostgreSQL 似乎在 count 的数据量小于数据表长度的某一比例时，才使用 index scan，通过查看官方 wiki 也可以看到相关描述：\nIt is important to realise that the planner is concerned with minimising the total cost of the query. With databases, the cost of I/O typically dominates. For that reason, \u0026ldquo;count(*) without any predicate\u0026rdquo; queries will only use an index-only scan if the index is significantly smaller than its table. This typically only happens when the table\u0026rsquo;s row width is much wider than some indexes\u0026rsquo;.[3]\n根据 Stackoverflow 上的回答，count 语句查询的数量大于表大小的 3/4 时候就会用使用全表扫描代替索引扫描[4]。\n结论 不要用 count(1) 或 count(列名) 代替 count(*) count 本身是非常耗时的 count 可能是 index scan 也可能是 sequence scan，取决于 count 数量占表大小的比例 参考资料 [1] 深入理解 Postgres 中的 cache\n[2] Re: performance difference in count(1) vs. count(*)?\n[3] Is \u0026ldquo;count(*)\u0026rdquo; much faster now?\n[4] PostgreSQL not using index during count(*)\n","permalink":"https://simpleapples.com/zh/posts/understanding-postgres-count-function/","summary":"\u003cp\u003e关于 count 函数的使用一直存在争议，尤其是在 MySQL 中，作为流行度越来越高的 PostgreSQL 是否也有类似的问题呢，我们通过实践来理解一下 PostgreSQL 中 count 函数的行为。\u003c/p\u003e\n\u003c!-- more --\u003e\n\u003ch3 id=\"构建测试数据库\"\u003e构建测试数据库\u003c/h3\u003e\n\u003cp\u003e创建测试数据库，并创建测试表。测试表中有自增 ID、创建时间、内容三个字段，自增 ID 字段是主键。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-sql\" data-lang=\"sql\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003ecreate\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003edatabase\u003c/span\u003e performance_test;\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003ecreate\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003etable\u003c/span\u003e test_tbl (id serial \u003cspan style=\"color:#66d9ef\"\u003eprimary\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003ekey\u003c/span\u003e, created_at \u003cspan style=\"color:#66d9ef\"\u003etimestamp\u003c/span\u003e, content varchar(\u003cspan style=\"color:#ae81ff\"\u003e512\u003c/span\u003e));\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"生成测试数据\"\u003e生成测试数据\u003c/h3\u003e\n\u003cp\u003e使用 generate_series 函数生成自增 ID，使用 now() 函数生成 created_at 列，对于 content 列，使用了 repeat(md5(random()::text), 10) 生成 10 个 32 位长度的 md5 字符串。使用下列语句，插入 1000w 条记录用于测试。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-sql\" data-lang=\"sql\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eperformance_test\u003cspan style=\"color:#f92672\"\u003e=#\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003einsert\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003einto\u003c/span\u003e test_tbl \u003cspan style=\"color:#66d9ef\"\u003eselect\u003c/span\u003e generate_series(\u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e,\u003cspan style=\"color:#ae81ff\"\u003e10000000\u003c/span\u003e),now(),repeat(md5(random()::text),\u003cspan style=\"color:#ae81ff\"\u003e10\u003c/span\u003e);\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eINSERT\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e10000000\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eTime: \u003cspan style=\"color:#ae81ff\"\u003e212184\u003c/span\u003e.\u003cspan style=\"color:#ae81ff\"\u003e223\u003c/span\u003e ms (\u003cspan style=\"color:#ae81ff\"\u003e03\u003c/span\u003e:\u003cspan style=\"color:#ae81ff\"\u003e32\u003c/span\u003e.\u003cspan style=\"color:#ae81ff\"\u003e184\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"由-count-语句引发的思考\"\u003e由 count 语句引发的思考\u003c/h3\u003e\n\u003cp\u003e默认情况下 PostgreSQL 不开启 SQL 执行时间的显示，所以需要手动开启一下，方便后面的测试对比。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-sql\" data-lang=\"sql\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\\\u003c/span\u003etiming \u003cspan style=\"color:#66d9ef\"\u003eon\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003ecount(*) 和 count(1) 的性能区别是经常被讨论的问题，分别使用 count(*) 和 count(1) 执行一次查询。\u003c/p\u003e","title":"理解 PostgreSQL 的 count 函数的行为"},{"content":"现象 刚签发的 JWT，在下一个请求使用时候会失效，请求会报 422 错误。\n{ \u0026#34;msg\u0026#34;: \u0026#34;The token is not yet valid (nbf)\u0026#34; } 如果隔几秒再请求（例如使用 Chrome 开发者工具中的 Replay XHR），就会成功。\nnbf 字段的原理 查看上面的报错信息，会发现有一个 nbf，nbf 是 JWT 协议中的一个字段，是 Not Before 的缩写，表示 JWT Token 在这个时间之前是无效的，一般来讲会设置成签发的时间。这里产生了一个猜想，多服务器环境时候，服务器之间时间如果不一致，一台服务器签发的 token 如果立刻被发往另一台服务器验证，就很容易产生 nbf 字段验证不通过的问题。其实 JWT 协议已经考虑到了这类问题，所以协议中在 nbf 这一节专门提到了可以使用一个 small leeway 来解决这个问题。\n4.1.5. \u0026ldquo;nbf\u0026rdquo; (Not Before) Claim\nThe \u0026ldquo;nbf\u0026rdquo; (not before) claim identifies the time before which the JWT MUST NOT be accepted for processing. The processing of the \u0026ldquo;nbf\u0026rdquo; claim requires that the current date/time MUST be after or equal to the not-before date/time listed in the \u0026ldquo;nbf\u0026rdquo; claim. Implementers MAY provide for some small leeway, usually no more than a few minutes, to account for clock skew. Its value MUST be a number containing a NumericDate value. Use of this claim is OPTIONAL.\n既然文档考虑到了这个问题，我们再来看一下代码是怎么实现的，我们使用的是 flask-jwt-extended 这个库来实现 JWT 的签发和验签，flask-jwt-extended 依赖的是 PyJWT 这个库，所以在 PyJWT 源码中查找一下这个错误。\ndef _validate_nbf(self, payload, now, leeway): try: nbf = int(payload[\u0026#39;nbf\u0026#39;]) except ValueError: raise DecodeError(\u0026#39;Not Before claim (nbf) must be an integer.\u0026#39;) if nbf \u0026gt; (now + leeway): raise ImmatureSignatureError(\u0026#39;The token is not yet valid (nbf)\u0026#39;) 可以看出，这个报错的确是在验证 nbf 字段时候出现的，如果 nbf 的时间晚于当前的时间加上一个 leeway，就会抛出错误，而从 flask_jwt_extended 源码中可以看到，这个 leeway 字段是用户设置的，而我们设置为了 0，也就是说不存在余量时间，这就要求服务器之间的时间同步，才能不出现 nbf 字段验证不通过的问题。\n验证问题 后端应用跑在多个节点中，使用 ansible 来同时获取多台机器的时间。\nansible machine_group -m command -a \u0026#39;date\u0026#39; 需要注意的是，ansible 默认的并发数是 5，机器多的情况下需要修改 ansible.cfg 中的 forks，这样能保证获取时间的操作尽可能在同一时间发起。\n[defaults] host_key_checking = False forks = 10 可以看到，不同的机器上的时间并没有同步，并且差异比较大，甚至达到了 2 分钟，这样无疑会造成 nbf 字段验签不通过。\n解决问题：配置 Linux 自动时间同步 因为多个服务器节点之间时间差太大，所以首先解决服务器之间时间不同步的问题，以 Ubuntu 为例，步骤如下：\n安装 Chrony。\nsudo apt install chrony 安装后 chrony 就会和默认 ntp 服务器进行同步，各个云环境都有自己的 ntp 服务器，在 /etc/chrony/chrony.conf 中可以配置首选 ntp 服务器，例如 aws 环境，需要在所有服务器前增加如下服务器。实测 aws 环境中并不能使用其他的 ntp 服务器（包括国家授时中心、阿里云 ntp 服务器）。\nserver 169.254.169.123 prefer iburst 重启 chrony 服务。\nsudo systemctl restart chrony 查看是否生效。\nsudo chronyc tracking 如果状态中有如下语句表示正常\nLeap status : Normal 将所有节点同步过时间后，再次测试，发现问题消失。\n上面过程是所有服务器节点都与时间服务器的时间进行同步，如果在网络隔离的环境中，可以选择一台节点作为授时服务器，其他节点与这台服务器进行时间同步。\n更进一步：增加 leeway 虽然同步时间过后问题已经消失，但是服务器之间仍然可能会产生微小的时间差，可以通过增加 leeway 来覆盖这种偶发的场景，但是 leeway 也不能无限加长，时间太长会造成安全性下降。\n参考资料 RFC7519 flask-jwt-extended PyJWT 为 Linux 实例设置时间\n","permalink":"https://simpleapples.com/zh/posts/solution-to-problem-of-jwt-token-invalidation/","summary":"\u003ch3 id=\"现象\"\u003e现象\u003c/h3\u003e\n\u003cp\u003e刚签发的 JWT，在下一个请求使用时候会失效，请求会报 422 错误。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-json\" data-lang=\"json\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e{\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  \u003cspan style=\"color:#f92672\"\u003e\u0026#34;msg\u0026#34;\u003c/span\u003e: \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;The token is not yet valid (nbf)\u0026#34;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e如果隔几秒再请求（例如使用 Chrome 开发者工具中的 Replay XHR），就会成功。\u003c/p\u003e\n\u003c!-- more --\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/images/20190326_01.png\"\u003e\u003c/p\u003e\n\u003ch3 id=\"nbf-字段的原理\"\u003enbf 字段的原理\u003c/h3\u003e\n\u003cp\u003e查看上面的报错信息，会发现有一个 nbf，nbf 是 JWT 协议中的一个字段，是 Not Before 的缩写，表示 JWT Token 在这个时间之前是无效的，一般来讲会设置成签发的时间。这里产生了一个猜想，多服务器环境时候，服务器之间时间如果不一致，一台服务器签发的 token 如果立刻被发往另一台服务器验证，就很容易产生 nbf 字段验证不通过的问题。其实 JWT 协议已经考虑到了这类问题，所以协议中在 nbf 这一节专门提到了可以使用一个 small leeway 来解决这个问题。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e4.1.5. \u0026ldquo;nbf\u0026rdquo; (Not Before) Claim\u003c/p\u003e\u003c/blockquote\u003e\n\u003cp\u003eThe \u0026ldquo;nbf\u0026rdquo; (not before) claim identifies the time before which the JWT\nMUST NOT be accepted for processing. The processing of the \u0026ldquo;nbf\u0026rdquo;\nclaim requires that the current date/time MUST be after or equal to\nthe not-before date/time listed in the \u0026ldquo;nbf\u0026rdquo; claim. Implementers MAY\nprovide for some small leeway, usually no more than a few minutes, to\naccount for clock skew. Its value MUST be a number containing a\nNumericDate value. Use of this claim is OPTIONAL.\u003c/p\u003e","title":"JWT 避坑指南：nbf 验签失效问题的解决"},{"content":"\n在基于 Kubernetes 部署，使用 Gunicorn 运行的 Python Web 应用中，上传大文件时出现了一系列的错误，现在将解决问题的思路记录如下。\n文件上传过程 上传文件流程\n上传的文件首先到达 Kubernetes 所在的宿主机。 宿主机上的 Nginx 通过 Proxy 转发给 Kubernetes 集群中的 Ingress Controller，Ingress controller 也是使用 Nginx 实现的。 Ingress Controller 中的 Nginx 通过 Proxy 转发给 Gunicorn。 Gunicorn 会启动若干个 Worker 处理请求，所以 Gunicorn 会再转发给 Worker。 Worker 就是最终的 Python Web App 错误 413 的解决 首先碰到的是 413 Request Entity Too Large 错误，在上传过程中连接被中断（基本上每次都是相同的上传百分比被中断），请求返回 413，首先考虑到 Nginx 对于请求体的大小有限制，查看 Nginx 文档，发现 client_max_body_size 参数控制请求体的大小，默认的设置是 1mb。\nclient_max_body_size: Sets the maximum allowed size of the client request body, specified in the “Content-Length” request header field. If the size in a request exceeds the configured value, the 413 (Request Entity Too Large) error is returned to the client. Please be aware that browsers cannot correctly display this error. Setting size to 0 disables checking of client request body size.\n首先在 Kubernetes 宿主机上 Nginx 的 http 域中加入如下配置。\nclient_max_body_size 1024m; 需要注意，除了 Kubernetes 宿主机上跑的 Nginx，还要修改 Ingress Controller 中的 Nginx。Ingress Nginx 的修改方法在 Annotation 字段中加入如下配置。\n\u0026#34;nginx.ingress.kubernetes.io/proxy-body-size\u0026#34;: \u0026#34;1024m\u0026#34; 错误 504 的解决 再次尝试上传，发现接口依然会返回错误，这次是 504 Gateway Timeout，从 Chrome 的开发者工具中查看请求，发现上传至少要持续 5 分钟，接下来从 Nginx 的超时机制入手。\n在 Nginx 和 Ingress 中分别提高了读写的超时限制，将发送的超时设置为 600s，返回的超时设置为 30s。\nproxy_send_timeout 600s; proxy_read_timeout 30s; 再次尝试，发现依然报同样的错误 504，难道说还有别的超时字段需要设置？再次查看文档发现了端倪。\nproxy_send_timeout: Sets a timeout for transmitting a request to the proxied server. The timeout is set only between two successive write operations, not for the transmission of the whole request. If the proxied server does not receive anything within this time, the connection is closed.\nproxy_read_timeout: Defines a timeout for reading a response from the proxied server. The timeout is set only between two successive read operations, not for the transmission of the whole response. If the proxied server does not transmit anything within this time, the connection is closed.\n这里的 send 和 read，主语不是客户端，而是 Nginx 自己，超时的时候，是 Nginx 向 Upstream 发送了文件，而等到 Upstream 处理完返回时候，超过了 proxy_read_timeout 的限制，所以需要增加的是 read_timeout。\n将宿主机上的 Nginx 和 Ingress 分别做如下配置。\nproxy_send_timeout 30s; proxy_read_timeout 600s; nginx.ingress.kubernetes.io/proxy-send-timeout: 30s nginx.ingress.kubernetes.io/proxy-read-timeout: 600s 错误 502 的解决 修改好了超时和上传文件大小的限制后，又出现了新的错误 502 Bad Gateway，这次就没有头绪了，由于是新的报错，上面的修改应该是生效了的，并且也不是上面两个限制导致的，通过查询 Nginx 和 Ingress 的日志，发现 Ingress 中有这样的报错。\n2019/02/27 07:18:36 [error] 4265#4265: *19932411 upstream prematurely closed connection while reading response header from upstream, client: 172.20.0.1, server: example.com, request: \u0026#34;POST /upload HTTP/1.0\u0026#34;, upstream: \u0026#34;http://172.0.0.1/upload\u0026#34;, host: \u0026#34;example.com\u0026#34;, referrer: \u0026#34;http://example.com/\u0026#34; 这就比较奇怪了，刚才已经修改了超时，为什么 Ingress 还会有超时的报错呢？从日志上看，可能是 Ingress 的 Upstream 超时了，也就是 Gunicorn，Stackoverflow 上有人遇到了类似的问题，答案是给 Gunicorn 设置 -t 参数。查看 Gunicorn 的文档，timeout 参数是这么定义的。\ntimeout: Workers silent for more than this many seconds are killed and restarted. Generally set to thirty seconds. Only set this noticeably higher if you’re sure of the repercussions for sync workers. For the non sync workers it just means that the worker process is still communicating and is not tied to the length of time required to handle a single request.\n也就是说，当某一个 Worker 处理文件上传请求时候，如果在默认的超时时间内没有响应 Master，就会被杀掉，这也不难理解为什么 Ingress 从 Upstream 获取返回值时候连接会被关闭了。修改 Gunicorn 的配置，将超时时间设置为 600s，重新上传，问题解决。\n参考文档 Module ngx_http_proxy_module\nIngress-Nginx Annotations\nGunicorn Configuration\nGunicorn Signals\nnginx gunicorn 502 bad gateway: upstream prematurely closed connection while reading response header from upstream\n","permalink":"https://simpleapples.com/zh/posts/update-error-on-nginx-ingress-gunicorn-environment/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/images/20190228_01.jpeg\"\u003e\u003c/p\u003e\n\u003cp\u003e在基于 Kubernetes 部署，使用 Gunicorn 运行的 Python Web 应用中，上传大文件时出现了一系列的错误，现在将解决问题的思路记录如下。\u003c/p\u003e\n\u003c!-- more --\u003e\n\u003ch3 id=\"文件上传过程\"\u003e文件上传过程\u003c/h3\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/images/20190228_02.jpg\"\u003e\u003c/p\u003e\n\u003cp\u003e上传文件流程\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e上传的文件首先到达 Kubernetes 所在的宿主机。\u003c/li\u003e\n\u003cli\u003e宿主机上的 Nginx 通过 Proxy 转发给 Kubernetes 集群中的 Ingress Controller，Ingress controller 也是使用 Nginx 实现的。\u003c/li\u003e\n\u003cli\u003eIngress Controller 中的 Nginx 通过 Proxy 转发给 Gunicorn。\u003c/li\u003e\n\u003cli\u003eGunicorn 会启动若干个 Worker 处理请求，所以 Gunicorn 会再转发给 Worker。\u003c/li\u003e\n\u003cli\u003eWorker 就是最终的 Python Web App\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3 id=\"错误-413-的解决\"\u003e错误 413 的解决\u003c/h3\u003e\n\u003cp\u003e首先碰到的是 413 Request Entity Too Large 错误，在上传过程中连接被中断（基本上每次都是相同的上传百分比被中断），请求返回 413，首先考虑到 Nginx 对于请求体的大小有限制，查看 Nginx 文档，发现 client_max_body_size 参数控制请求体的大小，默认的设置是 1mb。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003eclient_max_body_size:\u003c/strong\u003e Sets the maximum allowed size of the client request body, specified in the “Content-Length” request header field. If the size in a request exceeds the configured value, the 413 (Request Entity Too Large) error is returned to the client. Please be aware that browsers cannot correctly display this error. Setting size to 0 disables checking of client request body size.\u003c/p\u003e","title":"nginx + ingress + gunicorn 环境上传大文件报错问题的解决思路"},{"content":"\n本文从 Python logging 库的基础概念入手，理解 logging 库的执行流程，以及可能忽视的一些细节。\n日志级别 logging 库预置了 5 个错误级别，还有一个 NOTSET 级别，作为 logger 的默认值。\nCRITICAL = 50 ERROR = 40 WARNING = 30 INFO = 20 DEBUG = 10 NOTSET = 0 logging 库也支持自定义错误级别，通过上面的源码可以看到，在不同级别的错误中间预留了 10 个数字的位置，方便我们在预置错误级别的基础上添加更细致的错误级别。\nimport logging logging.addLevelName(31, \u0026#39;SERIOUS WARNING\u0026#39;) logger = logging.getLogger(\u0026#39;log\u0026#39;) logger.warn(\u0026#39;warn info\u0026#39;) logger.log(logging.getLevelName(\u0026#39;SERIOUS_WARNING\u0026#39;), \u0026#39;serious warn\u0026#39;) 例如添加一个 SERIOUS WARNING 类型的错误，值为 31，就可以用 log 方法输出该级别的错误。\n也可以覆盖 logging 预置的错误级别，例如将 WARNING 修改为 SERIOUS WARNING。\nlogging.addLevelName(30, \u0026#39;SERIOUS WARNING\u0026#39;) logger = logging.getLogger(\u0026#39;log\u0026#39;) print(logging.getLevelName(30)) # SERIOUS WARNING LogRecord、Formatter logging 库中的每一条 log 都以 LogRecord 的形式存在，当调用 logger 打印 log 时候，都会有一条 LogRecord 被自动创建出来，LogRecord 中包含了大量的和该条日志相关的属性，也包含用户传入的 message。\n属性名 格式 描述 asctime %(asctime)s 以可读格式表示的日志创建时间 created %(created)f 通过 time.time() 函数获取的日志创建时间 filename %(filename)s pathname 中的文件名称部分 funcName %(funcName)s 日志输出位置的函数名称 levelname %(levelname)s 字符串形式的日志级别 levelno %(levelno)s 数字形式的日志级别 lineno %(lineno)d 输出日志的源码行号 message %(message)s 用户传入的经过格式化的日志内容 module %(module)s filename 中的模块名部分 msecs %(msecs)d 日志创建时间的毫秒部分 name %(name)s logger 的名称 pathname %(pathname)s 源码的路径 process %(process)d 进程 ID processName %(processName)s 进程名 relativeCreated %(relativeCreated)d 相对于 logging 模块加载时间的毫秒数 thread %(thread)d 线程 ID threadName %(threadName)s 线程名 logger = logging.getLogger(\u0026#39;log\u0026#39;) logger.warning(\u0026#39;a warning message\u0026#39;) # a warning message 执行上述代码，会发现，logger 并没有输出列表中列出的 LogRecord 的各种属性，只有 message 内容。因为 LogRecord 只是承载每条日志内容和属性的对象，在一条 log 产生的时候就被创建了，而日志的输出格式则是在被输出时才确定，由 Formatter 来控制。Formatter 负责将一条 log（以 LogRecord 对象的形式存在）转换为可读的字符串，默认情况下，格式是%(message)s，所以当没有指定 Formatter 时，只输出用户传入的内容。\nLogger、Handler、Filter Logger 对象是 logging 库中最为常用的对象，Logger 对象的作用主要有三个：\n为应用暴露出 info、warning、error 等方法，应用可以通过这些方法创建对应级别的日志。 根据 Filter 和日志级别的设置，来决定哪些日志可以被传入给下一个流程处理， 将日志传递到所有相关的 Handler 中。 同时 Logger 对象还可以继承，一个 Logger 可以把 LogRecord 传递给父级的 Logger。\nHandler 负责将日志写入到最终的归宿，可能文件、电子邮件、内存、队列\u0026hellip; 由于一个 Logger 可以有多个 Handler，所以每个 Handler 都可以设置接收日志的级别和 Filter，换句话说，不同级别的日志可以输出到不同的归宿。\nPython 官方文档提供了 logging 处理日志的逻辑流程图。\n这里我们可能会有一个疑问，为 Logger 和 Handler 设置日志级别已经可以表示处理哪些日志，不处理哪些日志，为什么还需要 Filter 呢？\n相比于日志级别，Filter 可定制性更丰富，可以在 Logger 和 Handler 上实现颗粒度更细的控制。例如希望只记录长度大于 10 的日志，可以用如下的代码实现。\nclass CustomFilter(logging.Filterer): def filter(self, record): return len(record.msg) \u0026gt; 10 logger = logging.getLogger(\u0026#39;log\u0026#39;) filter = CustomFilter() logger.addFilter(filter) logger.warning(\u0026#39;a warning message\u0026#39;) # a warning message logger.warning(\u0026#39;a warn\u0026#39;) logger.warning(\u0026#39;another warning message\u0026#39;) # another warning message 长度小于 10 的第二条 log 并不会被输出。\n实践中的一些经验 在使用 Python logging 库的过程中，我们发现了一些容易容易忽视的细节，这些细节可能会导致一些预期之外的情况，在此做以总结。\nLogger 的继承链 Logger 对象是有一条继承链的，使用 logging.getLogger() 方法获取 logger 时，获取的是 root logger。如果为 getLogger 方法传入参数，获取的是子 logger。\nroot_logger = logging.getLogger() sub_logger = logging.getLogger(\u0026#39;log\u0026#39;) print(sub_logger.parent == root_logger) # True logging 的官方文档中推荐使用 __name__ 作为 getLogger 的参数，__name__ 是 module 的路径名，例如在 utils.log 包中使用 logging.getLogger(__name___) 相当于执行 logging.getLogger('base.db')，这样就创建了一个名为 base.db 的 logger，这个 db 包的 logger 继承自 root logger。\n如果我们在 base 中也创建一个 logger，logger.getLogger('base')，这时候，base logger 也继承自 root logger，但是 db logger 的继承顺序则被修改成了继承自 base logger。\nroot_logger = logging.getLogger() db_logger = logging.getLogger(\u0026#39;base.db\u0026#39;) print(db_logger.name) # base.db print(db_logger.parent.name) # root base_logger = logging.getLogger(\u0026#39;base\u0026#39;) # base print(db_logger.name) # base.db print(db_logger.parent.name) # base 换句话说我们可以通过 xxx.xxx 的形式获取任何一级的 logger，但是这些中间层的 logger 并不一定是存在的。\nLogger 奇葩的默认行为 root_logger = logging.getLogger() root_logger.info(\u0026#39;root info\u0026#39;) 执行上面的代码，会发现没有任何输出，但是如果打一个 warning 级别的 log，是可以输出的。\nroot_logger = logging.getLogger() sub_logger = logging.getLogger(\u0026#39;sub\u0026#39;) print(root_logger.level) # 30 = WARNING print(sub_logger.level) # 0 = NOTSET 打印一下 root logger 的默认级别，会发现 30 对应的是 WARNING，也就是说，只有比 WARNING 高的级别才会被输出出来，而 INFO 对应值是 20， 比 WARNING 低，所以默认情况下 root logger 将不会接受 INFO 级别的错误。\n但是只有 root logger 的默认级别是 WARNING，其他 logger 的默认级别 是 NOTSET = 0。\nroot_logger = logging.getLogger() sub_logger = logging.getLogger(\u0026#39;sub\u0026#39;) root_logger.info(\u0026#39;root info\u0026#39;) sub_logger.info(\u0026#39;sub info\u0026#39;) 执行上面代码，会发现依然没有任何输出，既然其他 logger 的默认级别是 NOTSET，为什么比 NOTSET 高的 INFO 还是不会输出呢？\n当一个 logger 的 level 被设置为 NOTSET 时，如果有父 logger，会将 log 传递给父 logger 处理，只有在 logger 是 root logger 或 propagate 属性设置为 False 时，才会由自己处理。接下来再修改一下上面的代码。\nsub_logger = logging.getLogger(\u0026#39;sub\u0026#39;) sub_logger.propagate = False sub_logger.info(\u0026#39;sub info\u0026#39;) sub_logger.warning(\u0026#39;sub warn\u0026#39;) # sub warn 上面的代码中禁用了 logger 的传递功能，所以 logger 会自己处理错误，但是 INFO 级别的日志依然没有被输出，如果输出一下 sub_logger.handlers 属性，会发现默认情况下 logger 并没有任何的 handlers，这能解释为什么无法输出日志，但是下一行代码输出了 WARNING 级别的日志，显然又是和这个猜测违背的，原因到底是什么呢？\n跟踪源码会发现，当一个 logger 需要自己处理日志时且没有任何一个 handler 时，会尝试使用 lastResort 属性所存储的 handler 来处理。\n文档中是这样定义 lastResort 的。\nA “handler of last resort” is available through this attribute. This is a StreamHandler writing to sys.stderr with a level of WARNING, and is used to handle logging events in the absence of any logging configuration. The end result is to just print the message to sys.stderr. This replaces the earlier error message saying that “no handlers could be found for logger XYZ”. If you need the earlier behaviour for some reason, lastResort can be set to None.\n所以，当一个 logger 没有任何 handler 的时候，依然能输出 WARNING 及以上级别的日志。\n参考资料 Python 日志库 logging 总结-可能是目前为止将 logging 库总结的最好的一篇文章 - 掘金\nlogging — Logging facility for Python\nLogging HOWTO\n","permalink":"https://simpleapples.com/zh/posts/practice-on-python-logging/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/images/20190125_01.jpg\"\u003e\u003c/p\u003e\n\u003cp\u003e本文从 Python logging 库的基础概念入手，理解 logging 库的执行流程，以及可能忽视的一些细节。\u003c/p\u003e\n\u003c!-- more --\u003e\n\u003ch3 id=\"日志级别\"\u003e日志级别\u003c/h3\u003e\n\u003cp\u003elogging 库预置了 5 个错误级别，还有一个 \u003ccode\u003eNOTSET\u003c/code\u003e 级别，作为 logger 的默认值。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eCRITICAL \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e50\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eERROR \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e40\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eWARNING \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e30\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eINFO \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e20\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eDEBUG \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e10\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eNOTSET \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003elogging 库也支持自定义错误级别，通过上面的源码可以看到，在不同级别的错误中间预留了 10 个数字的位置，方便我们在预置错误级别的基础上添加更细致的错误级别。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003eimport\u003c/span\u003e logging\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elogging\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003eaddLevelName(\u003cspan style=\"color:#ae81ff\"\u003e31\u003c/span\u003e, \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;SERIOUS WARNING\u0026#39;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elogger \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e logging\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003egetLogger(\u003cspan style=\"color:#e6db74\"\u003e\u0026#39;log\u0026#39;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elogger\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003ewarn(\u003cspan style=\"color:#e6db74\"\u003e\u0026#39;warn info\u0026#39;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elogger\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003elog(logging\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003egetLevelName(\u003cspan style=\"color:#e6db74\"\u003e\u0026#39;SERIOUS_WARNING\u0026#39;\u003c/span\u003e), \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;serious warn\u0026#39;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e例如添加一个 SERIOUS WARNING 类型的错误，值为 31，就可以用 log 方法输出该级别的错误。\u003c/p\u003e\n\u003cp\u003e也可以覆盖 logging 预置的错误级别，例如将 WARNING 修改为 SERIOUS WARNING。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elogging\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003eaddLevelName(\u003cspan style=\"color:#ae81ff\"\u003e30\u003c/span\u003e, \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;SERIOUS WARNING\u0026#39;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003elogger \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e logging\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003egetLogger(\u003cspan style=\"color:#e6db74\"\u003e\u0026#39;log\u0026#39;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eprint(logging\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003egetLevelName(\u003cspan style=\"color:#ae81ff\"\u003e30\u003c/span\u003e))  \u003cspan style=\"color:#75715e\"\u003e# SERIOUS WARNING\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"logrecordformatter\"\u003eLogRecord、Formatter\u003c/h3\u003e\n\u003cp\u003elogging 库中的每一条 log 都以 LogRecord 的形式存在，当调用 logger 打印 log 时候，都会有一条 LogRecord 被自动创建出来，LogRecord 中包含了大量的和该条日志相关的属性，也包含用户传入的 message。\u003c/p\u003e","title":"Python 日志库 logging 的理解和实践经验"},{"content":"\n在使用 go 语言开发过程中，经常需要使用到 json 包来进行 json 和 struct 的互相转换，在使用过程中，遇到了一些需要额外注意的地方，记录如下。\n整数变浮点数问题 假设有一个 Person 结构，其中包含 Age int64 和 Weight float64 两个字段，现在通过 json 包将 Person 结构转为 map[string]interface{}，代码如下。\ntype Person struct { Name string Age int64 Weight float64 } func main() { person := Person{ Name: \u0026#34;Wang Wu\u0026#34;, Age: 30, Weight: 150.07, } jsonBytes, _ := json.Marshal(person) fmt.Println(string(jsonBytes)) var personFromJSON interface{} json.Unmarshal(jsonBytes, \u0026amp;personFromJSON) r := personFromJSON.(map[string]interface{}) } 代码执行到这里看上去一切正常，但是打印一下 map[string]interface{} 就会发现不太对了。\nfmt.Println(reflect.TypeOf(r[\u0026#34;Age\u0026#34;]).Name()) // float64 fmt.Println(reflect.TypeOf(r[\u0026#34;Weight\u0026#34;]).Name()) // float64 转换成 map[string]interface{} 之后，原先的 uint64 和 float64 类型都被转换成了 float64 类型，这显然是不符合我们的预期的。\n查看 json 的规范可以看到，在 json 中是没有整型和浮点型之分的，所以现在可以理解 json 包中的 Unmarshal 方法转出的数字类型为什么都是 float64 了，因为根据 json 规范，数字都是同一种类型，那么对应到 go 的类型中最接近的就是 float64 了。\njson 包还针对这个问题提供了更好的解决方案，不过需要使用 json.Decoder 来代替 json.Unmarshal 方法，将 json.Unmarhsal 替换如下。\nvar personFromJSON interface{} decoder := json.NewDecoder(bytes.NewReader(jsonBytes)) decoder.UseNumber() decoder.Decode(\u0026amp;personFromJSON) r := personFromJSON.(map[string]interface{}) 这种方法首先创建了一个 jsonDecoder，然后调用了 UseNumber 方法，从文档中可以知道，使用 UseNumber 方法后，json 包会将数字转换成一个内置的 Number 类型（而不是 float64），这个 Number 类型提供了转换为 int64、float64 等多个方法。\n时间格式 对于 json 格式，是没有时间类型的，日期和时间以 json 格式存储时，需要转换为字符串类型。这就带来了一个问题，日期时间的字符串表示有多种多样，go 的 json 包支持的是哪一种呢？\n使用下面的代码来输出 json.Marshal 方法将 Time 类型转换为字符串后的格式。\ntype Person struct { Name string Birth time.Time } func main() { person := Person{ Name: \u0026#34;Wang Wu\u0026#34;, Birth: time.Now(), } jsonBytes, _ := json.Marshal(person) fmt.Println(string(jsonBytes)) // {\u0026#34;Name\u0026#34;:\u0026#34;Wang Wu\u0026#34;,\u0026#34;Birth\u0026#34;:\u0026#34;2018-12-20T16:22:02.00287617+08:00\u0026#34;} } 根据输出可以判断，go 的 json 包使用的是 RFC3339 标准中定义的格式。接下来测试一下 json.Unmarshal 方法所支持的日期时间格式。\ndateStr := \u0026#34;2018-10-12\u0026#34; var person Person jsonStr := fmt.Sprintf(\u0026#34;{\\\u0026#34;name\\\u0026#34;:\\\u0026#34;Wang Wu\\\u0026#34;, \\\u0026#34;Birth\\\u0026#34;: \\\u0026#34;%s\\\u0026#34;}\u0026#34;, dateStr) json.Unmarshal([]byte(jsonStr), \u0026amp;person) fmt.Println(person.Birth) // 0001-01-01 00:00:00 +0000 UTC 对于形如 2018-10-12 的字符串，json 包并没有成功将其解析，接下来我们把 time 包中支持的所有格式都试一下。\n经过试验，发现 json.Unmarshal 方法只支持 RFC3339 和 RFC3339Nano 两种格式的转换。还有一个需要注意的地方，使用 time.Now() 生成的时间是带有一个 Monotonic Time 的，经过 json.Marshal 转换时候，由于 RFC3339 规范里没有存放 Monotonic Time 的位置，会丢掉这一部分。\n对于字段为空的处理 json 包对于空值的处理是一个非常容易出错的地方，看下面代码。\ntype Person struct { Name string Age int64 Birth time.Time Children []Person } func main() { person := Person{} jsonBytes, _ := json.Marshal(person) fmt.Println(string(jsonBytes)) // {\u0026#34;Name\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;Age\u0026#34;:0,\u0026#34;Birth\u0026#34;:\u0026#34;0001-01-01T00:00:00Z\u0026#34;,\u0026#34;Children\u0026#34;:null} } 当 struct 中的字段没有值时，使用 json.Marshal 方法并不会自动忽略这些字段，而是根据字段的类型输出了他们的默认空值，这往往和我们的预期不一致，json 包提供了对字段的控制手段，我们可以为字段增加 omitempty tag，这个 tag 会在字段值为零值（int 和 float 类型零值是 0，string 类型零值是 \u0026ldquo;\u0026quot;，对象类型零值是 nil）时，忽略该字段。\ntype PersonAllowEmpty struct { Name string `json:\u0026#34;,omitempty\u0026#34;` Age int64 `json:\u0026#34;,omitempty\u0026#34;` Birth time.Time `json:\u0026#34;,omitempty\u0026#34;` Children []PersonAllowEmpty `json:\u0026#34;,omitempty\u0026#34;` } func main() { person := PersonAllowEmpty{} jsonBytes, _ := json.Marshal(person) fmt.Println(string(jsonBytes)) // {\u0026#34;Birth\u0026#34;:\u0026#34;0001-01-01T00:00:00Z\u0026#34;} } 可以看到，这次输出的 json 中只有 Birth 字段了，string、int、对象类型的字段，都因为没有赋值，默认是零值，所以被忽略，对于日期时间类型，由于不可以设置为零值，也就是 0000-00-00 00:00:00，不会被忽略。\n需要注意这样的情况：如果一个人的年龄是 0 （对于刚出生的婴儿，这个值是合理的），刚好是 int 字段的零值，在添加 omitempty tag 的情况下，年龄字段会被忽略。\n如果想要某一个字段在任何情况下都被 json 包忽略，需要使用如下的写法。\ntype Person struct { Name string `json:\u0026#34;-\u0026#34;` Age int64 `json:\u0026#34;-\u0026#34;` Birth time.Time `json:\u0026#34;-\u0026#34;` Children []string `json:\u0026#34;-\u0026#34;` } func main() { birth, _ := time.Parse(time.RFC3339, \u0026#34;1988-12-02T15:04:27+08:00\u0026#34;) person := Person{ Name: \u0026#34;Wang Wu\u0026#34;, Age: 30, Birth: birth, Children: []string{}, } jsonBytes, _ := json.Marshal(person) fmt.Println(string(jsonBytes)) // {} } 可以看到，使用 json:\u0026rdquo;-\u0026quot; 标签的字段都被忽略了。\n","permalink":"https://simpleapples.com/zh/posts/practice-in-json-with-go/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/images/20181224_01.png\"\u003e\u003c/p\u003e\n\u003cp\u003e在使用 go 语言开发过程中，经常需要使用到 json 包来进行 json 和 struct 的互相转换，在使用过程中，遇到了一些需要额外注意的地方，记录如下。\u003c/p\u003e\n\u003c!-- more --\u003e\n\u003ch3 id=\"整数变浮点数问题\"\u003e整数变浮点数问题\u003c/h3\u003e\n\u003cp\u003e假设有一个 Person 结构，其中包含 Age int64 和 Weight float64 两个字段，现在通过 json 包将 Person 结构转为 map[string]interface{}，代码如下。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-go\" data-lang=\"go\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003etype\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ePerson\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estruct\u003c/span\u003e {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#a6e22e\"\u003eName\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003estring\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#a6e22e\"\u003eAge\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003eint64\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#a6e22e\"\u003eWeight\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003efloat64\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003efunc\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003emain\u003c/span\u003e() {\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#a6e22e\"\u003eperson\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e:=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ePerson\u003c/span\u003e{\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#a6e22e\"\u003eName\u003c/span\u003e: \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;Wang Wu\u0026#34;\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#a6e22e\"\u003eAge\u003c/span\u003e: \u003cspan style=\"color:#ae81ff\"\u003e30\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#a6e22e\"\u003eWeight\u003c/span\u003e: \u003cspan style=\"color:#ae81ff\"\u003e150.07\u003c/span\u003e,\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    }\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#a6e22e\"\u003ejsonBytes\u003c/span\u003e, \u003cspan style=\"color:#a6e22e\"\u003e_\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e:=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ejson\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eMarshal\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003eperson\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#a6e22e\"\u003efmt\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003ePrintln\u003c/span\u003e(string(\u003cspan style=\"color:#a6e22e\"\u003ejsonBytes\u003c/span\u003e))\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003evar\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003epersonFromJSON\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003einterface\u003c/span\u003e{}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#a6e22e\"\u003ejson\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eUnmarshal\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003ejsonBytes\u003c/span\u003e, \u003cspan style=\"color:#f92672\"\u003e\u0026amp;\u003c/span\u003e\u003cspan style=\"color:#a6e22e\"\u003epersonFromJSON\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#a6e22e\"\u003er\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e:=\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003epersonFromJSON\u003c/span\u003e.(\u003cspan style=\"color:#66d9ef\"\u003emap\u003c/span\u003e[\u003cspan style=\"color:#66d9ef\"\u003estring\u003c/span\u003e]\u003cspan style=\"color:#66d9ef\"\u003einterface\u003c/span\u003e{})\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e代码执行到这里看上去一切正常，但是打印一下 map[string]interface{} 就会发现不太对了。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-go\" data-lang=\"go\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#a6e22e\"\u003efmt\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003ePrintln\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003ereflect\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eTypeOf\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003er\u003c/span\u003e[\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;Age\u0026#34;\u003c/span\u003e]).\u003cspan style=\"color:#a6e22e\"\u003eName\u003c/span\u003e())  \u003cspan style=\"color:#75715e\"\u003e// float64\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#a6e22e\"\u003efmt\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003ePrintln\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003ereflect\u003c/span\u003e.\u003cspan style=\"color:#a6e22e\"\u003eTypeOf\u003c/span\u003e(\u003cspan style=\"color:#a6e22e\"\u003er\u003c/span\u003e[\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;Weight\u0026#34;\u003c/span\u003e]).\u003cspan style=\"color:#a6e22e\"\u003eName\u003c/span\u003e())  \u003cspan style=\"color:#75715e\"\u003e// float64\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e转换成 map[string]interface{} 之后，原先的 uint64 和 float64 类型都被转换成了 float64 类型，这显然是不符合我们的预期的。\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/images/20181224_02.png\"\u003e\u003c/p\u003e","title":"go json 实践中遇到的坑"},{"content":"\nHTTP 是一个无状态的协议，一次请求结束后，下次在发送服务器就不知道这个请求是谁发来的了（同一个 IP 不代表同一个用户），在 Web 应用中，用户的认证和鉴权是非常重要的一环，实践中有多种可用方案，并且各有千秋。\n基于 Session 的会话管理 在 Web 应用发展的初期，大部分采用基于 Session 的会话管理方式，逻辑如下。\n客户端使用用户名密码进行认证 服务端生成并存储 Session，将 SessionID 通过 Cookie 返回给客户端 客户端访问需要认证的接口时在 Cookie 中携带 SessionID 服务端通过 SessionID 查找 Session 并进行鉴权，返回给客户端需要的数据 基于 Session 的方式存在多种问题。\n服务端需要存储 Session，并且由于 Session 需要经常快速查找，通常存储在内存或内存数据库中，同时在线用户较多时需要占用大量的服务器资源。 当需要扩展时，创建 Session 的服务器可能不是验证 Session 的服务器，所以还需要将所有 Session 单独存储并共享。 由于客户端使用 Cookie 存储 SessionID，在跨域场景下需要进行兼容性处理，同时这种方式也难以防范 CSRF 攻击。 基于 Token 的会话管理 鉴于基于 Session 的会话管理方式存在上述多个缺点，无状态的基于 Token 的会话管理方式诞生了，所谓无状态，就是服务端不再存储信息，甚至是不再存储 Session，逻辑如下。\n客户端使用用户名密码进行认证 服务端验证用户名密码，通过后生成 Token 返回给客户端 客户端保存 Token，访问需要认证的接口时在 URL 参数或 HTTP Header 中加入 Token 服务端通过解码 Token 进行鉴权，返回给客户端需要的数据 基于 Token 的会话管理方式有效解决了基于 Session 的会话管理方式带来的问题。\n服务端不需要存储和用户鉴权有关的信息，鉴权信息会被加密到 Token 中，服务端只需要读取 Token 中包含的鉴权信息即可 避免了共享 Session 导致的不易扩展问题 不需要依赖 Cookie，有效避免 Cookie 带来的 CSRF 攻击问题 使用 CORS 可以快速解决跨域问题 JWT 介绍 JWT 是 JSON Web Token 的缩写，JWT 本身没有定义任何技术实现，它只是定义了一种基于 Token 的会话管理的规则，涵盖 Token 需要包含的标准内容和 Token 的生成过程。\n一个 JWT Token 长这样。\neyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE1NDQ1MTE3NDMsImp0aSI6IjYxYmVmNjkyLTE4M2ItNGYxYy1hZjE1LWUwMDM0MTczNzkxOSJ9.CZzB2-JI1oPRFxNMaoFz9-9cKGTYVXkOC2INMoEYNNA 仔细辨别会发现它由 A.B.C 三部分组成，这三部分依次是头部（Header）、负载（Payload）、签名（Signature），头部和负载以 JSON 形式存在，这就是 JWT 中的 JSON，三部分的内容都分别单独经过了 Base64 编码，以 . 拼接成一个 JWT Token。\nJWT 的 Header 中存储了所使用的加密算法和 Token 类型。\n{ \u0026#34;alg\u0026#34;: \u0026#34;HS256\u0026#34;, \u0026#34;typ\u0026#34;: \u0026#34;JWT\u0026#34; } Payload 是负载，JWT 规范规定了一些字段，并推荐使用，开发者也可以自己指定字段和内容，例如下面的内容。\n{ \u0026#34;username\u0026#34;: \u0026#34;yage\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;sa@simpleapples.com\u0026#34;, \u0026#34;role\u0026#34;: \u0026#34;user\u0026#34;, \u0026#34;exp\u0026#34;: 1544602234 } 需要注意的是，Payload 的内容只经过了 Base64 编码，对客户端来说当于明文存储，所以不要放置敏感信息。\nSignature 部分用来验证 JWT Token 是否被篡改，所以这部分会使用一个 Secret 将前两部分加密，逻辑如下。\nHMACSHA256(base64UrlEncode(header) + \u0026#34;.\u0026#34; + base64UrlEncode(payload), secret) JWT 优势 \u0026amp; 问题 JWT 拥有基于 Token 的会话管理方式所拥有的一切优势，不依赖 Cookie，使得其可以防止 CSRF 攻击，也能在禁用 Cookie 的浏览器环境中正常运行。\n而 JWT 的最大优势是服务端不再需要存储 Session，使得服务端认证鉴权业务可以方便扩展，避免存储 Session 所需要引入的 Redis 等组件，降低了系统架构复杂度。但这也是 JWT 最大的劣势，由于有效期存储在 Token 中，JWT Token 一旦签发，就会在有效期内一直可用，无法在服务端废止，当用户进行登出操作，只能依赖客户端删除掉本地存储的 JWT Token，如果需要禁用用户，单纯使用 JWT 就无法做到了。\n基于 JWT 的实践 既然 JWT 依然存在诸多问题，甚至无法满足一些业务上的需求，但是我们依然可以基于 JWT 在实践中进行一些改进，来形成一个折中的方案，毕竟，在用户会话管理场景下，没有银弹。\n前面讲的 Token，都是 Access Token，也就是访问资源接口时所需要的 Token，还有另外一种 Token，Refresh Token，通常情况下，Refresh Token 的有效期会比较长，而 Access Token 的有效期比较短，当 Access Token 由于过期而失效时，使用 Refresh Token 就可以获取到新的 Access Token，如果 Refresh Token 也失效了，用户就只能重新登录了。\n在 JWT 的实践中，引入 Refresh Token，将会话管理流程改进如下。\n客户端使用用户名密码进行认证 服务端生成有效时间较短的 Access Token（例如 10 分钟），和有效时间较长的 Refresh Token（例如 7 天） 客户端访问需要认证的接口时，携带 Access Token 如果 Access Token 没有过期，服务端鉴权后返回给客户端需要的数据 如果携带 Access Token 访问需要认证的接口时鉴权失败（例如返回 401 错误），则客户端使用 Refresh Token 向刷新接口申请新的 Access Token 如果 Refresh Token 没有过期，服务端向客户端下发新的 Access Token 客户端使用新的 Access Token 访问需要认证的接口 将生成的 Refresh Token 以及过期时间存储在服务端的数据库中，由于 Refresh Token 不会在客户端请求业务接口时验证，只有在申请新的 Access Token 时才会验证，所以将 Refresh Token 存储在数据库中，不会对业务接口的响应时间造成影响，也不需要像 Session 一样一直保持在内存中以应对大量的请求。\n上述的架构，提供了服务端禁用用户 Token 的方式，当用户需要登出或禁用用户时，只需要将服务端的 Refresh Token 禁用或删除，用户就会在 Access Token 过期后，由于无法获取到新的 Access Token 而再也无法访问需要认证的接口。这样的方式虽然会有一定的窗口期（取决于 Access Token 的失效时间），但是结合用户登出时客户端删除 Access Token 的操作，基本上可以适应常规情况下对用户认证鉴权的精度要求。\n总结 JWT 的使用，提高了开发者开发用户认证鉴权功能的效率，降低了系统架构复杂度，避免了大量的数据库和缓存查询，降低了业务接口的响应延迟。然而 JWT 的这些优点也增加了 Token 管理上的难度，通过引入 Refresh Token，既能继续使用 JWT 所带来的优势，又能使得 Token 管理的精度符合业务的需求。\n","permalink":"https://simpleapples.com/zh/posts/combining-jwt-with-refresh-token/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/images/20181213_01.jpg\"\u003e\u003c/p\u003e\n\u003cp\u003eHTTP 是一个无状态的协议，一次请求结束后，下次在发送服务器就不知道这个请求是谁发来的了（同一个 IP 不代表同一个用户），在 Web 应用中，用户的认证和鉴权是非常重要的一环，实践中有多种可用方案，并且各有千秋。\u003c/p\u003e\n\u003c!-- more --\u003e\n\u003ch3 id=\"基于-session-的会话管理\"\u003e基于 Session 的会话管理\u003c/h3\u003e\n\u003cp\u003e在 Web 应用发展的初期，大部分采用基于 Session 的会话管理方式，逻辑如下。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e客户端使用用户名密码进行认证\u003c/li\u003e\n\u003cli\u003e服务端生成并存储 Session，将 SessionID 通过 Cookie 返回给客户端\u003c/li\u003e\n\u003cli\u003e客户端访问需要认证的接口时在 Cookie 中携带 SessionID\u003c/li\u003e\n\u003cli\u003e服务端通过 SessionID 查找 Session 并进行鉴权，返回给客户端需要的数据\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/images/20181213_02.jpg\"\u003e\u003c/p\u003e\n\u003cp\u003e基于 Session 的方式存在多种问题。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e服务端需要存储 Session，并且由于 Session 需要经常快速查找，通常存储在内存或内存数据库中，同时在线用户较多时需要占用大量的服务器资源。\u003c/li\u003e\n\u003cli\u003e当需要扩展时，创建 Session 的服务器可能不是验证 Session 的服务器，所以还需要将所有 Session 单独存储并共享。\u003c/li\u003e\n\u003cli\u003e由于客户端使用 Cookie 存储 SessionID，在跨域场景下需要进行兼容性处理，同时这种方式也难以防范 CSRF 攻击。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"基于-token-的会话管理\"\u003e基于 Token 的会话管理\u003c/h3\u003e\n\u003cp\u003e鉴于基于 Session 的会话管理方式存在上述多个缺点，无状态的基于 Token 的会话管理方式诞生了，所谓无状态，就是服务端不再存储信息，甚至是不再存储 Session，逻辑如下。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e客户端使用用户名密码进行认证\u003c/li\u003e\n\u003cli\u003e服务端验证用户名密码，通过后生成 Token 返回给客户端\u003c/li\u003e\n\u003cli\u003e客户端保存 Token，访问需要认证的接口时在 URL 参数或 HTTP Header 中加入 Token\u003c/li\u003e\n\u003cli\u003e服务端通过解码 Token 进行鉴权，返回给客户端需要的数据\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/images/20181213_03.jpg\"\u003e\u003c/p\u003e","title":"基于 JWT + Refresh Token 的用户认证实践"},{"content":"ngrok 用 ssh 访问一台主机，如果和主机在一个局域网中或者主机拥有公网 IP，就可以使用 ssh 命令直接连接主机的 IP 地址，但是大部分公司和家庭内部都是局域网，并不能给局域网内的每一台主机都分配一个公网 IP，这时候就需要进行内网穿透，才能从外部连接到局域网内的主机。\nngrok 是一个反向代理工具，可以实现将内网的端口暴露到公网，通过 ngrok，也能将 ssh 使用的端口暴露出去，以此实现 ssh 的内网穿透。\n注册并下载 ngrok 访问 https://ngrok.com/ 注册 ngrok 账号并下载 ngrok 客户端。\n查看 ngrok 的 token 访问 https://dashboard.ngrok.com/auth 查看 token 并复制。\n在内网机器上启动 ngrok 连接 ngrok 账号\nngrok authtoken 5TqUhMnum6ntDE8Z5HkNb_49F9ffzzcV9V7pKLVdDYc 启动 ngrok 并打开 22 端口转发\nngrok tcp 22 --log=stdout \u0026gt; \u0026#34;$HOME/ngrok.log\u0026#34; --region ap \u0026amp; 其中 region 的 ap 代表 ngrok 新加坡节点，访问速度相比美国节点会快一些。访问 https://ngrok.com/docs#config-options 可以查看支持的所有区域。\n访问 http://127.0.0.1:4040。\n可以看到一个 tcp 开头的地址，通过访问这个地址，就可以转发到本机的 22 端口上。\n通过 ssh 访问内网机器 查看到转发地址后，就可以在外网通过 ssh 命令访问内网机器来。以上图为例，ssh 访问的命令是：\nssh -p 10502 username@0.tcp.ap.ngrok.io 需要注意的问题 由于所有流量都要经过 ngrok 服务器，而 ngrok 的服务节点又只有美国、新加坡等地，所以速度上还是比较慢的。另外，如果 ngrok 的服务节点存在安全隐患的话，存在敏感内容的泄漏的可能性。\n","permalink":"https://simpleapples.com/zh/posts/ssh-via-ngrok/","summary":"\u003ch3 id=\"ngrok\"\u003engrok\u003c/h3\u003e\n\u003cp\u003e用 ssh 访问一台主机，如果和主机在一个局域网中或者主机拥有公网 IP，就可以使用 ssh 命令直接连接主机的 IP 地址，但是大部分公司和家庭内部都是局域网，并不能给局域网内的每一台主机都分配一个公网 IP，这时候就需要进行内网穿透，才能从外部连接到局域网内的主机。\u003c/p\u003e\n\u003cp\u003engrok 是一个反向代理工具，可以实现将内网的端口暴露到公网，通过 ngrok，也能将 ssh 使用的端口暴露出去，以此实现 ssh 的内网穿透。\u003c/p\u003e\n\u003c!-- more --\u003e\n\u003ch3 id=\"注册并下载-ngrok\"\u003e注册并下载 ngrok\u003c/h3\u003e\n\u003cp\u003e访问 \u003ca href=\"https://ngrok.com/\"\u003ehttps://ngrok.com/\u003c/a\u003e 注册 ngrok 账号并下载 ngrok 客户端。\u003c/p\u003e\n\u003ch3 id=\"查看-ngrok-的-token\"\u003e查看 ngrok 的 token\u003c/h3\u003e\n\u003cp\u003e访问 \u003ca href=\"https://dashboard.ngrok.com/auth\"\u003ehttps://dashboard.ngrok.com/auth\u003c/a\u003e 查看 token 并复制。\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/images/20181210_01.png\"\u003e\u003c/p\u003e\n\u003ch3 id=\"在内网机器上启动-ngrok\"\u003e在内网机器上启动 ngrok\u003c/h3\u003e\n\u003cp\u003e连接 ngrok 账号\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003engrok authtoken 5TqUhMnum6ntDE8Z5HkNb_49F9ffzzcV9V7pKLVdDYc\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e启动 ngrok 并打开 22 端口转发\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003engrok tcp \u003cspan style=\"color:#ae81ff\"\u003e22\u003c/span\u003e --log\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003estdout \u0026gt; \u003cspan style=\"color:#e6db74\"\u003e\u0026#34;\u003c/span\u003e$HOME\u003cspan style=\"color:#e6db74\"\u003e/ngrok.log\u0026#34;\u003c/span\u003e --region ap \u0026amp;\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e其中 region 的 ap 代表 ngrok 新加坡节点，访问速度相比美国节点会快一些。访问 \u003ca href=\"https://ngrok.com/docs#config-options\"\u003ehttps://ngrok.com/docs#config-options\u003c/a\u003e 可以查看支持的所有区域。\u003c/p\u003e\n\u003cp\u003e访问 \u003ccode\u003ehttp://127.0.0.1:4040\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e可以看到一个 tcp 开头的地址，通过访问这个地址，就可以转发到本机的 22 端口上。\u003c/p\u003e","title":"通过 ngrok 实现 ssh 内网穿透"},{"content":"\nUnicode 和 UTF-8 的概念是一个非常基础和重要，但是却容易被忽略的问题。\n字符集 在计算机系统中，所有的数据都以二进制存储，所有的运算也以二进制表示，人类语言和符号也需要转化成二进制的形式，才能存储在计算机中，于是需要有一个从人类语言到二进制编码的映射表。这个映射表就叫做字符集。\nASCII 最早的字符集叫 American Standard Code for Information Interchange（美国信息交换标准代码），简称 ASCII，由 American National Standard Institute（美国国家标准协会）制定。在 ASCII 字符集中，字母 A 对应的字符编码是 65，转换成二进制是 0100 0001，由于二进制表示比较长，通常使用十六进制 41。\nGB2312、GBK ASCII 字符集总共规定了 128 种字符规范，但是并没有涵盖西文字母之外的字符，当需要计算机显示存储中文的时候，就需要一种对中文进行编码的字符集，GB 2312 就是解决中文编码的字符集，由国家标准委员会发布。同时考虑到中文语境中往往也需要使用西文字母，GB 2312 也实现了对 ASCII 的向下兼容，原理是西文字母使用和 ASCII 中相同的代码，但是 GB 2312 只涵盖了 6000 多个汉字，还有很多没有包含在其中，所以又出现了 GBK 和 GB 18030，两种字符集都是在 GB 2312 的基础上进行了扩展。\nUnicode 可以看到，光是简体中文，就先后出现了至少三种字符集，繁体中文方面也有 BIG5 等字符集，几乎每种语言都需要有一个自己的字符集，每个字符集使用了自己的编码规则，往往互不兼容。同一个字符在不同字符集下的字符代码不同，这使得跨语言交流的过程中双方必须要使用相同的字符编码才能不出现乱码的情况。为了解决传统字符编码的局限性，Unicode 诞生了，Unicoide 的全称是 Universal Multiple-Octet Coded Character Set（通用多八位字符集，简称 UCS）。Unicode 在一个字符集中包含了世界上所有文字和符号，统一编码，来终结不同编码产生乱码的问题。\n字符编码 UTF-8 Unicode 统一了所有字符的编码，是一个 Character Set，也就是字符集，字符集只是给所有的字符一个唯一编号，但是却没有规定如何存储，一个编号为 65 的字符，只需要一个字节就可以存下，但是编号 40657 的字符需要两个字节的空间才可以装下，而更靠后的字符可能会需要三个甚至四个字节的空间。\n这时，用什么规则存储 Unicode 字符就成了关键，我们可以规定，一个字符使用四个字节存储，也就是 32 位，这样就能涵盖现有 Unicode 包含的所有字符，这种编码方式叫做 UTF-32（UTF 是 UCS Transformation Format 的缩写）。UTF-32 的规则虽然简单，但是缺陷也很明显，假设使用 UTF-32 和 ASCII 分别对一个只有西文字母的文档编码，前者需要花费的空间是后者的四倍（ASCII 每个字符只需要一个字节存储）。\n在存储和网络传输中，通常使用更为节省空间的变长编码方式 UTF-8，UTF-8 代表 8 位一组表示 Unicode 字符的格式，使用 1 - 4 个字节来表示字符。\nUTF-8 的编码规则如下（U+ 后面的数字代表 Unicode 字符代码）：\nU+ 0000 ~ U+ 007F: 0XXXXXXX U+ 0080 ~ U+ 07FF: 110XXXXX 10XXXXXX U+ 0800 ~ U+ FFFF: 1110XXXX 10XXXXXX 10XXXXXX U+10000 ~ U+1FFFF: 11110XXX 10XXXXXX 10XXXXXX 10XXXXXX 可以看到，UTF-8 通过开头的标志位位数实现了变长。对于单字节字符，只占用一个字节，实现了向下兼容 ASCII，并且能和 UTF-32 一样，包含 Unicode 中的所有字符，又能有效减少存储传输过程中占用的空间。\n","permalink":"https://simpleapples.com/zh/posts/unicode-and-utf-8/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/images/20181207_01.jpg\"\u003e\u003c/p\u003e\n\u003cp\u003eUnicode 和 UTF-8 的概念是一个非常基础和重要，但是却容易被忽略的问题。\u003c/p\u003e\n\u003c!-- more --\u003e\n\u003ch3 id=\"字符集\"\u003e字符集\u003c/h3\u003e\n\u003cp\u003e在计算机系统中，所有的数据都以二进制存储，所有的运算也以二进制表示，人类语言和符号也需要转化成二进制的形式，才能存储在计算机中，于是需要有一个从人类语言到二进制编码的映射表。这个映射表就叫做字符集。\u003c/p\u003e\n\u003ch3 id=\"ascii\"\u003eASCII\u003c/h3\u003e\n\u003cp\u003e最早的字符集叫 American Standard Code for Information Interchange（美国信息交换标准代码），简称 ASCII，由 American National Standard Institute（美国国家标准协会）制定。在 ASCII 字符集中，字母 \u003ccode\u003eA\u003c/code\u003e 对应的字符编码是 \u003ccode\u003e65\u003c/code\u003e，转换成二进制是 \u003ccode\u003e0100 0001\u003c/code\u003e，由于二进制表示比较长，通常使用十六进制 \u003ccode\u003e41\u003c/code\u003e。\u003c/p\u003e\n\u003ch3 id=\"gb2312gbk\"\u003eGB2312、GBK\u003c/h3\u003e\n\u003cp\u003eASCII 字符集总共规定了 128 种字符规范，但是并没有涵盖西文字母之外的字符，当需要计算机显示存储中文的时候，就需要一种对中文进行编码的字符集，GB 2312 就是解决中文编码的字符集，由国家标准委员会发布。同时考虑到中文语境中往往也需要使用西文字母，GB 2312 也实现了对 ASCII 的向下兼容，原理是西文字母使用和 ASCII 中相同的代码，但是 GB 2312 只涵盖了 6000 多个汉字，还有很多没有包含在其中，所以又出现了 GBK 和 GB 18030，两种字符集都是在 GB 2312 的基础上进行了扩展。\u003c/p\u003e\n\u003ch3 id=\"unicode\"\u003eUnicode\u003c/h3\u003e\n\u003cp\u003e可以看到，光是简体中文，就先后出现了至少三种字符集，繁体中文方面也有 BIG5 等字符集，几乎每种语言都需要有一个自己的字符集，每个字符集使用了自己的编码规则，往往互不兼容。同一个字符在不同字符集下的字符代码不同，这使得跨语言交流的过程中双方必须要使用相同的字符编码才能不出现乱码的情况。为了解决传统字符编码的局限性，Unicode 诞生了，Unicoide 的全称是 Universal Multiple-Octet Coded Character Set（通用多八位字符集，简称 UCS）。Unicode 在一个字符集中包含了世界上所有文字和符号，统一编码，来终结不同编码产生乱码的问题。\u003c/p\u003e\n\u003ch3 id=\"字符编码-utf-8\"\u003e字符编码 UTF-8\u003c/h3\u003e\n\u003cp\u003eUnicode 统一了所有字符的编码，是一个 Character Set，也就是字符集，字符集只是给所有的字符一个唯一编号，但是却没有规定如何存储，一个编号为 \u003ccode\u003e65\u003c/code\u003e 的字符，只需要一个字节就可以存下，但是编号 \u003ccode\u003e40657\u003c/code\u003e 的字符需要两个字节的空间才可以装下，而更靠后的字符可能会需要三个甚至四个字节的空间。\u003c/p\u003e","title":"Unicode 和 UTF-8"},{"content":"\n在 golang 中创建并打印一个时间对象，会看到如下输出\n2018-10-26 14:15:50.306558969 +0800 CST m=+0.000401093 前面表示的意义好理解，分别是年月日和时间时区，最后的 m=+xxxx 这部分代表什么呢？\nMonotonic Clocks 和 Wall Clocks 根据 golang 的 time 包的文档可以知道，golang 的 time 结构中存储了两种时钟，一种是 Wall Clocks，一种是 Monotonic Clocks。\nWall Clocks，顾名思义，表示墙上挂的钟，在这里表示我们平时理解的时间，存储的形式是自 1970 年 1 月 1 日 0 时 0 分 0 秒以来的时间戳，当系统和授时服务器进行校准时间时间操作时，有可能造成这一秒是 2018-1-1 00:00:00，而下一秒变成了 2017-12-31 23:59:59 的情况。Monotonic Clocks，意思是单调时间的，所谓单调，就是只会不停的往前增长，不受校时操作的影响，这个时间是自进程启动以来的秒数。\n如果每隔一秒生成一个 Time 并打印出来，就会看到如下输出。\n2018-10-26 14:15:50.306558969 +0800 CST m=+0.000401093 2018-10-26 14:15:51.310559881 +0800 CST m=+1.004425285 2018-10-26 14:15:52.311822486 +0800 CST m=+2.005711106 2018-10-26 14:15:53.314599457 +0800 CST m=+3.008511329 2018-10-26 14:15:54.31882248 +0800 CST m=+4.012757636 2018-10-26 14:15:55.320059921 +0800 CST m=+5.014018292 2018-10-26 14:15:56.323814998 +0800 CST m=+6.017796644 2018-10-26 14:15:57.324858749 +0800 CST m=+7.018863606 2018-10-26 14:15:58.325164174 +0800 CST m=+8.019192224 2018-10-26 14:15:59.329058535 +0800 CST m=+9.023109863 2018-10-26 14:16:00.329591268 +0800 CST m=+10.023665796 可以看到 m=+后面所显示的数字，就是文档中所说的 Monotonic Clocks。\nTime 结构 那么 Monotonic Clock 和 Wall Clock 在 Time 中是怎么存储的呢？来看一下 Time 结构体。\ntype Time struct { wall uint64 ext int64 loc *Location } Time 结构体中由三部分组成，loc 比较明了，表示时区，wall 和 ext 所存储的信息规则相对复杂，根据文档的介绍总结成了下图：\ngolang 中的 Time 结构，不像很多语言保存 Unix 时间戳（也就是最早只能表示到 1970 年 1 月 1 日），而是至少可以安全的表示 1885 年以来的时间。\nt, _ := time.Parse(time.RFC3339, \u0026#34;1890-01-02T15:04:05Z\u0026#34;) fmt.Println(t) // 1890-01-02 15:04:05 +0000 UTC 实践中需要注意的问题 既然 Time 结构所表示的时间，有可能有 Monotonic Clock 也可能没有，那么在使用中就有可能遇到一些问题，例如下面这种情况。\nnow := time.Now() encodeNow, _ := json.Marshal(now) decodeNow := time.Time{} json.Unmarshal(encodeNow, \u0026amp;decodeNow) fmt.Println(now) // 2018-10-26 16:04:55.230121766 +0800 CST m=+0.000520419 fmt.Println(decodeNow) // 2018-10-26 16:04:55.230121766 +0800 CST 可以看到，经过 JSON 转码之后，Time 结构体会被表示成不带 Monotonic Clock 的字符串，丢失了 Monotonic Clock 信息，而将字符串转码回 Time 结构时，自然也就和转码之前的不一样了。同样的情况，也发生在数据库存储中，存储到数据库里的 Time 结构和从数据库取出来的也是不一样的。\n当调用 Equal 比较两个 Time 时，只有两个 Time 都含有 Monotonic Clock 时，才会根据 Monotonic Clock 比较大小，其他情况只比较 Wall Clock 部分。\ntimeA := time.Now() timeB := time.Unix(0, timeA.UnixNano()) fmt.Println(timeA) // 2018-10-26 16:37:02.216165074 +0800 CST m=+0.000363156 fmt.Println(timeB) // 2018-10-26 16:37:02.216165074 +0800 CST r := timeA.Equal(timeB) fmt.Println(r) // true 上面两个时间的 Wall Clock 部分相同，一个有 Monotonic Clock 一个没有，但是比较的结果是两个时间是相同的。\ntimeA := time.Now() timeB := time.Unix(timeA.Unix(), 0) fmt.Println(timeA) // 2018-10-26 16:38:25.653953438 +0800 CST m=+0.000364851 fmt.Println(timeB) // 2018-10-26 16:38:25 +0800 CST r := timeA.Equal(timeB) fmt.Println(r) // false 需要注意的是 Wall Clock 并不是秒之前的部分，Wall Clock 本身也可以精确到纳秒级别，所以一个精确到纳秒的时间和一个精确到秒的时间也是不同的。\n对于 Time 中的 Monotonic Clock，我们可以使用time.Round(0)方法将其消除掉，以实现和其他语言一致的行为。\ntimeA := time.Now() timeB := timeA.Round(0) fmt.Println(timeA) // 2018-10-26 16:43:03.799263739 +0800 CST m=+0.000357758 fmt.Println(timeB) // 2018-10-26 16:43:03.799263739 +0800 CST 参考文章 https://golang.org/pkg/time/\n","permalink":"https://simpleapples.com/zh/posts/understand-time-struct-in-go/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/images/20181026_01.png\"\u003e\u003c/p\u003e\n\u003cp\u003e在 golang 中创建并打印一个时间对象，会看到如下输出\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e2018-10-26 14:15:50.306558969 +0800 CST m=+0.000401093\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e前面表示的意义好理解，分别是年月日和时间时区，最后的 m=+xxxx 这部分代表什么呢？\u003c/p\u003e\n\u003c!-- more --\u003e\n\u003ch3 id=\"monotonic-clocks-和-wall-clocks\"\u003eMonotonic Clocks 和 Wall Clocks\u003c/h3\u003e\n\u003cp\u003e根据 golang 的 time 包的文档可以知道，golang 的 time 结构中存储了两种时钟，一种是 Wall Clocks，一种是 Monotonic Clocks。\u003c/p\u003e\n\u003cp\u003eWall Clocks，顾名思义，表示墙上挂的钟，在这里表示我们平时理解的时间，存储的形式是自 1970 年 1 月 1 日 0 时 0 分 0 秒以来的时间戳，当系统和授时服务器进行校准时间时间操作时，有可能造成这一秒是 2018-1-1 00:00:00，而下一秒变成了 2017-12-31 23:59:59 的情况。Monotonic Clocks，意思是单调时间的，所谓单调，就是只会不停的往前增长，不受校时操作的影响，这个时间是自进程启动以来的秒数。\u003c/p\u003e\n\u003cp\u003e如果每隔一秒生成一个 Time 并打印出来，就会看到如下输出。\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003e2018-10-26 14:15:50.306558969 +0800 CST m=+0.000401093\n2018-10-26 14:15:51.310559881 +0800 CST m=+1.004425285\n2018-10-26 14:15:52.311822486 +0800 CST m=+2.005711106\n2018-10-26 14:15:53.314599457 +0800 CST m=+3.008511329\n2018-10-26 14:15:54.31882248 +0800 CST m=+4.012757636\n2018-10-26 14:15:55.320059921 +0800 CST m=+5.014018292\n2018-10-26 14:15:56.323814998 +0800 CST m=+6.017796644\n2018-10-26 14:15:57.324858749 +0800 CST m=+7.018863606\n2018-10-26 14:15:58.325164174 +0800 CST m=+8.019192224\n2018-10-26 14:15:59.329058535 +0800 CST m=+9.023109863\n2018-10-26 14:16:00.329591268 +0800 CST m=+10.023665796\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e可以看到 m=+后面所显示的数字，就是文档中所说的 Monotonic Clocks。\u003c/p\u003e","title":"理解Golang的Time结构"},{"content":"\n更快的 Python（Python Faster Way）使用代码示例来说明如何书写 Python 代码能带来更高的性能。本文对代码进行了讲解，从性能和可读性等角度来选择出最适合的写法。\n例子 11：字符串连接 最差/最优时间比：1.15 使用建议：一次性连接多个（3 个以上）的字符串的时候，使用 join，其他情况使用加号或 f-string。 说明：又是一个字符串连接的问题，不过这个例子举的不好，join 适用的场景是一次连接多个字符串，会比加号连接多个字符串要快很多（加号相当于一个一个连接）。 例子 12：数字的格式化 最差/最优时间比：1.29 使用建议：需要复杂格式，推荐使用 format 方法；将数字转换为字符串，直接使用 str 方法。 说明：将数字转为字符串，使用 str 方法要快于 format 方法，因为 format 方法支持在转换过程中增加规则，例如将数字转为货币形式（每三位加一个逗号分隔符）。 例子 13：获取内置列表类型的长度 最差/最优时间比：1.20 使用建议：使用 len()方法。 说明：当调用 len()方法时，系统实际上是调用了对象内置的len方法，从这个层面理解，直接调用len应该比 len()方法更快。但是当 len()内置的列表方法时，Python 解释器做了优化，直接返回了列表对象中存储长度信息的变量，并不会调用len。 例子 14：整数类型的运算 最差/最优时间比：2.63 使用建议：不要直接调用add等魔术方法。 说明：对于整数类型，调用魔术方法完成运算的速度远远慢于直接使用运算符，使用运算符时，Python 解释器直接调用 C 实现的 operaotr 包中的运算方法，所以速度很快；而使用调用魔术方法，在 Python 层面多出了调用add等魔术方法的额外操作。 例子 15：自定义类型的运算符重载 最差/最优时间比：1.06 使用建议：不要直接调用add等魔术方法。 说明：对于重载了运算符的对象，没有对应的 C 实现运算方法，所以直接直接调用魔术方法速度会更快。 例子 16：对 range 结果求和 最差/最优时间比：2.95 使用建议：推荐使用第一种。 说明：和第一种相比，第三种会遍历 range 先生成一个列表，然后将列表传给 sum，速度最慢，而第一种直接传递迭代器给 sum，省去了遍历生成列表的过程；第二种和第一种相比则是在 Python 层面实现了求和，而 sum 是 C 层面实现的求和，所以也没有第一种块。 例子 17：for 循环和表达式构建列表的区别 最差/最优时间比：2.05 使用建议：推荐使用表达式构建。 说明：两种方式看上去逻辑一样，都是把 range 迭代器遍历，生成一个列表，但是表达式是在字节码层面构建了一个循环来生成，而第二种则是在 Python 层面创建列表，并不断 Append，性能上要差于第一种。 例子 18：for 循环和表达式构建字典的区别 最差/最优时间比：1.49 使用建议：推荐使用表达式。 说明：dict 的 update 方法适用于合并两个字典的情况，也就是说可以一次合并多个 key，所以相比于直接访问 key 速度要慢；根据图中的测试，在 100 这个量级上，表达式生成的速度要慢一些，但是在更大的量级上，表达式的优势就体现出来了，并且更加 Pythonic。首先表达式方法是在字节码层面生成循环的，所以理论上比 Python 层面生成循环构建字典要快的，那么为什么在小量级的场景下，字节码反倒没有优势呢？根据 dis 出的字节码可以看到，表达式构建首先会 MAKE_FUNCTION 然后再 CALL_FUNCTION，这里会有一些基本的消耗，量级小的时候，这些基本消耗占比高，量级越大，这些基本消耗所占比例就越低，表达式方法的优势也就越明显。 例子 19：for 循环和表达式构建字典的区别 最差/最优时间比：2.89 使用建议：推荐使用表达式构建。 说明：理由同上一个例子。 例子 20：转换为 bool 值 最差/最优时间比：N/A 使用建议：根据具体情况选择。 说明：这个比较似乎没有什么好说的，时间的区别主要原因是构建 a 对象的成本不同。 参考文章 Python Faster Way ","permalink":"https://simpleapples.com/zh/posts/faster-python-part-2/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/images/20181025_11.png\"\u003e\u003c/p\u003e\n\u003cp\u003e更快的 Python（\u003ca href=\"http://pythonfasterway.org\"\u003ePython Faster Way\u003c/a\u003e）使用代码示例来说明如何书写 Python 代码能带来更高的性能。本文对代码进行了讲解，从性能和可读性等角度来选择出最适合的写法。\u003c/p\u003e\n\u003c!-- more --\u003e\n\u003ch3 id=\"例子-11字符串连接\"\u003e例子 11：字符串连接\u003c/h3\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/images/20181025_01.png\"\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e最差/最优时间比：\u003cstrong\u003e1.15\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e使用建议：一次性连接多个（3 个以上）的字符串的时候，使用 join，其他情况使用加号或 f-string。\u003c/li\u003e\n\u003cli\u003e说明：又是一个字符串连接的问题，不过这个例子举的不好，join 适用的场景是一次连接多个字符串，会比加号连接多个字符串要快很多（加号相当于一个一个连接）。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"例子-12数字的格式化\"\u003e例子 12：数字的格式化\u003c/h3\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/images/20181025_02.png\"\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e最差/最优时间比：\u003cstrong\u003e1.29\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e使用建议：需要复杂格式，推荐使用 format 方法；将数字转换为字符串，直接使用 str 方法。\u003c/li\u003e\n\u003cli\u003e说明：将数字转为字符串，使用 str 方法要快于 format 方法，因为 format 方法支持在转换过程中增加规则，例如将数字转为货币形式（每三位加一个逗号分隔符）。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"例子-13获取内置列表类型的长度\"\u003e例子 13：获取内置列表类型的长度\u003c/h3\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/images/20181025_03.png\"\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e最差/最优时间比：\u003cstrong\u003e1.20\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e使用建议：使用 len()方法。\u003c/li\u003e\n\u003cli\u003e说明：当调用 len()方法时，系统实际上是调用了对象内置的\u003cstrong\u003elen\u003c/strong\u003e方法，从这个层面理解，直接调用\u003cstrong\u003elen\u003c/strong\u003e应该比 len()方法更快。但是当 len()内置的列表方法时，Python 解释器做了优化，直接返回了列表对象中存储长度信息的变量，并不会调用\u003cstrong\u003elen\u003c/strong\u003e。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"例子-14整数类型的运算\"\u003e例子 14：整数类型的运算\u003c/h3\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/images/20181025_04.png\"\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e最差/最优时间比：\u003cstrong\u003e2.63\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e使用建议：不要直接调用\u003cstrong\u003eadd\u003c/strong\u003e等魔术方法。\u003c/li\u003e\n\u003cli\u003e说明：对于整数类型，调用魔术方法完成运算的速度远远慢于直接使用运算符，使用运算符时，Python 解释器直接调用 C 实现的 operaotr 包中的运算方法，所以速度很快；而使用调用魔术方法，在 Python 层面多出了调用\u003cstrong\u003eadd\u003c/strong\u003e等魔术方法的额外操作。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"例子-15自定义类型的运算符重载\"\u003e例子 15：自定义类型的运算符重载\u003c/h3\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/images/20181025_05.png\"\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e最差/最优时间比：\u003cstrong\u003e1.06\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e使用建议：不要直接调用\u003cstrong\u003eadd\u003c/strong\u003e等魔术方法。\u003c/li\u003e\n\u003cli\u003e说明：对于重载了运算符的对象，没有对应的 C 实现运算方法，所以直接直接调用魔术方法速度会更快。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"例子-16对-range-结果求和\"\u003e例子 16：对 range 结果求和\u003c/h3\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/images/20181025_06.png\"\u003e\u003c/p\u003e","title":"翻译 | 更快的Python（二）"},{"content":"\n栈空间管理的基本逻辑 go 语言通过 goroutine 提供了并发编程支持，goroutine 是 go 运行库的功能，而不是操作系统线程实现的，goroutine 可以被理解成一个用户态的线程。\n既然 goroutine 是由 go 运行库管理的，那么 go 运行库也需要为每个 goroutine 创建并管理相应的栈空间，为每个 goroutine 分配的栈空间不能太大，goroutine 开多时会浪费大量空间，也不能太小，会导致栈溢出。go 语言选择栈的栈空间管理的方式是，一开始给一个比较小的空间，随着需要自动增长。当 goroutine 不需要那么大的空间时，栈空间也要自动缩小。\n分段栈 Segment Stacks 在 go 1.3 之前，go 使用分段栈。\n分段栈实现了一种不连续但是可以持续增长的栈，开始时，栈只有一个段，当需要更多的栈空间时，会分配一个新的段，和上一个栈双向链接。这样，一个栈就是由多个双向链接的段所组成的。当新分配的段使用完毕后，新段会被释放掉。\n分段栈实现了栈的按需收缩，在增加新分段时也不需要对原有分段中的数据进行拷贝，使得 goroutine 的使用代价非常低廉。\n分段栈的好处是可以按需增长，空间利用率比较高，然而分段栈在某些情况下也存在一定的瑕疵。当一个段即将用尽，这时使用 for 循环执行一个比较耗空间的函数，会导致函数执行时 goroutine 进行段的分配，而执行完成返回时，进行段的销毁，这样就会导致在循环中出现多次栈的扩容和收缩，造成很大的性能损失，这种情况被称作栈分裂（Stack Split）。\n连续栈 Contiguous Stacks go 1.3 推出了连续栈，连续栈使用了另外一种策略，不再把栈分成一段一段的，当栈空间不够时，直接 new 一个 2 倍大的栈空间，并将原先栈空间中的数据拷贝到新的栈空间中，而后销毁旧栈。这样当出现栈空间触及边界时，不会产生栈分裂的情况。\n继续假设当前栈空间即将用尽，并且需要在 for 循环中执行一个比较消耗空间的函数。当该函数执行时，栈空间发生了扩容，变成原先 2 倍大小，函数执行完成一次后，栈空间的使用量缩小回执行前的大小，但是栈空间的使用量并没有小于栈大小的 1/4，不会触发栈收缩，所以在整个 for 循环执行过程中，不会反复触发栈空间的收缩扩容。\n总结 相比于分段栈，连续栈避免了某些场景下栈空间的的频繁伸缩。有一点需要注意的是，连续栈的收缩也是需要重新申请一段空间（原先的 1/2 大小），并进行栈拷贝操作的。\n","permalink":"https://simpleapples.com/zh/posts/stacks-in-go/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/images/20181011_01.jpg\"\u003e\u003c/p\u003e\n\u003ch3 id=\"栈空间管理的基本逻辑\"\u003e栈空间管理的基本逻辑\u003c/h3\u003e\n\u003cp\u003ego 语言通过 goroutine 提供了并发编程支持，goroutine 是 go 运行库的功能，而不是操作系统线程实现的，goroutine 可以被理解成一个用户态的线程。\u003c/p\u003e\n\u003cp\u003e既然 goroutine 是由 go 运行库管理的，那么 go 运行库也需要为每个 goroutine 创建并管理相应的栈空间，为每个 goroutine 分配的栈空间不能太大，goroutine 开多时会浪费大量空间，也不能太小，会导致栈溢出。go 语言选择栈的栈空间管理的方式是，一开始给一个比较小的空间，随着需要自动增长。当 goroutine 不需要那么大的空间时，栈空间也要自动缩小。\u003c/p\u003e\n\u003ch3 id=\"分段栈-segment-stacks\"\u003e分段栈 Segment Stacks\u003c/h3\u003e\n\u003cp\u003e在 go 1.3 之前，go 使用分段栈。\u003c/p\u003e\n\u003cp\u003e分段栈实现了一种不连续但是可以持续增长的栈，开始时，栈只有一个段，当需要更多的栈空间时，会分配一个新的段，和上一个栈双向链接。这样，一个栈就是由多个双向链接的段所组成的。当新分配的段使用完毕后，新段会被释放掉。\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/images/20181011_02.png\"\u003e\u003c/p\u003e\n\u003cp\u003e分段栈实现了栈的按需收缩，在增加新分段时也不需要对原有分段中的数据进行拷贝，使得 goroutine 的使用代价非常低廉。\u003c/p\u003e\n\u003cp\u003e分段栈的好处是可以按需增长，空间利用率比较高，然而分段栈在某些情况下也存在一定的瑕疵。当一个段即将用尽，这时使用 for 循环执行一个比较耗空间的函数，会导致函数执行时 goroutine 进行段的分配，而执行完成返回时，进行段的销毁，这样就会导致在循环中出现多次栈的扩容和收缩，造成很大的性能损失，这种情况被称作栈分裂（Stack Split）。\u003c/p\u003e\n\u003ch3 id=\"连续栈-contiguous-stacks\"\u003e连续栈 Contiguous Stacks\u003c/h3\u003e\n\u003cp\u003ego 1.3 推出了连续栈，连续栈使用了另外一种策略，不再把栈分成一段一段的，当栈空间不够时，直接 new 一个 2 倍大的栈空间，并将原先栈空间中的数据拷贝到新的栈空间中，而后销毁旧栈。这样当出现栈空间触及边界时，不会产生栈分裂的情况。\u003c/p\u003e\n\u003cp\u003e继续假设当前栈空间即将用尽，并且需要在 for 循环中执行一个比较消耗空间的函数。当该函数执行时，栈空间发生了扩容，变成原先 2 倍大小，函数执行完成一次后，栈空间的使用量缩小回执行前的大小，但是栈空间的使用量并没有小于栈大小的 1/4，不会触发栈收缩，所以在整个 for 循环执行过程中，不会反复触发栈空间的收缩扩容。\u003c/p\u003e\n\u003ch3 id=\"总结\"\u003e总结\u003c/h3\u003e\n\u003cp\u003e相比于分段栈，连续栈避免了某些场景下栈空间的的频繁伸缩。有一点需要注意的是，连续栈的收缩也是需要重新申请一段空间（原先的 1/2 大小），并进行栈拷贝操作的。\u003c/p\u003e","title":"Go的栈空间管理"},{"content":"\n更快的 Python（Python Faster Way）使用代码示例来说明如何书写 Python 代码能带来更高的性能。本文对代码进行了讲解，从性能和可读性等角度来选择出最适合的写法。\n例子 1：字符串格式化 最差/最优时间比：1.95 使用建议：Python 3.7 或以上推荐使用 f-string，其他版本推荐使用 format 方法。 说明：字符串格式化是代码中最常遇到的情况，虽然在连接少量字符串的情景中，使用+号的性能最优，但是使用+号的代码可读性最差。如果使用 Python 3.7 或优以上版本，可以使用 f-string 来解决这个问题，f-string 的性能比 format 方法和%操作符的性能都要高，可读性也比+号好。 例子 2：字典的初始化 最差/最优时间比：1.83 使用建议：使用字面量初始化字典（以及其他集合类型）。 说明：Python 中初始化集合类型时使用字面量的方式，解释器会直接调用 BUILD_MAP 等字节码来创建，如果用构造函数的方式来创建，则需要先查询构造方法，再执行构造方法。使用字面量初始化，Python 代码也更简洁。 例子 3：内置排序方法 最差/最优时间比：1.26 使用建议：根据是否需要修改原始值来决定使用哪个方法。 说明：sorted 和 list.sort 方法是 Python 中内置的排序方法，sorted 方法不会修改原始值，list.sort 方法在原始值上直接排序，会修改原始值。比较这两个方法的性能差异，意义不大。 例子 4：初始化多个变量 最差/最优时间比：1.01 使用建议：推荐使用第二种。 说明：从字节码中可以看出两种方式出了执行顺序之外，基本一致，所以性能上也非常接近。 例子 5：多个变量的比较 最差/最优时间比：1.11 使用建议：推荐使用第二种。 说明：使用第一种方法能带来一定的性能提升，但是提升有限，在实际情况中也很少出现多个变量连续比较大小的情况，并且第一种方法非常不 Pythonic，所以推荐使用第二种。 例子 6：if true 的条件判断 最差/最优时间比：1.17 使用建议：推荐使用第一种。 说明：从字节码上看，第一种方法的性能最高，并且语法上也更加简洁。 例子 7：if false 的条件判断 最差/最优时间比：1.10 使用建议：推荐使用第一种。 说明：从字节码上看，第一种方法的性能最高，语法角度上，if not 写成第二种和第三种都是不推荐的。 例子 8：判断 list 是否为空 最差/最优时间比：1.55 使用建议：根据具体需求，优先使用前两种。 说明：前两种代码性能更高，代码更简洁。同时，空列表 a 并不等于 None，所以使用 if a is None 无法实现对空列表的判断。 例子 9：判断 object 是否为空 最差/最优时间比：1.00 使用建议：根据具体需求，优先使用前两种。 说明：理由同上一个例子。 例子 10：遍历可迭代对象 最差/最优时间比：1.12 使用建议：根据具体情况选择。 说明：两者性能差别不大，使用 enumerate 方法，可以不需要取对象的长度，可以直接获取到对象的 index。 参考文章 Python Faster Way ","permalink":"https://simpleapples.com/zh/posts/faster-python-part-1/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/images/20181008_11.png\"\u003e\u003c/p\u003e\n\u003cp\u003e更快的 Python（\u003ca href=\"http://pythonfasterway.org\"\u003ePython Faster Way\u003c/a\u003e）使用代码示例来说明如何书写 Python 代码能带来更高的性能。本文对代码进行了讲解，从性能和可读性等角度来选择出最适合的写法。\u003c/p\u003e\n\u003ch3 id=\"例子-1字符串格式化\"\u003e例子 1：字符串格式化\u003c/h3\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/images/20181008_01.png\"\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e最差/最优时间比：\u003cstrong\u003e1.95\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e使用建议：Python 3.7 或以上推荐使用 f-string，其他版本推荐使用 format 方法。\u003c/li\u003e\n\u003cli\u003e说明：字符串格式化是代码中最常遇到的情况，虽然在连接少量字符串的情景中，使用+号的性能最优，但是使用+号的代码可读性最差。如果使用 Python 3.7 或优以上版本，可以使用 f-string 来解决这个问题，f-string 的性能比 format 方法和%操作符的性能都要高，可读性也比+号好。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"例子-2字典的初始化\"\u003e例子 2：字典的初始化\u003c/h3\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/images/20181008_02.png\"\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e最差/最优时间比：\u003cstrong\u003e1.83\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e使用建议：使用字面量初始化字典（以及其他集合类型）。\u003c/li\u003e\n\u003cli\u003e说明：Python 中初始化集合类型时使用字面量的方式，解释器会直接调用 BUILD_MAP 等字节码来创建，如果用构造函数的方式来创建，则需要先查询构造方法，再执行构造方法。使用字面量初始化，Python 代码也更简洁。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"例子-3内置排序方法\"\u003e例子 3：内置排序方法\u003c/h3\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/images/20181008_03.png\"\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e最差/最优时间比：\u003cstrong\u003e1.26\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e使用建议：根据是否需要修改原始值来决定使用哪个方法。\u003c/li\u003e\n\u003cli\u003e说明：sorted 和 list.sort 方法是 Python 中内置的排序方法，sorted 方法不会修改原始值，list.sort 方法在原始值上直接排序，会修改原始值。比较这两个方法的性能差异，意义不大。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"例子-4初始化多个变量\"\u003e例子 4：初始化多个变量\u003c/h3\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/images/20181008_04.png\"\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e最差/最优时间比：\u003cstrong\u003e1.01\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e使用建议：推荐使用第二种。\u003c/li\u003e\n\u003cli\u003e说明：从字节码中可以看出两种方式出了执行顺序之外，基本一致，所以性能上也非常接近。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"例子-5多个变量的比较\"\u003e例子 5：多个变量的比较\u003c/h3\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/images/20181008_05.png\"\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e最差/最优时间比：\u003cstrong\u003e1.11\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e使用建议：推荐使用第二种。\u003c/li\u003e\n\u003cli\u003e说明：使用第一种方法能带来一定的性能提升，但是提升有限，在实际情况中也很少出现多个变量连续比较大小的情况，并且第一种方法非常不 Pythonic，所以推荐使用第二种。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"例子-6if-true-的条件判断\"\u003e例子 6：if true 的条件判断\u003c/h3\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/images/20181008_06.png\"\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e最差/最优时间比：\u003cstrong\u003e1.17\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e使用建议：推荐使用第一种。\u003c/li\u003e\n\u003cli\u003e说明：从字节码上看，第一种方法的性能最高，并且语法上也更加简洁。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"例子-7if-false-的条件判断\"\u003e例子 7：if false 的条件判断\u003c/h3\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/images/20181008_07.png\"\u003e\u003c/p\u003e","title":"翻译 | 更快的Python（一）"},{"content":"\ndefer 语句是 Go 中一个非常有用的特性，可以将一个方法延迟到包裹该方法的方法返回时执行，在实际应用中，defer 语句可以充当其他语言中 try…catch…的角色，也可以用来处理关闭文件句柄等收尾操作。\ndefer 触发时机 A \u0026ldquo;defer\u0026rdquo; statement invokes a function whose execution is deferred to the moment the surrounding function returns, either because the surrounding function executed a return statement, reached the end of its function body, or because the corresponding goroutine is panicking.\nGo 官方文档中对 defer 的执行时机做了阐述，分别是。\n包裹 defer 的函数返回时 包裹 defer 的函数执行到末尾时 所在的 goroutine 发生 panic 时 defer 执行顺序 当一个方法中有多个 defer 时， defer 会将要延迟执行的方法“压栈”，当 defer 被触发时，将所有“压栈”的方法“出栈”并执行。所以 defer 的执行顺序是 LIFO 的。\n所以下面这段代码的输出不是 1 2 3，而是 3 2 1。\nfunc stackingDefers() { defer func() { fmt.Println(\u0026#34;1\u0026#34;) }() defer func() { fmt.Println(\u0026#34;2\u0026#34;) }() defer func() { fmt.Println(\u0026#34;3\u0026#34;) }() } 坑 1：defer 在匿名返回值和命名返回值函数中的不同表现 先看下面两个方法执行的结果。\nfunc returnValues() int { var result int defer func() { result++ fmt.Println(\u0026#34;defer\u0026#34;) }() return result } func namedReturnValues() (result int) { defer func() { result++ fmt.Println(\u0026#34;defer\u0026#34;) }() return result } 上面的方法会输出 0，下面的方法输出 1。上面的方法使用了匿名返回值，下面的使用了命名返回值，除此之外其他的逻辑均相同，为什么输出的结果会有区别呢？\n要搞清这个问题首先需要了解 defer 的执行逻辑，文档中说 defer 语句在方法返回“时”触发，也就是说 return 和 defer 是“同时”执行的。以匿名返回值方法举例，过程如下。\n将 result 赋值给返回值（可以理解成 Go 自动创建了一个返回值 retValue，相当于执行 retValue = result） 然后检查是否有 defer，如果有则执行 返回刚才创建的返回值（retValue） 在这种情况下，defer 中的修改是对 result 执行的，而不是 retValue，所以 defer 返回的依然是 retValue。在命名返回值方法中，由于返回值在方法定义时已经被定义，所以没有创建 retValue 的过程，result 就是 retValue，defer 对于 result 的修改也会被直接返回。\n坑 2：在 for 循环中使用 defer 可能导致的性能问题 看下面的代码\nfunc deferInLoops() { for i := 0; i \u0026lt; 100; i++ { f, _ := os.Open(\u0026#34;/etc/hosts\u0026#34;) defer f.Close() } } defer 在紧邻创建资源的语句后生命力，看上去逻辑没有什么问题。但是和直接调用相比，defer 的执行存在着额外的开销，例如 defer 会对其后需要的参数进行内存拷贝，还需要对 defer 结构进行压栈出栈操作。所以在循环中定义 defer 可能导致大量的资源开销，在本例中，可以将 f.Close()语句前的 defer 去掉，来减少大量 defer 导致的额外资源消耗。\n坑 3：判断执行没有 err 之后，再 defer 释放资源 一些获取资源的操作可能会返回 err 参数，我们可以选择忽略返回的 err 参数，但是如果要使用 defer 进行延迟释放的的话，需要在使用 defer 之前先判断是否存在 err，如果资源没有获取成功，即没有必要也不应该再对资源执行释放操作。如果不判断获取资源是否成功就执行释放操作的话，还有可能导致释放方法执行错误。\n正确写法如下。\nresp, err := http.Get(url) // 先判断操作是否成功 if err != nil { return err } // 如果操作成功，再进行Close操作 defer resp.Body.Close() 坑 4：调用 os.Exit 时 defer 不会被执行 当发生 panic 时，所在 goroutine 的所有 defer 会被执行，但是当调用 os.Exit()方法退出程序时，defer 并不会被执行。\nfunc deferExit() { defer func() { fmt.Println(\u0026#34;defer\u0026#34;) }() os.Exit(0) } 上面的 defer 并不会输出。\n","permalink":"https://simpleapples.com/zh/posts/how-to-use-defer-in-go/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/images/20180914_01.png\"\u003e\u003c/p\u003e\n\u003cp\u003edefer 语句是 Go 中一个非常有用的特性，可以将一个方法延迟到包裹该方法的方法返回时执行，在实际应用中，defer 语句可以充当其他语言中 try…catch…的角色，也可以用来处理关闭文件句柄等收尾操作。\u003c/p\u003e\n\u003ch3 id=\"defer-触发时机\"\u003edefer 触发时机\u003c/h3\u003e\n\u003cblockquote\u003e\n\u003cp\u003eA \u0026ldquo;defer\u0026rdquo; statement invokes a function whose execution is deferred to the moment the surrounding function returns, either because the surrounding function executed a return statement, reached the end of its function body, or because the corresponding goroutine is panicking.\u003c/p\u003e\u003c/blockquote\u003e\n\u003cp\u003eGo 官方文档中对 defer 的执行时机做了阐述，分别是。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e包裹 defer 的函数返回时\u003c/li\u003e\n\u003cli\u003e包裹 defer 的函数执行到末尾时\u003c/li\u003e\n\u003cli\u003e所在的 goroutine 发生 panic 时\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3 id=\"defer-执行顺序\"\u003edefer 执行顺序\u003c/h3\u003e\n\u003cp\u003e当一个方法中有多个 defer 时， defer 会将要延迟执行的方法“压栈”，当 defer 被触发时，将所有“压栈”的方法“出栈”并执行。所以 defer 的执行顺序是 LIFO 的。\u003c/p\u003e","title":"Go语言中defer的一些坑"},{"content":"\n现在有一组数，不知道这组数的总量有多少，请描述一种算法能够在这组数据中随机抽取 k 个数，使得每个数被取出来的概率相等。\n如果这组数有 n 个，那么每个数字取到的概率就是 k/n，但是这个问题的难点在于不知道这组数的总数，也就是不知道 n，那么该怎么计算每个数取到的概率呢？\n蓄水池算法 游泳池（蓄水池）大家都不陌生，有些游泳池中的水是活的，有入水管也有出水管，那么和泳池体积相当的水流过之后，是不是泳池中所有的水都会被替换呢？当然不是，有的水在泳池中可能会存留很久，有的可能刚进去就流走了。仿照这种现象，蓄水池抽样算法诞生了，蓄水池算法的关键在于保证流入蓄水池的水和已经在池中的水以相同的概率留存在蓄水池中。并且蓄水池算法可以在不预先知道总量的情况下，在时间复杂度 O(N)的情况下，来解决这类采样问题。\n核心原理 这一部分涉及公式，为了保证效果直接贴了图过来。\nPython 实现 接下来尝试用 Python 实现一下蓄水池算法，由于蓄水池算法是在事先不知道总量的情况下抽样的，所以定义一个方法来接收单个元素，并且把这个方法放在类中，以持有采样后的数据。\nimport random class ReservoirSample(object): def __init__(self, size): self._size = size self._counter = 0 self._sample = [] def feed(self, item): self._counter += 1 # 第i个元素（i \u0026lt;= k），直接进入池中 if len(self._sample) \u0026lt; self._size: self._sample.append(item) return self._sample # 第i个元素（i \u0026gt; k），以k / i的概率进入池中 rand_int = random.randint(1, self._counter) if rand_int \u0026lt;= self._size: self._sample[rand_int - 1] = item return self._sample 测试代码 接下来实现一个测试用例验证实现的算法是否正确，既然是随机抽样，无法通过单词测试来验证是否正确，所以通过多次执行的方式来验证，比如从 1-10 里随机取样 3 个数，然后执行 10000 次取样，如果算法正确，最后结果中 1-10 被取样的次数应该是相同的，都是 3000 上下。\nimport unittest from collections import Counter from reservoir_sample import ReservoirSample class TestMain(unittest.TestCase): def test_reservoir_sample(self): samples = [] for i in range(10000): sample = [] rs = ReservoirSample(3) for item in range(1, 11): sample = rs.feed(item) samples.extend(sample) r = Counter(samples) print(r) if __name__ == \u0026#39;__main__\u0026#39;: unittest.main() 输出的结果如下\nCounter({7: 3084, 6: 3042, 10: 3033, 3: 3020, 8: 3016, 5: 2997, 4: 2986, 2: 2972, 9: 2932, 1: 2918}) 上面输出了每个数字被取样到的次数，通过图表可以清晰的看到分布情况\n可以看出蓄水池算法对于随机抽样还是非常适合的，每个元素的抽样概率都相同。\n代码 上述的算法和测试代码已经放在Github，可以直接下载使用。\n","permalink":"https://simpleapples.com/zh/posts/implementation-of-reservoir-sample-in-python/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/images/20180805_01.jpg\"\u003e\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e现在有一组数，不知道这组数的总量有多少，请描述一种算法能够在这组数据中随机抽取 k 个数，使得每个数被取出来的概率相等。\u003c/p\u003e\u003c/blockquote\u003e\n\u003cp\u003e如果这组数有 n 个，那么每个数字取到的概率就是 k/n，但是这个问题的难点在于不知道这组数的总数，也就是不知道 n，那么该怎么计算每个数取到的概率呢？\u003c/p\u003e\n\u003ch1 id=\"蓄水池算法\"\u003e蓄水池算法\u003c/h1\u003e\n\u003cp\u003e游泳池（蓄水池）大家都不陌生，有些游泳池中的水是活的，有入水管也有出水管，那么和泳池体积相当的水流过之后，是不是泳池中所有的水都会被替换呢？当然不是，有的水在泳池中可能会存留很久，有的可能刚进去就流走了。仿照这种现象，蓄水池抽样算法诞生了，蓄水池算法的关键在于保证流入蓄水池的水和已经在池中的水以相同的概率留存在蓄水池中。并且蓄水池算法可以在不预先知道总量的情况下，在时间复杂度 O(N)的情况下，来解决这类采样问题。\u003c/p\u003e\n\u003ch1 id=\"核心原理\"\u003e核心原理\u003c/h1\u003e\n\u003cp\u003e这一部分涉及公式，为了保证效果直接贴了图过来。\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/images/20180805_02.jpg\"\u003e\u003c/p\u003e\n\u003ch1 id=\"python-实现\"\u003ePython 实现\u003c/h1\u003e\n\u003cp\u003e接下来尝试用 Python 实现一下蓄水池算法，由于蓄水池算法是在事先不知道总量的情况下抽样的，所以定义一个方法来接收单个元素，并且把这个方法放在类中，以持有采样后的数据。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003eimport\u003c/span\u003e random\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eReservoirSample\u003c/span\u003e(object):\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003edef\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003e__init__\u003c/span\u003e(self, size):\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        self\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003e_size \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e size\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        self\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003e_counter \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        self\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003e_sample \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e []\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003edef\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003efeed\u003c/span\u003e(self, item):\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        self\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003e_counter \u003cspan style=\"color:#f92672\"\u003e+=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#75715e\"\u003e# 第i个元素（i \u0026lt;= k），直接进入池中\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e len(self\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003e_sample) \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e self\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003e_size:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            self\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003e_sample\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003eappend(item)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e self\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003e_sample\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#75715e\"\u003e# 第i个元素（i \u0026gt; k），以k / i的概率进入池中\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        rand_int \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e random\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003erandint(\u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e, self\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003e_counter)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e rand_int \u003cspan style=\"color:#f92672\"\u003e\u0026lt;=\u003c/span\u003e self\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003e_size:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            self\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003e_sample[rand_int \u003cspan style=\"color:#f92672\"\u003e-\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e] \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e item\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e self\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003e_sample\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch1 id=\"测试代码\"\u003e测试代码\u003c/h1\u003e\n\u003cp\u003e接下来实现一个测试用例验证实现的算法是否正确，既然是随机抽样，无法通过单词测试来验证是否正确，所以通过多次执行的方式来验证，比如从 1-10 里随机取样 3 个数，然后执行 10000 次取样，如果算法正确，最后结果中 1-10 被取样的次数应该是相同的，都是 3000 上下。\u003c/p\u003e","title":"用Python写算法 | 蓄水池算法实现随机抽样"},{"content":"\n对于一门编程语言来说，代码格式化是最容易引起争议的一个问题，不同的开发者可能会有不同的编码风格和习惯，但是如果所有开发者都能使用同一种格式来编写代码，开发者就可以将宝贵的时间专注在语言要解决的问题上。\ngofmt 介绍 Golang 的开发团队制定了统一的官方代码风格，并且推出了 gofmt 工具（gofmt 或 go fmt）来帮助开发者格式化他们的代码到统一的风格。gofmt 是一个 cli 程序，会优先读取标准输入，如果传入了文件路径的话，会格式化这个文件，如果传入一个目录，会格式化目录中所有.go 文件，如果不传参数，会格式化当前目录下的所有.go 文件。\ngofmt 默认不对代码进行简化，使用-s 参数可以开启简化代码功能，具体来说会进行如下的转换：\n去除数组、切片、Map 初始化时不必要的类型声明： 如下形式的切片表达式： []T{T{}, T{}} 将被简化为： []T{{}, {}} 去除数组切片操作时不必要的索引指定 如下形式的切片表达式： s[a:len(s)] 将被简化为： s[a:] 去除迭代时非必要的变量赋值 如下形式的迭代： for x, _ = range v {...} 将被简化为： for x = range v {...} 如下形式的迭代： for _ = range v {...} 将被简化为： for range v {...} gofmt 命令参数列表如下：\nusage: gofmt [flags] [path ...] -cpuprofile string write cpu profile to this file -d display diffs instead of rewriting files -e report all errors (not just the first 10 on different lines) -l list files whose formatting differs from gofmt\u0026#39;s -r string rewrite rule (e.g., \u0026#39;a[b:len(a)] -\u0026gt; a[b:]\u0026#39;) -s simplify code -w write result to (source) file instead of stdout 可以看到，gofmt 命令还支持自定义的重写规则，使用-r 参数，按照 pattern -\u0026gt; replacement 的格式传入规则。\n有如下内容的 Golang 程序，存储在 main.go 文件中。\npackage main import \u0026#34;fmt\u0026#34; func main() { a := 1 b := 2 c := a + b fmt.Println(c) } 用以下规则来格式化上面的代码。\ngofmt -r \u0026#34;a + b -\u0026gt; b + a\u0026#34; 格式化的结果如下。\npackage main import \u0026#34;fmt\u0026#34; func main() { a := 1 b := 2 c := b + a fmt.Println(c) } *注意：Gofmt 使用 tab 来表示缩进，并且对行宽度无限制，如果手动对代码进行了换行，gofmt 也不会强制把代码格式化回一行。\ngo fmt 和 gofmt gofmt 是一个独立的 cli 程序，而 go 中还有一个 go fmt 命令，go fmt 命令是 gofmt 的简单封装。\nusage: go fmt [-n] [-x] [packages] Fmt runs the command \u0026#39;gofmt -l -w\u0026#39; on the packages named by the import paths. It prints the names of the files that are modified. For more about gofmt, see \u0026#39;go doc cmd/gofmt\u0026#39;. For more about specifying packages, see \u0026#39;go help packages\u0026#39;. The -n flag prints commands that would be executed. The -x flag prints commands as they are executed. To run gofmt with specific options, run gofmt itself. See also: go fix, go vet. go fmt 命令本身只有两个可选参数-n 和-x，-n 仅打印出内部要执行的 go fmt 的命令，-x 命令既打印出 go fmt 命令又执行它，如果需要更细化的配置，需要直接执行 gofmt 命令。\ngo fmt 在调用 gofmt 时添加了-l -w 参数，相当于执行了gofmt -l -w。\ngoland 中配置 gofmt Goland 是 JetBrains 公司推出的 Go 语言 IDE，是一款功能强大，使用便捷的产品。\n在 Goland 中，可以通过添加一个 File Watcher 来在文件发生变化的时候调用 gofmt 进行代码格式化，具体方法是，点击 Preferences -\u0026gt; Tools -\u0026gt; File Watchers，点加号添加一个 go fmt 模版，Goland 中预置的 go fmt 模版使用的是 go fmt 命令，将其替换为 gofmt，然后在参数中增加-l -w -s 参数，启用代码简化功能。添加配置后，保存源码时，goland 就会执行代码格式化了。\n参考文章 https://golang.org/cmd/gofmt/\nhttps://golang.org/doc/effective_go.html\nhttps://openhome.cc/Gossip/Go/gofmt.html\nhttps://github.com/hyper0x/go_command_tutorial/blob/master/0.9.md\n","permalink":"https://simpleapples.com/zh/posts/gofmt-formating-your-code/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/images/20180717_01.png\"\u003e\u003c/p\u003e\n\u003cp\u003e对于一门编程语言来说，代码格式化是最容易引起争议的一个问题，不同的开发者可能会有不同的编码风格和习惯，但是如果所有开发者都能使用同一种格式来编写代码，开发者就可以将宝贵的时间专注在语言要解决的问题上。\u003c/p\u003e\n\u003ch1 id=\"gofmt-介绍\"\u003egofmt 介绍\u003c/h1\u003e\n\u003cp\u003eGolang 的开发团队制定了统一的官方代码风格，并且推出了 gofmt 工具（gofmt 或 go fmt）来帮助开发者格式化他们的代码到统一的风格。gofmt 是一个 cli 程序，会优先读取标准输入，如果传入了文件路径的话，会格式化这个文件，如果传入一个目录，会格式化目录中所有.go 文件，如果不传参数，会格式化当前目录下的所有.go 文件。\u003c/p\u003e\n\u003cp\u003egofmt 默认不对代码进行简化，使用-s 参数可以开启简化代码功能，具体来说会进行如下的转换：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e去除数组、切片、Map 初始化时不必要的类型声明：\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-go\" data-lang=\"go\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#a6e22e\"\u003e如下形式的切片表达式\u003c/span\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e：\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    []\u003cspan style=\"color:#a6e22e\"\u003eT\u003c/span\u003e{\u003cspan style=\"color:#a6e22e\"\u003eT\u003c/span\u003e{}, \u003cspan style=\"color:#a6e22e\"\u003eT\u003c/span\u003e{}}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#a6e22e\"\u003e将被简化为\u003c/span\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e：\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    []\u003cspan style=\"color:#a6e22e\"\u003eT\u003c/span\u003e{{}, {}}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e去除数组切片操作时不必要的索引指定\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-go\" data-lang=\"go\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#a6e22e\"\u003e如下形式的切片表达式\u003c/span\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e：\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#a6e22e\"\u003es\u003c/span\u003e[\u003cspan style=\"color:#a6e22e\"\u003ea\u003c/span\u003e:len(\u003cspan style=\"color:#a6e22e\"\u003es\u003c/span\u003e)]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#a6e22e\"\u003e将被简化为\u003c/span\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e：\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#a6e22e\"\u003es\u003c/span\u003e[\u003cspan style=\"color:#a6e22e\"\u003ea\u003c/span\u003e:]\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e去除迭代时非必要的变量赋值\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-go\" data-lang=\"go\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#a6e22e\"\u003e如下形式的迭代\u003c/span\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e：\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003efor\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ex\u003c/span\u003e, \u003cspan style=\"color:#a6e22e\"\u003e_\u003c/span\u003e = \u003cspan style=\"color:#66d9ef\"\u003erange\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ev\u003c/span\u003e {\u003cspan style=\"color:#f92672\"\u003e...\u003c/span\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#a6e22e\"\u003e将被简化为\u003c/span\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e：\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003efor\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ex\u003c/span\u003e = \u003cspan style=\"color:#66d9ef\"\u003erange\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ev\u003c/span\u003e {\u003cspan style=\"color:#f92672\"\u003e...\u003c/span\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#a6e22e\"\u003e如下形式的迭代\u003c/span\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e：\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003efor\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003e_\u003c/span\u003e = \u003cspan style=\"color:#66d9ef\"\u003erange\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ev\u003c/span\u003e {\u003cspan style=\"color:#f92672\"\u003e...\u003c/span\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#a6e22e\"\u003e将被简化为\u003c/span\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e：\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003efor\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003erange\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ev\u003c/span\u003e {\u003cspan style=\"color:#f92672\"\u003e...\u003c/span\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003egofmt 命令参数列表如下：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eusage: gofmt \u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003eflags\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003epath ...\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  -cpuprofile string\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        write cpu profile to this file\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  -d    display diffs instead of rewriting files\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  -e    report all errors \u003cspan style=\"color:#f92672\"\u003e(\u003c/span\u003enot just the first \u003cspan style=\"color:#ae81ff\"\u003e10\u003c/span\u003e on different lines\u003cspan style=\"color:#f92672\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  -l    list files whose formatting differs from gofmt\u003cspan style=\"color:#e6db74\"\u003e\u0026#39;s\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#e6db74\"\u003e  -r string\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#e6db74\"\u003e        rewrite rule (e.g., \u0026#39;\u003c/span\u003ea\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003eb:len\u003cspan style=\"color:#f92672\"\u003e(\u003c/span\u003ea\u003cspan style=\"color:#f92672\"\u003e)]\u003c/span\u003e -\u0026gt; a\u003cspan style=\"color:#f92672\"\u003e[\u003c/span\u003eb:\u003cspan style=\"color:#f92672\"\u003e]\u003c/span\u003e\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\u0026#39;\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  -s    simplify code\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e  -w    write result to \u003cspan style=\"color:#f92672\"\u003e(\u003c/span\u003esource\u003cspan style=\"color:#f92672\"\u003e)\u003c/span\u003e file instead of stdout\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e可以看到，gofmt 命令还支持自定义的重写规则，使用-r 参数，按照 pattern -\u0026gt; replacement 的格式传入规则。\u003c/p\u003e","title":"使用gofmt格式化代码"},{"content":"\n问题描述 在搭建 Kubernetes 集群过程中，安装了 kube-dns 插件后，运行一个 ubuntu 容器，发现容器内无法解析集群外域名，一开始可以解析集群内域名，一段时间后也无法解析集群内域名。\n$ nslookup kubernetes.default Server: 10.99.0.2 Address 1: 10.99.0.2 kube-dns.kube-system.svc.cluster.local nslookup: can\u0026#39;t resolve \u0026#39;kubernetes.default\u0026#39; 排查过程 在排查问题前，先思考一下 Kubernetes 集群中的 DNS 解析过程，在安装好 kube-dns 的集群中，普通 Pod 的 dnsPolicy 属性是默认值 ClusterFirst，也就是会指向集群内部的 DNS 服务器，kube-dns 负责解析集群内部的域名，kube-dns Pod 的 dnsPolicy 值是 Default，意思是从所在 Node 继承 DNS 服务器，对于无法解析的外部域名，kube-dns 会继续向集群外部的 dns 进行查询，过程如图。\nUbuntu 容器是一个普通的 Pod，在 Linux 系统中，/etc/resolv.conf 是存储 DNS 服务器的文件，普通 Pod 的/etc/resolv.conf 文件应该存储的是 kube-dns 的 Service IP。\nnameserver 10.99.0.2 # 这里存储的是kube-dns的Service IP search default.svc.cluster.local. svc.cluster.local. cluster.local. options ndots:5 查看后发现/etc/resolv.conf 文件中存储的是 kube-dns 的 Service IP，证明这一步没有问题，接下来查看一下 kube-dns 的 Pod，先进入 kube-dns 的 Pod 中检查一下/etc/resolv.conf 文件，这里存储的应该是集群外部的 DNS 服务器地址，查看后发现，这里存储的地址是 127.0.0.53，进一步查看 kube-dns Pod 的 log，发现出现了非常多的 i/o timeout 错误。\n2018/07/11 07:12:47 [ERROR] 2 [www.baidu.com](http://www.baidu.com/). A: unreachable backend: read udp 127.0.0.1:38019-\u0026gt;127.0.0.53:53: i/o timeout 2018/07/11 07:12:47 [ERROR] 2 [www.baidu.com](http://www.baidu.com/). A: unreachable backend: read udp 127.0.0.1:57567-\u0026gt;127.0.0.53:53: i/o timeout 2018/07/11 07:12:47 [ERROR] 2 [www.baidu.com](http://www.baidu.com/). A: unreachable backend: read udp 127.0.0.1:52599-\u0026gt;127.0.0.53:53: i/o timeout 2018/07/11 07:12:47 [ERROR] 2 [www.baidu.com](http://www.baidu.com/). A: unreachable backend: read udp 127.0.0.1:42539-\u0026gt;127.0.0.53:53: i/o timeout 2018/07/11 07:12:47 [ERROR] 2 [www.baidu.com](http://www.baidu.com/). A: unreachable backend: read udp 127.0.0.1:46885-\u0026gt;127.0.0.53:53: i/o timeout 2018/07/11 07:12:47 [ERROR] 2 [www.baidu.com](http://www.baidu.com/). A: unreachable backend: read udp 127.0.0.1:44189-\u0026gt;127.0.0.53:53: i/o timeout 2018/07/11 07:12:47 [ERROR] 2 [www.baidu.com](http://www.baidu.com/). A: unreachable backend: read udp 127.0.0.1:56505-\u0026gt;127.0.0.53:53: i/o timeout 2018/07/11 07:12:47 [ERROR] 2 [www.baidu.com](http://www.baidu.com/). A: unreachable backend: read udp 127.0.0.1:47320-\u0026gt;127.0.0.53:53: i/o timeout 2018/07/11 07:12:47 [ERROR] 2 [www.baidu.com](http://www.baidu.com/). A: unreachable backend: read udp 127.0.0.1:42464-\u0026gt;127.0.0.53:53: i/o timeout 2018/07/11 07:12:47 [ERROR] 2 [www.baidu.com](http://www.baidu.com/). A: unreachable backend: read udp 127.0.0.1:49203-\u0026gt;127.0.0.53:53: i/o timeout 2018/07/11 07:12:47 [ERROR] 2 [www.baidu.com](http://www.baidu.com/). A: unreachable backend: read udp 127.0.0.1:58103-\u0026gt;127.0.0.53:53: i/o timeout 2018/07/11 07:12:47 [ERROR] 2 [www.baidu.com](http://www.baidu.com/). A: unreachable backend: read udp 127.0.0.1:47148-\u0026gt;127.0.0.53:53: i/o timeout 2018/07/11 07:12:47 [ERROR] 2 [www.baidu.com](http://www.baidu.com/). A: unreachable backend: read udp 127.0.0.1:36883-\u0026gt;127.0.0.53:53: i/o timeout 2018/07/11 07:12:47 [ERROR] 2 [www.baidu.com](http://www.baidu.com/). A: unreachable backend: read udp 127.0.0.1:40968-\u0026gt;127.0.0.53:53: i/o timeout 2018/07/11 07:12:47 [ERROR] 2 [www.baidu.com](http://www.baidu.com/). A: unreachable backend: read udp 127.0.0.1:55672-\u0026gt;127.0.0.53:53: i/o timeout 现在基本上可以发现问题的原因了，kube-dns 只能解析集群内部地址，而集群外部地址应该发给外部 DNS 服务器进行解析，由于 kube-dns Pod 中的/etc/resolv.conf 文件存储的 DNS 服务器地址是 127.0.0.53，127...*都是回环地址，也就是集群外域名的 DNS 解析请求会再次发送回 kube-dns，导致形成一个循环，这也是一秒钟会出现几十次 i/o timeout 日志的原因，请求会不断的在 kube-dns 中循环，kube-dns 就像一个黑洞一样，吃掉了所有 dns 解析请求，不断累积的请求最终会导致整个集群的网络出现卡顿。\n为什么 虽然问题的原因找到了，但是为什么 kube-dns Pod 中/etc/resolv.conf 文件存储的 DNS 服务器是 127.0.0.53？\nkube-dns Pod 的 dnsPolicy 值是 Default，查看一下 Kubernetes 文档。\n\u0026ldquo;Default\u0026rdquo;: The Pod inherits the name resolution configuration from the node that the pods run on. See related discussion for more details.\n所以 kube-dns 的/etc/resolv.conf 文件是从 Node 中继承来的，查看 Node 中的/etc/resolv.conf 文件，存储的 DNS 服务器地址确实是 127.0.0.53，那么下一个问题出现了，在 Node 中发送 DNS 解析请求为什么不会产生回环的问题呢？\nNode 使用的是 Ubuntu 18.04 Server，在这个版本的系统中，DNS 解析请求并不是直接发给所在网络的 DNS 服务器的，Ubuntu 18.04 中有一个 systemd-resolved 服务，为本地应用程序提供了 DNS 解析服务，例如 nslookup localhost，解析程序从/etc/resolv.conf 文件中找到 DNS 服务器 127.0.0.53，发送解析请求，systemd-resolved 会监听在 53 端口上，捕获到解析请求后，如果是自己可以解析的，例如 localhost，会直接返回 127.0.0.1，如果不能解析，才会发送给外部服务器，而外部服务器的地址存储在/run/systemd/resolve/resolv.conf 文件中，这个文件是 systemd-resolved 服务器的配置文件，过程如图。\n怎么破 理解了问题的来龙去脉，解决问题的办法也就应运而生。在 Kubernetes 集群中，kubelet 是 worker 组建，负责管理 Pod，根据 kubernetes 文档，kubelet 默认会从 Node 的/etc/resolv.conf 文件读取 DNS 服务器地址，使得 dnsPolicy 是 Default 的 Pod 得以继承，kubelet 中的\u0026ndash;resolv-conf 参数可以指定这个配置文件的地址。在 Ubuntu 18.04 中，将这个参数设置为 systemd-resolved 的 DNS 服务器配置文件/run/systemd/resolve/resolv.conf，Pod 就会继承真正的外部 DNS 服务器。\n总结 通过对问题的探究，也理解了 Kubernetes 集群中 DNS 解析的完整过程，如图。\n* 在 Ubuntu 16.04 中也是类似的逻辑，只不过 systemd-resolved 换成了 dnsmasq，监听地址是 127.0.1.1 * 在具体实践过程中，也顺便探究了 CoreDNS 和 KubeDNS 架构和解析逻辑上的区别，不过不在此问题的讨论范围，有兴趣的朋友可以自己看一下。 * 如果 Kubernetes 集群是安装在 NAT 网络下的虚拟机上，虚拟机（也就是 Kubernetes 集群中的 Node）中/etc/resolv.conf 文件可能被修改为 NAT 的地址，也就不会出现上面这个问题。\n参考内容 https://kubernetes.io/docs/reference/command-line-tools-reference/kubelet/ https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/ https://kubernetes.io/docs/tasks/administer-cluster/dns-custom-nameservers/ https://www.freedesktop.org/software/systemd/man/systemd-resolved.service.html https://github.com/kubernetes/kubernetes/issues/49411 https://github.com/kubernetes/kubernetes/issues/45828\n","permalink":"https://simpleapples.com/zh/posts/solving-kubernetes-dns-problem/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/images/20180715_01.jpg\"\u003e\u003c/p\u003e\n\u003ch1 id=\"问题描述\"\u003e问题描述\u003c/h1\u003e\n\u003cp\u003e在搭建 Kubernetes 集群过程中，安装了 kube-dns 插件后，运行一个 ubuntu 容器，发现容器内无法解析集群外域名，一开始可以解析集群内域名，一段时间后也无法解析集群内域名。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e$ nslookup kubernetes.default\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eServer:    10.99.0.2\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eAddress 1: 10.99.0.2 kube-dns.kube-system.svc.cluster.local\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003enslookup: can\u003cspan style=\"color:#e6db74\"\u003e\u0026#39;t resolve \u0026#39;\u003c/span\u003ekubernetes.default\u003cspan style=\"color:#960050;background-color:#1e0010\"\u003e\u0026#39;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch1 id=\"排查过程\"\u003e排查过程\u003c/h1\u003e\n\u003cp\u003e在排查问题前，先思考一下 Kubernetes 集群中的 DNS 解析过程，在安装好 kube-dns 的集群中，普通 Pod 的 dnsPolicy 属性是默认值 ClusterFirst，也就是会指向集群内部的 DNS 服务器，kube-dns 负责解析集群内部的域名，kube-dns Pod 的 dnsPolicy 值是 Default，意思是从所在 Node 继承 DNS 服务器，对于无法解析的外部域名，kube-dns 会继续向集群外部的 dns 进行查询，过程如图。\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/images/20180715_02.jpg\"\u003e\u003c/p\u003e\n\u003cp\u003eUbuntu 容器是一个普通的 Pod，在 Linux 系统中，/etc/resolv.conf 是存储 DNS 服务器的文件，普通 Pod 的/etc/resolv.conf 文件应该存储的是 kube-dns 的 Service IP。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-bash\" data-lang=\"bash\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003enameserver 10.99.0.2  \u003cspan style=\"color:#75715e\"\u003e# 这里存储的是kube-dns的Service IP\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esearch default.svc.cluster.local. svc.cluster.local. cluster.local.\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eoptions ndots:5\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e查看后发现/etc/resolv.conf 文件中存储的是 kube-dns 的 Service IP，证明这一步没有问题，接下来查看一下 kube-dns 的 Pod，先进入 kube-dns 的 Pod 中检查一下/etc/resolv.conf 文件，这里存储的应该是集群外部的 DNS 服务器地址，查看后发现，这里存储的地址是 127.0.0.53，进一步查看 kube-dns Pod 的 log，发现出现了非常多的 i/o timeout 错误。\u003c/p\u003e","title":"搭建Kubernetes集群时DNS无法解析问题的处理过程"},{"content":"2015 年，Go 1.5 加入了一个试验性的 vendor 机制（到 2016 年的 Go 1.6 版变为默认开启），vendor 机制就是在项目中加入了 vendor 文件夹，用于存放依赖，这样就可以将不同项目的依赖隔离开。 Golang 一种静态强类型、编译型、并发型，并具有垃圾回收功能的编程语言。Golang 提供了方便的安装包，支持 Windows、Linux、Mac 系统。\n下载安装包 Golang 的官网是https://golang.org/，如果官网打不开，可以访问https://golang.google.cn/这个域名。在官网点击 Download Go 会进入下载页，可以看到这里提供了针对各个系统的安装包，也提供了源码，可以下载源码编译安装。\n下载运行安装包后，在 terminal 中执行 go env 命令，如果出现下面的输出说明已经安装成功。\nGOROOT 与 GOPATH 仔细看上面的输出，会发现其中有一个 GOPATH，又有一个 GOROOT，那么到底哪个才是 Golang 的运行环境呢。\n首先访问一下 GOROOT 这个路径，会发现其中包含 bin、lib 等文件夹。GOROOT 就是 Golang 的安装路径，其中包含 Golang 编译、工具、标准库等，在安装后就会存在。\n和 GOROOT 不同，GOPATH 是工作空间路径，从 go 1.8 开始，如果 GOPATH 没有被设置，会有一个默认值，在 Unix 上为$HOME/go，在 Windows 上为%USERPROFILE%/go，当调用 go build 时，它会在 GOPATH 中寻找源码。访问一下 GOPATH 这个路径，会发现其中只有 pkg、bin、src 三个文件夹，并且里面基本是空的，这是一个约定的目录结构，src 文件夹用来存放源码、pkg 存放编译后生成的文件，bin 存放编译后生成的可执行文件。项目代码需要在 GOPATH/src 路径下。\nGOPATH 路径下出了存放项目代码，还存放所有通过 go get 安装的依赖，项目代码和依赖代码是平级的，当各个项目都有很多依赖的时候，这个 GOPATH 路径下的代码量会多的吓人，并且难以拆分。\nVendor 当使用 go run 或者 go build 命令时，会首先从当前路径下的 vendor 文件夹中查找依赖，如果 vendor 不存在，才会从 GOPATH 中查找依赖。\n然而我们安装依赖通常使用 go get 或者 go install 命令，这两个命令依旧会把依赖安装到 GOPATH 路径下。\n包管理工具 dep Vendor 只是 go 官方提供的一个机制，但是包管理的问题依然没有解决，并且也没有对依赖进行版本管理。如果要实现上述的功能，还需要借助包管理工具。\nGo 官方给出了包管理工具的对比：https://github.com/golang/go/wiki/PackageManagementTools\ndep 是官方的试验性包管理工具，可以通过如下脚本安装\ncurl https://raw.githubusercontent.com/golang/dep/master/install.sh | sh\n安装完成后，进入项目路径，执行\ndep init 项目中会出现两个文件一个目录\nGopkg.toml Gopkg.lock vendor dep 包管理的流程如图\nsolving 功能，它将当前项目中的导入包和 Gopkg.toml 中的规则作为输入，不可变的依赖关系图作为传递完成后的输出，形成 Gopkg.lock。\nvendor 功能，将 Gopkg.lock 中的信息作为输入，确保项目编译时能使用在 Gopkg.lock 文件中锁定的版本。\n使用如下命令添加依赖\ndep ensure -add [github.com/gin-gonic/gin](http://github.com/gin-gonic/gin) 使用如下命令更新 Gopkg.lock\ndep ensure -update ","permalink":"https://simpleapples.com/zh/posts/build-golang-environment/","summary":"\u003cp\u003e2015 年，Go 1.5 加入了一个试验性的 vendor 机制（到 2016 年的 Go 1.6 版变为默认开启），vendor 机制就是在项目中加入了 vendor 文件夹，用于存放依赖，这样就可以将不同项目的依赖隔离开。\n\u003cimg loading=\"lazy\" src=\"/images/20180710_02.png\"\u003e\u003c/p\u003e\n\u003cp\u003eGolang 一种静态强类型、编译型、并发型，并具有垃圾回收功能的编程语言。Golang 提供了方便的安装包，支持 Windows、Linux、Mac 系统。\u003c/p\u003e\n\u003ch1 id=\"下载安装包\"\u003e下载安装包\u003c/h1\u003e\n\u003cp\u003eGolang 的官网是\u003ca href=\"https://golang.org/\"\u003ehttps://golang.org/\u003c/a\u003e，如果官网打不开，可以访问\u003ca href=\"https://golang.google.cn/\"\u003ehttps://golang.google.cn/\u003c/a\u003e这个域名。在官网点击 Download Go 会进入下载页，可以看到这里提供了针对各个系统的安装包，也提供了源码，可以下载源码编译安装。\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/images/20180710_03.png\"\u003e\u003c/p\u003e\n\u003cp\u003e下载运行安装包后，在 terminal 中执行 go env 命令，如果出现下面的输出说明已经安装成功。\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/images/20180710_04.png\"\u003e\u003c/p\u003e\n\u003ch1 id=\"goroot-与-gopath\"\u003eGOROOT 与 GOPATH\u003c/h1\u003e\n\u003cp\u003e仔细看上面的输出，会发现其中有一个 GOPATH，又有一个 GOROOT，那么到底哪个才是 Golang 的运行环境呢。\u003c/p\u003e\n\u003cp\u003e首先访问一下 GOROOT 这个路径，会发现其中包含 bin、lib 等文件夹。GOROOT 就是 Golang 的安装路径，其中包含 Golang 编译、工具、标准库等，在安装后就会存在。\u003c/p\u003e\n\u003cp\u003e和 GOROOT 不同，GOPATH 是工作空间路径，从 go 1.8 开始，如果 GOPATH 没有被设置，会有一个默认值，在 Unix 上为$HOME/go，在 Windows 上为%USERPROFILE%/go，当调用 go build 时，它会在 GOPATH 中寻找源码。访问一下 GOPATH 这个路径，会发现其中只有 pkg、bin、src 三个文件夹，并且里面基本是空的，这是一个约定的目录结构，src 文件夹用来存放源码、pkg 存放编译后生成的文件，bin 存放编译后生成的可执行文件。项目代码需要在 GOPATH/src 路径下。\u003c/p\u003e","title":"Golang环境安装和依赖管理"},{"content":"\n函数参数处理机制是 Python 中一个非常重要的知识点，随着 Python 的演进，参数处理机制的灵活性和丰富性也在不断增加，使得我们不仅可以写出简化的代码，也能处理复杂的调用。\n关键字参数 调用时指定参数的名称，且与函数声明时的参数名称一致。\n关键字参数是 Python 函数中最基础也最常见的，我们写一个记账的函数，参数是需要记录的时间和金额。\ndef add_record(date, amount): print(\u0026#39;date:\u0026#39;, date, \u0026#39;amount:\u0026#39;, amount) 这里的 amount 参数就是一个关键字参数，关键字参数支持两种调用方式：\n位置调用 关键字调用 位置调用，就是按参数的位置进行调用，例如传入两个参数，第一个是字符串 2018-07-06，第二个是整数 10，那么这两个参数会被分别赋予 date 和 amount 变量，如果顺序反过来，则这两个参数分别赋予 amount 和 date 变量。\nadd_record(\u0026#39;2018-07-06\u0026#39;, 10) # 输出date: 2018-07-06 amount: 10 add_record(10, \u0026#39;2018-07-06\u0026#39;) # 输出date: 10 amount: 2018-07-06 关键字调用，可以忽略参数顺序，直接指定参数。\nadd_record(amount=10, date=\u0026#39;2018-07-06\u0026#39;) # 虽然参数顺序反了，但是使用了关键字调用，所以依然输出date: 2018-07-06 amount: 10 仅限关键字参数 我们定义一个 Person 类，并实现它的__init__方法\nclass Person(object): def __init__(self, name, age, gender, height, weight): self._name = name self._age = age self._gender = gender self._height = height self._weight = weight 当初始化这个类的时候，我们可以使用关键字调用，也可以使用位置调用。\nPerson(\u0026#39;Wendy\u0026#39;, 24, \u0026#39;female\u0026#39;, 160, 48) Person(\u0026#39;John\u0026#39;, age=27, gender=\u0026#39;male\u0026#39;, height=170, weight=52) 对比上面两种方式，我们会发现参数多的时候通过关键字指定参数不仅更加清晰，也更具有可读性。如果我们希望函数只允许关键字调用，该如何做呢？Python 3.0 中，引入了一种新的仅限关键字参数，能实现我们的需求。\n下面将 age 以后的参数修改为只允许关键字调用，定义函数时想指定仅限关键字参数，要把它们放到前面有星号的参数后面，在 Python 中有星号的参数是可变参数的意思，如果不想支持可变参数，可以在参数中放一个星号作为分割。\nclass Person(object): # 参数中的星号作为关键字参数和仅限关键字参数的分割 def __init__(self, name, *, age=\u0026#39;22\u0026#39;, gender=\u0026#39;female\u0026#39;, height=160, weight=50): self._name = name self._age = age self._gender = gender self._height = height self._weight = weight Person(\u0026#39;Wendy\u0026#39;, 24, \u0026#39;female\u0026#39;, 160, 48) # 报错，age以后参数不允许位置调用 Person(\u0026#39;John\u0026#39;, age=27, gender=\u0026#39;male\u0026#39;, height=170, weight=52) # 正常执行 普通参数和仅限关键字参数中间由一个星号隔离开，星号以后的都是仅限关键字参数，只可以通过关键字指定，而不能通过位置指定。\n参数默认值 在函数声明时，指定参数默认值，调用时不传入参数则使用默认值，相当于可选参数。\ndef add_record(date, amount=0): print(\u0026#39;date:\u0026#39;, date, \u0026#39;amount:\u0026#39;, amount) add_record(\u0026#39;2018-07-06\u0026#39;) # 输出date: 2018-07-06 amount: 0 上面代码中没有传入 amount 参数，所以 amount 直接被置为默认值 0。有一点需要注意的是，默认参数需要设置在必选参数后面，并且默认参数既可以通过位置调用，也可以通过关键字调用。\nadd_record(\u0026#39;2018-07-06\u0026#39;, 10) # 通过位置指定参数 add_record(\u0026#39;2018-07-06\u0026#39;, amount=10) # 通过位置指定参数 add_record(amount=10, \u0026#39;2018-07-06\u0026#39;) # 报错，默认参数必须在必选参数后面 参数默认值既支持关键字参数，也支持仅限关键字参数。\n可变长参数 “可变长”顾名思义是允许在调用时传入多个参数，可变长参数适用于参数数量不确定的场景，可变参数有两种，一种是关键字可变长参数，另一种是非关键字可变长参数。\n非关键字可变长参数的写法是在参数名前加一个星号，Python 会将这些多出来的参数的值放入一个元组中，由于元组中只有参数值而没有参数名称，所以是关键字参数。\ndef print_args(*args): print(args) print_args(1, 2, 3, 4, 5) # 输出元组(1, 2, 3, 4, 5) a = [1, 2, 3, 4, 5] print_args(a) # 直接传入时，列表a会被当作一个元素，所以输出([1, 2, 3, 4, 5],) print_args(*a) # 在传参时加星号可以将可迭代参数解包，所以列表a中每一个元素都被当作一个参数传入，输出(1, 2, 3, 4, 5) 关键字可变长参数的写法是在参数名前加两个星号，Python 会将这些多出来的参数的值放入一个字典中，由于字典中只有参数值而没有参数名称，所以是非关键字参数。\ndef print_kwargs(**kw_args): print(kw_args) a = {\u0026#39;a\u0026#39;: 1, \u0026#39;b\u0026#39;: 2, \u0026#39;c\u0026#39;: 3, \u0026#39;d\u0026#39;: 4, \u0026#39;e\u0026#39;: 5} print_kwargs(**a) # 使用关键字可变参数时， {\u0026#39;a\u0026#39;: 1, \u0026#39;c\u0026#39;: 3, \u0026#39;b\u0026#39;: 2, \u0026#39;e\u0026#39;: 5, \u0026#39;d\u0026#39;: 4} 函数注解 Python 3 中为函数定义增加的另一个新功能是函数注解，所谓函数注解，就是可以在函数参数和返回值上添加任意的元数据。\ndef create_person(name: str, age: int, gender: str = \u0026#39;female\u0026#39;, height: int = 160) -\u0026gt; bool: return True 用 create_person 方法举例，可以看到在每个参数后面都跟了一个参数类型，在函数后面则是返回值类型，函数注解可以用在文档编写、类型检查中，在支持函数注解的 IDE 中，如果传入参数和返回的类型不符合函数注解中的类型，IDE 会提示错误。\n但是函数注解只是一个元数据，Python 解释器执行时候并不会去检查类型，所以下面这种情况也是合法的。\nPerson(name=123, age=\u0026#39;John\u0026#39;) # 并不会报错 总结 Python 有着非常好入门的特点，但是随着语言本身的演进，很多高级功能也在持续加入，用好这些功能可以使我们的 Python 代码拥有更高的可读性，适应更加复杂的应用场景。\n","permalink":"https://simpleapples.com/zh/posts/transition-of-parameters-of-functions-in-python/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/images/20180710_01.png\"\u003e\u003c/p\u003e\n\u003cp\u003e函数参数处理机制是 Python 中一个非常重要的知识点，随着 Python 的演进，参数处理机制的灵活性和丰富性也在不断增加，使得我们不仅可以写出简化的代码，也能处理复杂的调用。\u003c/p\u003e\n\u003ch1 id=\"关键字参数\"\u003e关键字参数\u003c/h1\u003e\n\u003cp\u003e\u003cstrong\u003e调用时指定参数的名称，且与函数声明时的参数名称一致。\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e关键字参数是 Python 函数中最基础也最常见的，我们写一个记账的函数，参数是需要记录的时间和金额。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003edef\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eadd_record\u003c/span\u003e(date, amount):\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\tprint(\u003cspan style=\"color:#e6db74\"\u003e\u0026#39;date:\u0026#39;\u003c/span\u003e, date, \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;amount:\u0026#39;\u003c/span\u003e, amount)\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e这里的 amount 参数就是一个关键字参数，关键字参数支持两种调用方式：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e位置调用\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e关键字调用\u003c/strong\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e位置调用，就是按参数的位置进行调用，例如传入两个参数，第一个是字符串 2018-07-06，第二个是整数 10，那么这两个参数会被分别赋予 date 和 amount 变量，如果顺序反过来，则这两个参数分别赋予 amount 和 date 变量。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eadd_record(\u003cspan style=\"color:#e6db74\"\u003e\u0026#39;2018-07-06\u0026#39;\u003c/span\u003e, \u003cspan style=\"color:#ae81ff\"\u003e10\u003c/span\u003e)  \u003cspan style=\"color:#75715e\"\u003e# 输出date: 2018-07-06 amount: 10\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eadd_record(\u003cspan style=\"color:#ae81ff\"\u003e10\u003c/span\u003e, \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;2018-07-06\u0026#39;\u003c/span\u003e)  \u003cspan style=\"color:#75715e\"\u003e# 输出date: 10 amount: 2018-07-06\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e关键字调用，可以忽略参数顺序，直接指定参数。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eadd_record(amount\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e10\u003c/span\u003e, date\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e\u0026#39;2018-07-06\u0026#39;\u003c/span\u003e)  \u003cspan style=\"color:#75715e\"\u003e# 虽然参数顺序反了，但是使用了关键字调用，所以依然输出date: 2018-07-06 amount: 10\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch1 id=\"仅限关键字参数\"\u003e仅限关键字参数\u003c/h1\u003e\n\u003cp\u003e我们定义一个 Person 类，并实现它的\u003ccode\u003e__init__\u003c/code\u003e方法\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ePerson\u003c/span\u003e(object):\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#66d9ef\"\u003edef\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003e__init__\u003c/span\u003e(self, name, age,  gender, height, weight):\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\tself\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003e_name \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e name\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\tself\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003e_age \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e age\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\tself\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003e_gender \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e gender\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\tself\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003e_height \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e height\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\tself\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003e_weight \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e weight\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e当初始化这个类的时候，我们可以使用关键字调用，也可以使用位置调用。\u003c/p\u003e","title":"你所不知道的Python | 函数参数的演进之路"},{"content":"\n字符串连接，就是将 2 个或以上的字符串合并成一个，看上去连接字符串是一个非常基础的小问题，但是在 Python 中，我们可以用多种方式实现字符串的连接，稍有不慎就有可能因为选择不当而给程序带来性能损失。\n方法 1：加号连接 很多语言都支持使用加号连接字符串，Python 也不例外，只需要简单的将 2 个或多个字符串相加就可以完成拼接。\na = \u0026#39;Python\u0026#39; b = \u0026#39;私房菜\u0026#39; r = a + b # 输出\u0026#39;Python私房菜\u0026#39; 方法 2：使用%操作符 在 Python 2.6 以前，%操作符是唯一一种格式化字符串的方法，它也可以用于连接字符串。\na = \u0026#39;Python\u0026#39; b = \u0026#39;私房菜\u0026#39; r = \u0026#39;%s%s\u0026#39; % (a, b) # 输出\u0026#39;Python私房菜\u0026#39; 方法 3：使用 format 方法 format 方法是 Python 2.6 中出现的一种代替%操作符的字符串格式化方法，同样可以用来连接字符串。\na = \u0026#39;Python\u0026#39; b = \u0026#39;私房菜\u0026#39; r = \u0026#39;{}{}\u0026#39;.format(a, b) 方法 4：使用 f-string Python 3.6 中引入了 Formatted String Literals（字面量格式化字符串），简称 f-string，f-string 是%操作符和 format 方法的进化版，使用 f-string 连接字符串的方法和使用%操作符、format 方法类似。\na = \u0026#39;Python\u0026#39; b = \u0026#39;私房菜\u0026#39; r = f\u0026#39;{a}{b}\u0026#39; 方法 5：使用 str.join()方法 字符串有一个内置方法 join，其参数是一个序列类型，例如数组或者元组等。\na = \u0026#39;Python\u0026#39; b = \u0026#39;私房菜\u0026#39; r = \u0026#39;\u0026#39;.join([a, b]) 对比测试 既然连接字符串有这么多方法，那么使用时到底选择哪种呢？我们从代码可读性和性能两个层面来评估一下上面 5 种方法。\n使用 timeit 模块，分别执行上述 5 种方法的示例代码 100000 次，执行时间如图。\n可以看到，%操作符、format 和 f-string 都是字符串格式化方法，性能依次递增，加号连接的性能和 f-string 不相上下。\n有一点需要注意的是，字符串类型是不可变的，所以每一次应用加号连接字符串都会生成一个新的字符串，连接多个字符串时，效率低下就是必然的了，我们将一次连接的字符串提升到 10 个和 20 个，再来进行 2 轮测试，下面是连接 20 个字符串时的耗时情况。\n和连接两个字符串时的结果出现了一些不同，首先使用加号连接的方式在字符串数量较多时（大于 10 个），性能会急剧下降，str.join()方法在连接大量字符串时性能最好。\n总结 连接少量字符串时 使用加号连接符在性能和可读性上都是明智的，如果对可读性有更高的要求，并且使用的 Python 3.6 以上版本，f-string也是一个非常好的选择，例如下面这种情况，f-string 的可读性显然比加号连接好得多。\na = f\u0026#39;姓名：{name} 年龄：{age} 性别：{gender}\u0026#39; b = \u0026#39;姓名：\u0026#39; + name + \u0026#39;年龄：\u0026#39; + age + \u0026#39;性别：\u0026#39; + gender 连接大量字符串时 join和f-string都是性能最好的选择，选择时依然取决于你使用的 Python 版本以及对可读性的要求，f-string 在连接大量字符串时可读性并不一定好。切记不要使用加号连接，尤其是在 for 循环中。\n","permalink":"https://simpleapples.com/zh/posts/the-secret-of-string-concatenation/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/images/20180628_04.jpg\"\u003e\u003c/p\u003e\n\u003cp\u003e字符串连接，就是将 2 个或以上的字符串合并成一个，看上去连接字符串是一个非常基础的小问题，但是在 Python 中，我们可以用多种方式实现字符串的连接，稍有不慎就有可能因为选择不当而给程序带来性能损失。\u003c/p\u003e\n\u003ch1 id=\"方法-1加号连接\"\u003e方法 1：加号连接\u003c/h1\u003e\n\u003cp\u003e很多语言都支持使用加号连接字符串，Python 也不例外，只需要简单的将 2 个或多个字符串相加就可以完成拼接。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ea \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;Python\u0026#39;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eb \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;私房菜\u0026#39;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003er \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e a \u003cspan style=\"color:#f92672\"\u003e+\u003c/span\u003e b  \u003cspan style=\"color:#75715e\"\u003e# 输出\u0026#39;Python私房菜\u0026#39;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch1 id=\"方法-2使用操作符\"\u003e方法 2：使用%操作符\u003c/h1\u003e\n\u003cp\u003e在 Python 2.6 以前，%操作符是唯一一种格式化字符串的方法，它也可以用于连接字符串。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ea \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;Python\u0026#39;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eb \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;私房菜\u0026#39;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003er \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e%s%s\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e\u0026#39;\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e%\u003c/span\u003e (a, b)  \u003cspan style=\"color:#75715e\"\u003e# 输出\u0026#39;Python私房菜\u0026#39;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch1 id=\"方法-3使用-format-方法\"\u003e方法 3：使用 format 方法\u003c/h1\u003e\n\u003cp\u003eformat 方法是 Python 2.6 中出现的一种代替%操作符的字符串格式化方法，同样可以用来连接字符串。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ea \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;Python\u0026#39;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eb \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;私房菜\u0026#39;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003er \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e{}{}\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e\u0026#39;\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003eformat(a, b)\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch1 id=\"方法-4使用-f-string\"\u003e方法 4：使用 f-string\u003c/h1\u003e\n\u003cp\u003ePython 3.6 中引入了 Formatted String Literals（字面量格式化字符串），简称 f-string，f-string 是%操作符和 format 方法的进化版，使用 f-string 连接字符串的方法和使用%操作符、format 方法类似。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ea \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;Python\u0026#39;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eb \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;私房菜\u0026#39;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003er \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003ef\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e\u0026#39;\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e{\u003c/span\u003ea\u003cspan style=\"color:#e6db74\"\u003e}{\u003c/span\u003eb\u003cspan style=\"color:#e6db74\"\u003e}\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e\u0026#39;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch1 id=\"方法-5使用-strjoin方法\"\u003e方法 5：使用 str.join()方法\u003c/h1\u003e\n\u003cp\u003e字符串有一个内置方法 join，其参数是一个序列类型，例如数组或者元组等。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ea \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;Python\u0026#39;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eb \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;私房菜\u0026#39;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003er \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;\u0026#39;\u003c/span\u003e\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003ejoin([a, b])\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch1 id=\"对比测试\"\u003e对比测试\u003c/h1\u003e\n\u003cp\u003e既然连接字符串有这么多方法，那么使用时到底选择哪种呢？我们从代码可读性和性能两个层面来评估一下上面 5 种方法。\u003c/p\u003e","title":"你所不知道的Python | 字符串连接的秘密"},{"content":"\n前一阵使用在最新的 Ubuntu 18.04 上安装了 KVM 来虚拟一个小的 VM 集群，将主要过程和其中遇到的一些问题记录下来。\n准备工作 首先需要检查一下 CPU 是否支持虚拟化，执行一下命令来检查/proc/cpuinfo 文件中是否又虚拟化相关的字眼，如果有的话表明 CPU 支持虚拟化技术。\negrep -c \u0026#39;(svm|vmx)\u0026#39; /proc/cpuinfo 上面命令执行结果如果返回 0，表示 CPU 不支持虚拟化技术。当然主板 BIOS 中的虚拟化技术也可能不是默认开启的，如果没有开启需要手动开启一下。\n安装 KVM 执行以下命令安装 KVM\nsudo apt update sudo apt install qemu qemu-kvm libvirt-bin bridge-utils virt-manager 将 libvirtd 添加自启动\nsudo systemctl start libvirtd.service sudo systemctl enable libvirtd.service 网络模式 KVM 安装完成后，首先需要进行网络设定，KVM 支持四种网络模式：\n桥接模式 NAT 模式 用户网络模式 直接分配设备模式 主要讲一下前两种\n桥接（Bridge）模式 在桥接模式下，宿主机和虚拟机共享同一个物理网络设备，虚拟机中的网卡和物理机中的网卡是平行关系，所以虚拟机可以直接接入外部网络，虚拟机和宿主机有平级的 IP。\n原本宿主机是通过网卡 eth0 连接外部网络的，网桥模式会新创建一个网桥 br0，接管 eth0 来连接外部网络，然后将宿主机和虚拟机的网卡 eth0 都绑定到网桥上。\n使用桥接模式需要进行以下操作：\n编辑/etc/network/interfaces，增加如下内容\nauto br0 iface br0 inet dhcp # 网桥使用DHCP模式，从DHCP服务器获取IP bridge_ports enp3s0 # 网卡名称，网桥创建前连接外部的网卡，可通过ifconfig命令查看，有IP地址的就是 bridge_stp on # 避免数据链路出现死循环 bridge_fd 0 # 将转发延迟设置为0 接下来需要重启 networking 服务（如果是通过 SSH 连接到宿主机上的，这一步会导致网络中断，如果出现问题可能导致连不上宿主机，最好在宿主机上直接操作）\nsystemctl restart networking.service 使用 ifconfig 命令查看 IP 是否从 enp3s0（网桥创建前的网卡）变到了 br0 上，如果没有变化则需要重启。如果宿主机 ip 已经成功变到网桥上，并且宿主机能正常上网而虚拟机获取不到 ip，可能是 ufw 没有允许 ip 转发导致的，编辑/etc/default/ufw允许 ip 转发。\nDEFAULT_FORWARD_POLICY=\u0026#34;ACCEPT\u0026#34; 重启 ufw 服务让设置生效\nsystemctl restart ufw.service NAT（Network Address Translation）模式 NAT 模式是 KVM 默认的网络模式，KVM 会创建一个名为 virbr0 的虚拟网桥，但是宿主机和虚拟机对于网桥来说不是平等的了，网桥会把虚拟机藏在背后，虚拟机会被分配一个内网 IP，而从外网访问不到虚拟机。\n安装 Linux 虚拟机 使用如下命令安装安装 Linux 虚拟机\nsudo virt-install -n ubuntu_3 --description \u0026#34;ubuntu_3\u0026#34; --os-type=linux --os-variant=ubuntu17.10 --ram=1024 --vcpus=1 --disk path=/var/lib/libvirt/images/ubuntu_3.img,bus=virtio,size=50 # 磁盘位置，大小50G --network bridge:br0 # 这里网络选择了桥接模式 --accelerate --graphics vnc,listen=0.0.0.0,keymap=en-us # VNC监听端口，注意要选择en-us作为key-map，否则键位布局可能会乱 --cdrom /home/zzy/Downloads/ubuntu-18.04-live-server-amd64.iso # 安装ISO路径 安装 Windows 10 虚拟机 安装 Windows 10 虚拟机会出现没有 virtio 驱动的问题，导致安装程序找不到硬盘，需要先下载 virtio 驱动。\nhttps://fedoraproject.org/wiki/Windows_Virtio_Drivers\n创建虚拟机时，将其加入到 CD-ROM 中\nsudo virt-install -n win10 --description \u0026#34;win10\u0026#34; --os-type=win --os-variant=win10 --ram=4096 --vcpus=2 --disk path=/var/lib/libvirt/images/win_10.img,bus=virtio,size=100 --network bridge:br0 --accelerate --graphics vnc,listen=0.0.0.0,keymap=en-us --cdrom =/home/zzy/Downloads/cn_windows_10_consumer_editions_version_1803_updated_march_2018_x64_dvd_12063766.iso --cdrom=/home/zzy/Downloads/virtio-win.iso 使用 VNC 客户端连接虚拟机 执行以下命令查看虚拟机的列表\nsudo virus list 通过上一步查处的虚拟机列表，查看单台机器的 VNC 端口\nsudo virsh vncdisplay ubuntu_3 # ubuntu_3是虚拟机名称 知道了 VNC 端口号，就可以使用 VNC 客户端连接到虚拟机完成安装了。\n","permalink":"https://simpleapples.com/zh/posts/install-kvm-on-ubuntu-18.04-lts/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/images/20180628_01.png\"\u003e\u003c/p\u003e\n\u003cp\u003e前一阵使用在最新的 Ubuntu 18.04 上安装了 KVM 来虚拟一个小的 VM 集群，将主要过程和其中遇到的一些问题记录下来。\u003c/p\u003e\n\u003ch1 id=\"准备工作\"\u003e准备工作\u003c/h1\u003e\n\u003cp\u003e首先需要检查一下 CPU 是否支持虚拟化，执行一下命令来检查/proc/cpuinfo 文件中是否又虚拟化相关的字眼，如果有的话表明 CPU 支持虚拟化技术。\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003eegrep -c \u0026#39;(svm|vmx)\u0026#39; /proc/cpuinfo\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e上面命令执行结果如果返回 0，表示 CPU 不支持虚拟化技术。当然主板 BIOS 中的虚拟化技术也可能不是默认开启的，如果没有开启需要手动开启一下。\u003c/p\u003e\n\u003ch1 id=\"安装-kvm\"\u003e安装 KVM\u003c/h1\u003e\n\u003cp\u003e执行以下命令安装 KVM\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003esudo apt update\nsudo apt install qemu qemu-kvm libvirt-bin  bridge-utils  virt-manager\n\u003c/code\u003e\u003c/pre\u003e\u003cp\u003e将 libvirtd 添加自启动\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode\u003esudo systemctl start libvirtd.service\nsudo systemctl enable libvirtd.service\n\u003c/code\u003e\u003c/pre\u003e\u003ch1 id=\"网络模式\"\u003e网络模式\u003c/h1\u003e\n\u003cp\u003eKVM 安装完成后，首先需要进行网络设定，KVM 支持四种网络模式：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e桥接模式\u003c/li\u003e\n\u003cli\u003eNAT 模式\u003c/li\u003e\n\u003cli\u003e用户网络模式\u003c/li\u003e\n\u003cli\u003e直接分配设备模式\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e主要讲一下前两种\u003c/p\u003e\n\u003ch1 id=\"桥接bridge模式\"\u003e桥接（Bridge）模式\u003c/h1\u003e\n\u003cp\u003e在桥接模式下，宿主机和虚拟机共享同一个物理网络设备，虚拟机中的网卡和物理机中的网卡是平行关系，所以虚拟机可以直接接入外部网络，虚拟机和宿主机有平级的 IP。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"桥接模式\" loading=\"lazy\" src=\"/images/20180628_02.jpg\"\u003e\u003c/p\u003e\n\u003cp\u003e原本宿主机是通过网卡 eth0 连接外部网络的，网桥模式会新创建一个网桥 br0，接管 eth0 来连接外部网络，然后将宿主机和虚拟机的网卡 eth0 都绑定到网桥上。\u003c/p\u003e","title":"Ubuntu 18.04 LTS安装KVM虚拟机"},{"content":"潜伏期 去年 4 月底买了一台美版 XPS 15 9560，用了几个月之后就会偶尔出现蓝屏问题，由于之前就在论坛上看到很多吐槽 XPS 品控的帖子，以为自己也中了枪，好在蓝屏也不频繁，不影响使用也就没管。\n上升期 进入今年 5 月，升级了 Win10 1803 后（基本上软件有更新我都会第一时间升级，体验最新的改进），蓝屏的次数开始多了起来，开始变得影响使用，于是开始着手查找问题。\n由于心急，并没有看转储文件，而是直接 Google 了 XPS 15 的蓝屏问题，希望能尽快找到方案。很快发现具有类似问题的人不在少数，也有很大一部分人以此说 XPS 15 品控不好，看了很多内容后，把怀疑的方向放在了驱动层面（Dell 有一个 Dell Update 软件，一有更新提示我就会更新驱动），于是从更新频率最高的显卡驱动入手，降级显卡驱动到上一个版本，然而并没有什么用。于是又降级了 Wifi 驱动，因为 Wifi 驱动也是最近更新的，并且 XPS 15 的 Killer 显卡兼容性似乎没有那么好。\n降级完驱动之后，电脑进入了短暂的回光返照阶段，用了几个小时都没有蓝屏，然而紧接着更加不幸的问题就要发生了。\n爆发期 用 QQ 接收一个大文件，大概 1G，进行到一半的时候忽然蓝屏，重启后重新接收，准备传完之后再解决蓝屏问题，然而不幸的是传了一半又蓝屏了\u0026hellip; 这时我把怀疑的方向转向了硬盘，于是降级了 Intel RST 驱动，心想降级要是没用的话，有可能是 SSD 跪了\u0026hellip; 降级后怀着忐忑的心情再次重试，竟然\u0026hellip;又蓝屏了\u0026hellip;\n这次把怀疑的方向转到了 QQ 或者 Wifi 上，毕竟是一用 QQ 接收大文件就出问题，那么不是 QQ 就是 Wifi 了，于是卸载 QQ，用迅雷下载一个大文件，果不其然，又跪了\u0026hellip;\n然而已经降级了 Wifi 驱动，之前也一直没有什么问题，难道真的是硬件出了问题？这个时候，我内心已经有点放弃 PC，转而在京东上看 MBP 的价格了\u0026hellip;\n然而 MBP 高企的售价让我冷静了下来，回来死马当活马医，继续找问题吧。\n既然自己怀疑的方向都不对，只能信仰科学了，安装了 WinDbg 和 BlueScreenView 这两款软件来查看和分析转储文件（具体过程不再赘述，可以参考文末的相关资源）。\n从 BlueScreenView 里并没有看到太多信息，现在只剩下 WinDbg 这一根救命稻草了。\n不过好在 WinDbg 非常给力，分析了几个不同时间的转储文件，都提示问题可能是由 tdx.sys 文件造成的。\ntdx 是 TDI Translation Driver 的意思，TDI 是传输层驱动接口的意思，那么可以肯定问题来自于网络，这也印证了每次使用网络传输大文件就会蓝屏的现象。紧接着，看到了另外一段话：\nWARNING: Unable to verify timestamp for QMTgpNetFlow764.sys\n这个 QMTgpNetFlow764.sys 又是什么，看前缀似乎像第三方的文件，先 Google 一下。\n真相大白 Google 了一下这个 QMTgpNetFlow764.sys，终于拨云见日。\n根据网友们的分析（具体可以查看文末的相关资源），这 5 个文件来自于腾讯的游戏平台 WeGame，于是卸载了腾讯系的游戏，并且重启删除了 C:\\Windows\\system32\\drivers 目录下以 QMT 开头的 5 个文件，没关机使用至今（大约半个月）再也没有出现过蓝屏的情况，至此可以证明，腾讯 WeGame 平台是引起蓝屏的主要原因。\n相关资源 BlueScreenView 下载地址：https://www.nirsoft.net/utils/blue_screen_view.html\nWinDbg 下载地址：https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/debugger-download-tools\nWinDbg 使用说明：https://jingyan.baidu.com/article/9f7e7ec0b0aea36f281554df.html\n知乎用户Weasley Frank的专栏文章TGP/WeGame 驱动导致 WSL 网络服务异常 对这个问题进行了简单分析\n","permalink":"https://simpleapples.com/zh/posts/wegame-causing-bsod-on-xps-15-9560/","summary":"\u003ch1 id=\"潜伏期\"\u003e潜伏期\u003c/h1\u003e\n\u003cp\u003e去年 4 月底买了一台美版 XPS 15 9560，用了几个月之后就会偶尔出现蓝屏问题，由于之前就在论坛上看到很多吐槽 XPS 品控的帖子，以为自己也中了枪，好在蓝屏也不频繁，不影响使用也就没管。\u003c/p\u003e\n\u003ch1 id=\"上升期\"\u003e上升期\u003c/h1\u003e\n\u003cp\u003e进入今年 5 月，升级了 Win10 1803 后（基本上软件有更新我都会第一时间升级，体验最新的改进），蓝屏的次数开始多了起来，开始变得影响使用，于是开始着手查找问题。\u003c/p\u003e\n\u003cp\u003e由于心急，并没有看转储文件，而是直接 Google 了 XPS 15 的蓝屏问题，希望能尽快找到方案。很快发现具有类似问题的人不在少数，也有很大一部分人以此说 XPS 15 品控不好，看了很多内容后，把怀疑的方向放在了驱动层面（Dell 有一个 Dell Update 软件，一有更新提示我就会更新驱动），于是从更新频率最高的显卡驱动入手，降级显卡驱动到上一个版本，然而并没有什么用。于是又降级了 Wifi 驱动，因为 Wifi 驱动也是最近更新的，并且 XPS 15 的 Killer 显卡兼容性似乎没有那么好。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"XPS 15的驱动列表，可以看到Wifi和显卡驱动都是最近发布的\" loading=\"lazy\" src=\"/images/20180620_01.png\"\u003e\u003c/p\u003e\n\u003cp\u003e降级完驱动之后，电脑进入了短暂的回光返照阶段，用了几个小时都没有蓝屏，然而紧接着更加不幸的问题就要发生了。\u003c/p\u003e\n\u003ch1 id=\"爆发期\"\u003e爆发期\u003c/h1\u003e\n\u003cp\u003e用 QQ 接收一个大文件，大概 1G，进行到一半的时候忽然蓝屏，重启后重新接收，准备传完之后再解决蓝屏问题，然而不幸的是传了一半又蓝屏了\u0026hellip; 这时我把怀疑的方向转向了硬盘，于是降级了 Intel RST 驱动，心想降级要是没用的话，有可能是 SSD 跪了\u0026hellip; 降级后怀着忐忑的心情再次重试，竟然\u0026hellip;又蓝屏了\u0026hellip;\u003c/p\u003e\n\u003cp\u003e这次把怀疑的方向转到了 QQ 或者 Wifi 上，毕竟是一用 QQ 接收大文件就出问题，那么不是 QQ 就是 Wifi 了，于是卸载 QQ，用迅雷下载一个大文件，果不其然，又跪了\u0026hellip;\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/images/20180620_02.png\"\u003e\u003c/p\u003e\n\u003cp\u003e然而已经降级了 Wifi 驱动，之前也一直没有什么问题，难道真的是硬件出了问题？这个时候，我内心已经有点放弃 PC，转而在京东上看 MBP 的价格了\u0026hellip;\u003c/p\u003e","title":"大毒瘤！卸载WeGame解决XPS 15蓝屏问题"},{"content":"\n字符串格式化对于每个语言来说都是一个非常基础和常用的功能，学习 Python 的同学大概都知道可以用%语法来格式化字符串。然而为了让我们更方便的使用这个常用功能，语言本身也在对字符串格式化方法进行迭代。\nPython 2.6 以前：%操作符 在 Python 2.6 出现之前，字符串迭代只有一种方法，就是%（也是取模）操作符，%操作符支持 unicode 和 str 类型的 Python 字符串，效果和 C 语言中的 sprintf()方法相似，下面是一个使用%格式化字符串的例子：\nprint(\u0026#34;I\u0026#39;m %s. I\u0026#39;m %d year old\u0026#34; % (\u0026#39;Tom\u0026#39;, 27)) %符号前面使用一个字符串作为模板，模板中有标记格式的占位符号，%后面是一个 tuple 或者 dict，用来传递需要格式化的值。占位符控制着显示的格式，下面列表展示了占位符的种类：\n占位符 内容 %d 十进制整数 %i 十进制整数 %o 八进制整数 %u 无符号整数 %x 无符号十六进制（小写） %X 无符号十六进制（大写） %e 浮点型（科学记数法，小写） %E 浮点型（科学记数法，大写） %f 浮点数 %F 浮点数 %g 浮点型，如果小数位数超过 4 位，使用科学记数法表示（小写） %G 浮点型，如果小数位数超过 4 位，使用科学记数法表示（大写） %c 单个字符 %r 字符串（调用 repr()方法生成） %s 字符串（调用 str()方法生成） 除了对数据类型的指定，%操作符还支持更复杂的格式控制：\n%[数据名称][对齐标志][宽度].[精度]类型 名称 内容 数据名称 数据名称用于字典赋值，如果%符号后面传递的数组就不需要填写了 对齐标志 有+、-、0、‘ ’四种，+表示显示正负数符号，-表示左对齐，空格表示在左侧填充一个空格，0 表示用 0 填充 宽度 表示格式化后的字符串长度，位数不足用 0 或空格补齐 精度 小数点后的位数 类型 数据类型（参考占位符种类） 例如 print(\u0026rsquo;%053f\u0026rsquo; % \u0026lsquo;12.34\u0026rsquo;)会输出 0012.340\nPython 2.6：format 函数 到 Python2.6 时，出现了一种新的字符串格式化方式，str.format()函数，相比于%操作符，format 函数使用{}和:代替了%，威力更加强大，在映射关系方面，format 函数支持位置映射、关键字映射、对象属性映射、下标映射等多种方式，不仅参数可以不按顺序，也可以不用参数或者一个参数使用多次，下面通过几个例子来说明。\n\u0026#39;{1} {0}\u0026#39;.format(\u0026#39;abc\u0026#39;, 123) # 可以不按顺序进行位置映射，输出\u0026#39;123 abc\u0026#39; \u0026#39;{} {}\u0026#39;.format(\u0026#39;abc\u0026#39;, 123) # 可以不指定参数名称，输出\u0026#39;abc 123\u0026#39; \u0026#39;{1} {0} {1}\u0026#39;.format(\u0026#39;abc\u0026#39;, 123) # 参数可以使用多次，输出\u0026#39;123 abc 123\u0026#39; \u0026#39;{name} {age}\u0026#39;.format(name=\u0026#39;tom\u0026#39;, age=27) # 可以按关键字映射，输出\u0026#39;tom 27\u0026#39; \u0026#39;{person.name} {person.age}\u0026#39;.format(person=person) # 可以按对象属性映射，输出\u0026#39;tom 27\u0026#39; \u0026#39;{0[1]} {0[0]}\u0026#39;.format(lst) # 通过下标映射 可以看到，format 函数比%操作符使用起来更加方便，不需要记住太多各种占位符代表的意义，代码可读性也更高。在复杂格式控制方面，format 函数也提供了更加强大的控制方式：\n[[填充字符]对齐方式][符号标志][#][宽度][,][.精度][类型] 例如：\n\u0026#39;{:S^+#016,.2f}\u0026#39;.format(1234) # 输出\u0026#39;SSS+1,234.00SSSS\u0026#39; 我们以上面的代码为例，通过表格说明一下 format 格式控制参数：\n类型 说明 示例说明 填充字符 不填时默认用空格填充 S 表示用 S 填充 对齐方式 ^表示居中对齐、\u0026lt;表示左对齐、\u0026gt;表示右对齐 ^表示居中对齐，左右位数不足部分会用填充字符填充 符号标志 +表示有符号（正数前显示+，负数前显示-），空格表示整数前加一个空格以和负数对齐 +表示正数前显示空格 # 表示是否在二进制、八进制、十六进制前显示 0b、0o、0x 等符号 #表示显示进制符号，由于是十进制，所以不显示 宽度 表示输出字符串的宽度 16 表示字符串宽度为 16，不足部分会补齐 , 表示使用,作为千位分隔符 ,表示使用千位分隔符 精度 表示小数点后数字位数 .2 表示精度为 2 为 类型 s 表示字符串类型，c 表示字符类型，b\\o\\d 分别表示二八十进制，x\\X 表示小写和大写十六进制，e\\E 表示小写和大写的科学记数法，f 表示浮点型 f 表示浮点型数字 可以看到 format 函数在%基础上丰富了格式控制种类，并且使输出更容易。\nPython 3.6：f-string 不少使用过 ES6 的小伙伴会知道其中的模板字符串，采用直接在字符串中内嵌变量的方式进行字符串格式化操作，Python 在 3.6 版本中也为我们带来了类似的功能：Formatted String Literals（字面量格式化字符串），简称 f-string。\nf-string 就是以 f\u0026rsquo;\u0026lsquo;开头的字符串，类似 u\u0026rsquo;\u0026lsquo;和 b\u0026rsquo;\u0026rsquo;，字符串内容和 format 方法中的格式一样，但是可以直接将变量带入到字符串中，可读性进一步增加，例如：\namount = 1234 f\u0026#39;请转账给我{amount:,.2f}元\u0026#39; # \u0026#39;请转账给我1,234.00元\u0026#39; 同时，f-string 的性能是比%和 format 都有提升的，我们做一个简单的测试，分别使用%操作符、format 和 f-string 将下面语句执行 10000 次：\n\u0026#39;My name is %s and i\u0026#39;m %s years old.\u0026#39; % (name, age) \u0026#39;My name is {} and i\u0026#39;m {} years old.\u0026#39;.format(name, age) f\u0026#39;My name is {name} and i\u0026#39;m {age} years old.\u0026#39; 用时结果如下：\n总结 如果你的项目使用的 Python 版本已经提升到 3.6，f-string 格式化是首选方式，不仅在保持功能强大的同时语义上更容易理解，而且性能也有较大的提升。如果项目还没有提升到 3.6 或者使用的 2.7，更建议使用 format，虽然性能上没有优势，但是语义上还是比%操作符更加便于理解的，功能也更加强大。\n","permalink":"https://simpleapples.com/zh/posts/things-you-dont-know-about-python/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/images/20180611_01.jpg\"\u003e\u003c/p\u003e\n\u003cp\u003e字符串格式化对于每个语言来说都是一个非常基础和常用的功能，学习 Python 的同学大概都知道可以用%语法来格式化字符串。然而为了让我们更方便的使用这个常用功能，语言本身也在对字符串格式化方法进行迭代。\u003c/p\u003e\n\u003ch1 id=\"python-26-以前操作符\"\u003ePython 2.6 以前：%操作符\u003c/h1\u003e\n\u003cp\u003e在 Python 2.6 出现之前，字符串迭代只有一种方法，就是%（也是取模）操作符，%操作符支持 unicode 和 str 类型的 Python 字符串，效果和 C 语言中的 sprintf()方法相似，下面是一个使用%格式化字符串的例子：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eprint(\u003cspan style=\"color:#e6db74\"\u003e\u0026#34;I\u0026#39;m \u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e%s\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e. I\u0026#39;m \u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e%d\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e year old\u0026#34;\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e%\u003c/span\u003e (\u003cspan style=\"color:#e6db74\"\u003e\u0026#39;Tom\u0026#39;\u003c/span\u003e, \u003cspan style=\"color:#ae81ff\"\u003e27\u003c/span\u003e))\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e%符号前面使用一个字符串作为模板，模板中有标记格式的占位符号，%后面是一个 tuple 或者 dict，用来传递需要格式化的值。占位符控制着显示的格式，下面列表展示了占位符的种类：\u003c/p\u003e\n\u003ctable\u003e\n  \u003cthead\u003e\n      \u003ctr\u003e\n          \u003cth\u003e占位符\u003c/th\u003e\n          \u003cth\u003e内容\u003c/th\u003e\n      \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e%d\u003c/td\u003e\n          \u003ctd\u003e十进制整数\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e%i\u003c/td\u003e\n          \u003ctd\u003e十进制整数\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e%o\u003c/td\u003e\n          \u003ctd\u003e八进制整数\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e%u\u003c/td\u003e\n          \u003ctd\u003e无符号整数\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e%x\u003c/td\u003e\n          \u003ctd\u003e无符号十六进制（小写）\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e%X\u003c/td\u003e\n          \u003ctd\u003e无符号十六进制（大写）\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e%e\u003c/td\u003e\n          \u003ctd\u003e浮点型（科学记数法，小写）\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e%E\u003c/td\u003e\n          \u003ctd\u003e浮点型（科学记数法，大写）\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e%f\u003c/td\u003e\n          \u003ctd\u003e浮点数\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e%F\u003c/td\u003e\n          \u003ctd\u003e浮点数\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e%g\u003c/td\u003e\n          \u003ctd\u003e浮点型，如果小数位数超过 4 位，使用科学记数法表示（小写）\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e%G\u003c/td\u003e\n          \u003ctd\u003e浮点型，如果小数位数超过 4 位，使用科学记数法表示（大写）\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e%c\u003c/td\u003e\n          \u003ctd\u003e单个字符\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e%r\u003c/td\u003e\n          \u003ctd\u003e字符串（调用 repr()方法生成）\u003c/td\u003e\n      \u003c/tr\u003e\n      \u003ctr\u003e\n          \u003ctd\u003e%s\u003c/td\u003e\n          \u003ctd\u003e字符串（调用 str()方法生成）\u003c/td\u003e\n      \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003e除了对数据类型的指定，%操作符还支持更复杂的格式控制：\u003c/p\u003e","title":"你所不知道的Python | 字符串格式化的演进之路"},{"content":"笔者整理了 Python3 中内置方法的速查表，包含：\n内置方法 列表处理方法 字典处理方法 元组处理方法 集合处理方法 序列类型的切片方法 共计 100 多个方法，点击图片——查看原图——下载。\n","permalink":"https://simpleapples.com/zh/posts/python-cheat-sheet/","summary":"\u003cp\u003e笔者整理了 Python3 中内置方法的速查表，包含：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e内置方法\u003c/li\u003e\n\u003cli\u003e列表处理方法\u003c/li\u003e\n\u003cli\u003e字典处理方法\u003c/li\u003e\n\u003cli\u003e元组处理方法\u003c/li\u003e\n\u003cli\u003e集合处理方法\u003c/li\u003e\n\u003cli\u003e序列类型的切片方法\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e共计 100 多个方法，点击图片——查看原图——下载。\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/images/20180531_01.jpg\"\u003e\u003c/p\u003e","title":"初学者必备 | Python Cheat Sheet 中文版"},{"content":"队列是一种只允许在一端进行插入操作，而在另一端进行删除操作的线性表。\n在 Python 文档中搜索队列（queue）会发现，Python 标准库中包含了四种队列，分别是 queue.Queue / asyncio.Queue / multiprocessing.Queue / collections.deque。\ncollections.deque deque 是双端队列（double-ended queue）的缩写，由于两端都能编辑，deque 既可以用来实现栈（stack）也可以用来实现队列（queue）。\ndeque 支持丰富的操作方法，主要方法如图：\n相比于 list 实现的队列，deque 实现拥有更低的时间和空间复杂度。list 实现在出队（pop）和插入（insert）时的空间复杂度大约为 O(n)，deque 在出队（pop）和入队（append）时的时间复杂度是 O(1)。\ndeque 也支持 in 操作符，可以使用如下写法：\nq = collections.deque([1, 2, 3, 4]) print(5 in q) # False print(1 in q) # True deque 还封装了顺逆时针的旋转的方法：rotate。\n# 顺时针 q = collections.deque([1, 2, 3, 4]) q.rotate(1) print(q) # [4, 1, 2, 3] q.rotate(1) print(q) # [3, 4, 1, 2] # 逆时针 q = collections.deque([1, 2, 3, 4]) q.rotate(-1) print(q) # [2, 3, 4, 1] q.rotate(-1) print(q) # [3, 4, 1, 2] 线程安全方面，通过查看 collections.deque 中的 append()、pop()等方法的源码可以知道，他们都是原子操作，所以是 GIL 保护下的线程安全方法。\nstatic PyObject * deque_append(dequeobject *deque, PyObject *item) { Py_INCREF(item); if (deque_append_internal(deque, item, deque-\u0026gt;maxlen) \u0026lt; 0) return NULL; Py_RETURN_NONE; } 通过 dis 方法可以看到，append 是原子操作（一行字节码）。\n综上，collections.deque 是一个可以方便实现队列的数据结构，具有线程安全的特性，并且有很高的性能。\nqueue.Queue \u0026amp; asyncio.Queue queue.Queue 和 asyncio.Queue 都是支持多生产者、多消费者的队列，基于 collections.deque，他们都提供了 Queue（FIFO 队列）、PriorityQueue（优先级队列）、LifoQueue（LIFO 队列），接口方面也相同。\n区别在于 queue.Queue 适用于多线程的场景，asyncio.Queue 适用于协程场景下的通信，由于 asyncio 的加成，queue.Queue 下的阻塞接口在 asyncio.Queue 中则是以返回协程对象的方式执行，具体差异如下表：\nqueue.Queue asyncio.Queue 介绍 同步队列 asyncio 队列 线程安全 是 否 超时机制 通过 timeout 参数实现 通过 asyncio.wait_for()方法实现 qsize() 预估的队列长度（获取 qsize 到下一个操作之间，queue 有可能被其它的线程修改，导致 qsize 大小发生变化） 准确的队列长度（由于是单线程，所以 queue 不会被其它线程修改） put() / set() put(item, block=True, timeout=None)，可以通过设置 block 是否为 True 来配置 put 和 set 方法是否为阻塞，并且可以为阻塞操作设置最大时长 timeout，block 为 False 时行为和 put_nowait()方法一致。 put()方法会返回一个协程对象，所以没有 block 参数和 timeout 参数，如果需要非阻塞方法，可以使用 put_nowait()，如果需要对阻塞方法应用超时，可以使用 coroutine asyncio.wait_for()。 multiprocessing.Queue multiprocessing 提供了三种队列，分别是 Queue、SimpleQueue、JoinableQueue。\nmultiprocessing.Queue 既是线程安全也是进程安全的，相当于 queue.Queue 的多进程克隆版。和 threading.Queue 很像，multiprocessing.Queue 支持 put 和 get 操作，底层结构是 multiprocessing.Pipe。\nmultiprocessing.Queue 底层是基于 Pipe 构建的，但是数据传递时并不是直接写入 Pipe，而是写入进程本地 buffer，通过一个 feeder 线程写入底层 Pipe，这样做是为了实现超时控制和非阻塞 put/get，所以 Queue 提供了 join_thread、cancel_join_thread、close 函数来控制 feeder 的行为，close 函数用来关闭 feeder 线程、join_thread 用来 join feeder 线程，cancel_join_thread 用来在控制在进程退出时，不自动 join feeder 线程，使用 cancel_join_thread 有可能导致部分数据没有被 feeder 写入 Pipe 而导致的数据丢失。\n和 threading.Queue 不同的是，multiprocessing.Queue 默认不支持 join()和 task_done 操作，这两个支持需要使用 mp.JoinableQueue 对象。\nSimpleQueue 是一个简化的队列，去掉了 Queue 中的 buffer，没有了使用 Queue 可能出现的问题，但是 put 和 get 方法都是阻塞的并且没有超时控制。\n总结 通过对比可以发现，上述四种结构都实现了队列，但是用处却各有偏重，collections.deque 在数据结构层面实现了队列，但是并没有应用场景方面的支持，可以看做是一个基础的数据结构。queue 模块实现了面向多生产线程、多消费线程的队列，asyncio.queue 模块则实现了面向多生产协程、多消费协程的队列，而 multiprocessing.queue 模块实现了面向多成产进程、多消费进程的队列。\n参考 https://docs.python.org/3/library/collections.html#collections.deque https://docs.python.org/3/library/queue.html https://docs.python.org/3/library/asyncio-queue.html https://docs.python.org/3/library/multiprocessing.html#multiprocessing.Queue https://bugs.python.org/issue15329 http://blog.ftofficer.com/2009/12/python-multiprocessing-3-about-queue/ http://cyrusin.github.io/2016/04/27/python-gil-implementaion/\n","permalink":"https://simpleapples.com/zh/posts/four-types-of-queue-in-python/","summary":"\u003cp\u003e队列是一种只允许在一端进行插入操作，而在另一端进行删除操作的线性表。\u003c/p\u003e\n\u003cp\u003e在 Python 文档中搜索队列（queue）会发现，Python 标准库中包含了四种队列，分别是 queue.Queue / asyncio.Queue / multiprocessing.Queue / collections.deque。\u003c/p\u003e\n\u003ch1 id=\"collectionsdeque\"\u003ecollections.deque\u003c/h1\u003e\n\u003cp\u003edeque 是双端队列（double-ended queue）的缩写，由于两端都能编辑，deque 既可以用来实现栈（stack）也可以用来实现队列（queue）。\u003c/p\u003e\n\u003cp\u003edeque 支持丰富的操作方法，主要方法如图：\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/images/20180522_01.jpg\"\u003e\u003c/p\u003e\n\u003cp\u003e相比于 list 实现的队列，deque 实现拥有更低的时间和空间复杂度。list 实现在出队（pop）和插入（insert）时的空间复杂度大约为 O(n)，deque 在出队（pop）和入队（append）时的时间复杂度是 O(1)。\u003c/p\u003e\n\u003cp\u003edeque 也支持 in 操作符，可以使用如下写法：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eq \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e collections\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003edeque([\u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e, \u003cspan style=\"color:#ae81ff\"\u003e2\u003c/span\u003e, \u003cspan style=\"color:#ae81ff\"\u003e3\u003c/span\u003e, \u003cspan style=\"color:#ae81ff\"\u003e4\u003c/span\u003e])\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eprint(\u003cspan style=\"color:#ae81ff\"\u003e5\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003ein\u003c/span\u003e q)  \u003cspan style=\"color:#75715e\"\u003e# False\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eprint(\u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003ein\u003c/span\u003e q)  \u003cspan style=\"color:#75715e\"\u003e# True\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003edeque 还封装了顺逆时针的旋转的方法：rotate。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# 顺时针\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eq \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e collections\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003edeque([\u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e, \u003cspan style=\"color:#ae81ff\"\u003e2\u003c/span\u003e, \u003cspan style=\"color:#ae81ff\"\u003e3\u003c/span\u003e, \u003cspan style=\"color:#ae81ff\"\u003e4\u003c/span\u003e])\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eq\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003erotate(\u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eprint(q)  \u003cspan style=\"color:#75715e\"\u003e# [4, 1, 2, 3]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eq\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003erotate(\u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eprint(q)  \u003cspan style=\"color:#75715e\"\u003e# [3, 4, 1, 2]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# 逆时针\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eq \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e collections\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003edeque([\u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e, \u003cspan style=\"color:#ae81ff\"\u003e2\u003c/span\u003e, \u003cspan style=\"color:#ae81ff\"\u003e3\u003c/span\u003e, \u003cspan style=\"color:#ae81ff\"\u003e4\u003c/span\u003e])\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eq\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003erotate(\u003cspan style=\"color:#f92672\"\u003e-\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eprint(q)  \u003cspan style=\"color:#75715e\"\u003e# [2, 3, 4, 1]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eq\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003erotate(\u003cspan style=\"color:#f92672\"\u003e-\u003c/span\u003e\u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eprint(q)  \u003cspan style=\"color:#75715e\"\u003e# [3, 4, 1, 2]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e线程安全方面，通过查看 collections.deque 中的 append()、pop()等方法的源码可以知道，他们都是原子操作，所以是 GIL 保护下的线程安全方法。\u003c/p\u003e","title":"简析Python中的四种队列"},{"content":"\n什么是断言 断言是作为一种调试工具被发明出来的，用来检查那些“代码写对了就肯定成立”的条件。例如我们要断言一个变量 a 必须要大于 2，就可以这样写：\nassert a \u0026gt; 2 当条件不满足时，就会抛出 AssertionError 异常，等同于如下代码：\nif not assert_condition: raise AssertionError 由于断言是一个 debug 工具，Python 的实现也符合这个设计哲学，在 Python 中 assert 语句的执行是依赖于__debug__变量的，当__debug__为 true 时，assert 语句才会被执行。\nif __debug__ and not assert_condition: raise AssertionError 默认情况下，当我们执行一个 Python 文件时，__debug__是会被设置为 True 的，只有加参数-O 或-OO 时，__debug__才会被设置为 False。\n新建一个 assert.py 文件，写下如下代码：\nprint(__debug__) assert 2 \u0026gt; 5 当使用 python assert.py 运行时，__debug__会输出 True，assert 2 \u0026gt; 5 语句会抛出 AssertionError 异常。\n当使用 python -O assert.py 运行时，__debug__会输出 False，assert 2 \u0026gt; 5 语句由于没有执行不会报任何异常。\n断言 or 异常 我们思考这几个问题：断言应该用在哪些情境下？异常和断言的区别是什么？\n用一句话来概括断言的使用场景和与异常的区别：\n检查先验条件使用断言，检查后验条件使用异常\n我们定义一个 read_file 函数：\ndef read_file(file_path): pass read_file 函数要求在开始执行的时候满足一定条件：file_path 必须是 str 类型，这个条件就是先验条件，如果不满足，就不能调用这个函数，如果真的出现了不满足条件的情况，证明代码中出现了 bug，这时候我们就可以使用 assert 语句来对 file_path 的类型进行推断，提醒程序员修改代码，这样的推断在生产环境中是不需要的，也可以使用 if + raise 语句来实现 assert，但是要繁琐很多。\ndef read_file(file_path): assert is_instance(file_path, str) read_file 函数在被调用执行后，依然需要满足一定条件，比如 file_path 所指定的文件需要是存在的，并且当前用户有权限读取该文件，这些条件称为后验条件，对于后验条件的检查，我们需要使用异常来处理。\ndef read_file(file_path): assert is_instance(file_path, str) if not check_exist(file_path): raise NotFoundError() if not has_privilege(file_path): raise PermissionError() 文件不存在和没有权限，这两种情况并不属于代码 bug，是代码逻辑的一部分，上层代码捕获异常后可能会执行其他逻辑，因此我们不能接受这部分代码在生产环境中被忽略。并且，相比于 assert 语句只能抛出 AssertionError，使用异常可以抛出更细致的错误，方便上层代码针对不同错误执行不同的逻辑。\n","permalink":"https://simpleapples.com/zh/posts/right-way-to-use-assert-in-python/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/images/20180507_01.jpg\"\u003e\u003c/p\u003e\n\u003ch1 id=\"什么是断言\"\u003e什么是断言\u003c/h1\u003e\n\u003cp\u003e断言是作为一种调试工具被发明出来的，用来检查那些“代码写对了就肯定成立”的条件。例如我们要断言一个变量 a 必须要大于 2，就可以这样写：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eassert\u003c/span\u003e a \u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e2\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e当条件不满足时，就会抛出 AssertionError 异常，等同于如下代码：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003enot\u003c/span\u003e assert_condition:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eraise\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eAssertionError\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e由于断言是一个 debug 工具，Python 的实现也符合这个设计哲学，在 Python 中 assert 语句的执行是依赖于\u003ccode\u003e__debug__\u003c/code\u003e变量的，当\u003ccode\u003e__debug__\u003c/code\u003e为 true 时，assert 语句才会被执行。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e __debug__ \u003cspan style=\"color:#f92672\"\u003eand\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003enot\u003c/span\u003e assert_condition:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003eraise\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eAssertionError\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e默认情况下，当我们执行一个 Python 文件时，\u003ccode\u003e__debug__\u003c/code\u003e是会被设置为 True 的，只有加参数-O 或-OO 时，\u003ccode\u003e__debug__\u003c/code\u003e才会被设置为 False。\u003c/p\u003e\n\u003cp\u003e新建一个 assert.py 文件，写下如下代码：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eprint(__debug__)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eassert\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e2\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e5\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e当使用 python assert.py 运行时，\u003ccode\u003e__debug__\u003c/code\u003e会输出 True，assert 2 \u0026gt; 5 语句会抛出 AssertionError 异常。\u003c/p\u003e\n\u003cp\u003e当使用 python -O assert.py 运行时，\u003ccode\u003e__debug__\u003c/code\u003e会输出 False，assert 2 \u0026gt; 5 语句由于没有执行不会报任何异常。\u003c/p\u003e\n\u003ch1 id=\"断言-or-异常\"\u003e断言 or 异常\u003c/h1\u003e\n\u003cp\u003e我们思考这几个问题：断言应该用在哪些情境下？异常和断言的区别是什么？\u003c/p\u003e\n\u003cp\u003e用一句话来概括断言的使用场景和与异常的区别：\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e检查先验条件使用断言，检查后验条件使用异常\u003c/p\u003e\u003c/blockquote\u003e\n\u003cp\u003e我们定义一个 read_file 函数：\u003c/p\u003e","title":"你真的会正确使用断言吗？"},{"content":" Don\u0026rsquo;t repeat yourself\n在使用Flask-WTF的时候，常会用下面这样的代码来验证表单数据的合法性：\nfrom flask import Flask app = Flask(__name__) @app.route(\u0026#39;/\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def index(): form = TestForm() # 判断是否合法 if not form.validate_on_submit(): return \u0026#39;err\u0026#39;, 400 # 主要逻辑 对于有很多提交接口的项目来说，需要在每个路由下写相同的的逻辑，造成了大量的代码重复。在Flask-Login中，要把一个路由设置为登录后才能访问，只需要在路由上加一个@login_required装饰器，不需要额外的代码。能不能像Flask-Login一样，用装饰器来封装对表单的验证逻辑呢？\n实现表单验证装饰器 由于不同路由使用的表单类不一样，所以需要为装饰器传入一个表单类参数，并且在路由函数中需要用到表单中的值，所以还需要将验证通过的表单传给路由函数。\n上代码：\ndef validate_form(self, form_cls): def decorator(fn): @wraps(fn) def wrapper(*args, **kwargs): if not form.validate_on_submit(): return \u0026#39;error\u0026#39;, 400 return fn(form, *args, **kwargs) return wrapper return decorator 使用方式如下：\n@validate_form(TestForm) # 需要传入要验证的表单类 @app.route(\u0026#39;/\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def index(form): # 执行到这里说明表单验证通过 经过在项目中的应用，发现装饰器还是有一些缺陷：\n无法自定义处理非法表单的逻辑 不支持get方式提交的表单（查看validate_on_submit()源码可知其只支持对post和put方式提交的表单进行验证） 丰富一下 要自定义处理非法表单的逻辑，需要增加一个可以传入自定义逻辑的接口。表单非法时接口的返回往往是一致的，所以我们为所有应用装饰器的路由传入一个统一的处理逻辑。将装饰器封装在一个类中，在类中添加一个配置处理逻辑的方法。\nfrom functools import wraps from flask import request class FormValidator(object): def __init__(self, error_handler=None): self._error_handler = error_handler def validate_form(self, form_cls): def decorator(fn): @wraps(fn) def wrapper(*args, **kwargs): if not form.validate_on_submit() and self._error_handler: return self._error_handler(form.errors) return fn(form, *args, **kwargs) return wrapper return decorator def error_handler(self, fn): self._error_handler = fn return fn error_handler也是一个装饰器，被它修饰的方法就是处理非法表单的方法。\n@form_validator.error_handler def error_handler(errors): return jsonify({\u0026#39;errors\u0026#39;: errors}), 400 接下来支持get方法，在flask中，我们可以通过request.args来获取到get方法提交的参数。思路是用获取到的参数生成一个表单类的实例，然后就可以通过调用表单类的validate()方法来判断是否合法了。修改validate_form装饰器：\ndef validate_form(self, form_cls): def decorator(fn): @wraps(fn) def wrapper(*args, **kwargs): if request.method == \u0026#39;GET\u0026#39;: form = form_cls(formdata=request.args) elif request.method in (\u0026#39;POST\u0026#39;, \u0026#39;PUT\u0026#39;): form = form_cls() else: return fn(*args, **kwargs) if not form.validate() and self._error_handler: return self._error_handler(form.errors) return fn(form, *args, **kwargs) return wrapper return decorator 大功告成！使用上面的装饰器，就可以免除在路由函数中重复写表单验证逻辑，并且同时支持put、post和get方法提交的表单。\n开箱即用 笔者已经把上面的代码封装成了一个库发布到了PyPI，想直接用的朋友可以使用pip install flask-wtf-decorators安装，项目源码也已经发布到Github。\n查看PyPI\n查看Github\n","permalink":"https://simpleapples.com/zh/posts/using-decorators-to-validate-form/","summary":"\u003cblockquote\u003e\n\u003cp\u003eDon\u0026rsquo;t repeat yourself\u003c/p\u003e\u003c/blockquote\u003e\n\u003cp\u003e在使用Flask-WTF的时候，常会用下面这样的代码来验证表单数据的合法性：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003efrom\u003c/span\u003e flask \u003cspan style=\"color:#f92672\"\u003eimport\u003c/span\u003e Flask\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eapp \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e Flask(__name__)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#a6e22e\"\u003e@app.route\u003c/span\u003e(\u003cspan style=\"color:#e6db74\"\u003e\u0026#39;/\u0026#39;\u003c/span\u003e, methods\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e[\u003cspan style=\"color:#e6db74\"\u003e\u0026#39;GET\u0026#39;\u003c/span\u003e, \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;POST\u0026#39;\u003c/span\u003e])\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003edef\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eindex\u003c/span\u003e():\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\tform \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e TestForm()\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#75715e\"\u003e# 判断是否合法\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003enot\u003c/span\u003e form\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003evalidate_on_submit():\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;err\u0026#39;\u003c/span\u003e, \u003cspan style=\"color:#ae81ff\"\u003e400\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#75715e\"\u003e# 主要逻辑\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e对于有很多提交接口的项目来说，需要在每个路由下写相同的的逻辑，造成了大量的代码重复。在Flask-Login中，要把一个路由设置为登录后才能访问，只需要在路由上加一个@login_required装饰器，不需要额外的代码。能不能像Flask-Login一样，用装饰器来封装对表单的验证逻辑呢？\u003c/p\u003e\n\u003ch1 id=\"实现表单验证装饰器\"\u003e实现表单验证装饰器\u003c/h1\u003e\n\u003cp\u003e由于不同路由使用的表单类不一样，所以需要为装饰器传入一个表单类参数，并且在路由函数中需要用到表单中的值，所以还需要将验证通过的表单传给路由函数。\u003c/p\u003e\n\u003cp\u003e上代码：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003edef\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003evalidate_form\u003c/span\u003e(self, form_cls):\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003edef\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003edecorator\u003c/span\u003e(fn):\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#a6e22e\"\u003e@wraps\u003c/span\u003e(fn)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003edef\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ewrapper\u003c/span\u003e(\u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003eargs, \u003cspan style=\"color:#f92672\"\u003e**\u003c/span\u003ekwargs):\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003enot\u003c/span\u003e form\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003evalidate_on_submit():\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;error\u0026#39;\u003c/span\u003e, \u003cspan style=\"color:#ae81ff\"\u003e400\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e fn(form, \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003eargs, \u003cspan style=\"color:#f92672\"\u003e**\u003c/span\u003ekwargs)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e wrapper\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e decorator\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e使用方式如下：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#a6e22e\"\u003e@validate_form\u003c/span\u003e(TestForm)  \u003cspan style=\"color:#75715e\"\u003e# 需要传入要验证的表单类\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#a6e22e\"\u003e@app.route\u003c/span\u003e(\u003cspan style=\"color:#e6db74\"\u003e\u0026#39;/\u0026#39;\u003c/span\u003e, methods\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e[\u003cspan style=\"color:#e6db74\"\u003e\u0026#39;GET\u0026#39;\u003c/span\u003e, \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;POST\u0026#39;\u003c/span\u003e])\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003edef\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eindex\u003c/span\u003e(form):\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#75715e\"\u003e# 执行到这里说明表单验证通过\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e经过在项目中的应用，发现装饰器还是有一些缺陷：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e无法自定义处理非法表单的逻辑\u003c/li\u003e\n\u003cli\u003e不支持get方式提交的表单（查看validate_on_submit()源码可知其只支持对post和put方式提交的表单进行验证）\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch1 id=\"丰富一下\"\u003e丰富一下\u003c/h1\u003e\n\u003cp\u003e要自定义处理非法表单的逻辑，需要增加一个可以传入自定义逻辑的接口。表单非法时接口的返回往往是一致的，所以我们为所有应用装饰器的路由传入一个统一的处理逻辑。将装饰器封装在一个类中，在类中添加一个配置处理逻辑的方法。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003efrom\u003c/span\u003e functools \u003cspan style=\"color:#f92672\"\u003eimport\u003c/span\u003e wraps\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003efrom\u003c/span\u003e flask \u003cspan style=\"color:#f92672\"\u003eimport\u003c/span\u003e request\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eFormValidator\u003c/span\u003e(object):\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003edef\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003e__init__\u003c/span\u003e(self, error_handler\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eNone\u003c/span\u003e):\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        self\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003e_error_handler \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e error_handler\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003edef\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003evalidate_form\u003c/span\u003e(self, form_cls):\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003edef\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003edecorator\u003c/span\u003e(fn):\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#a6e22e\"\u003e@wraps\u003c/span\u003e(fn)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#66d9ef\"\u003edef\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003ewrapper\u003c/span\u003e(\u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003eargs, \u003cspan style=\"color:#f92672\"\u003e**\u003c/span\u003ekwargs):\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                \u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003enot\u003c/span\u003e form\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003evalidate_on_submit() \u003cspan style=\"color:#f92672\"\u003eand\u003c/span\u003e self\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003e_error_handler:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                    \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e self\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003e_error_handler(form\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003eerrors)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e                \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e fn(form, \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003eargs, \u003cspan style=\"color:#f92672\"\u003e**\u003c/span\u003ekwargs)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e wrapper\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e decorator\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003edef\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eerror_handler\u003c/span\u003e(self, fn):\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        self\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003e_error_handler \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e fn\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e fn\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eerror_handler也是一个装饰器，被它修饰的方法就是处理非法表单的方法。\u003c/p\u003e","title":"用装饰器封装Flask-WTF表单验证逻辑"},{"content":"\n面试的时候，有没有被问到 Python 传参是传引用还是传值这种问题？有没有听到过 Python 传参既不是传值也不是传引用这种说法？一个小小的参数默认值也可能让代码出现难以查找的 bug？\n如果你也遇到过上面的问题，不妨我们来探究下 Python 函数传递的种种。\n万物皆对象 Python 中有一个非常重要的概念——万物皆对象，无论是一个数字、字符串，还是数组、字典，在 Python 中都会以一个对象的形式存在。\na = 123 对于上面这行代码，在 Python 看来就是创建一个 PyObject 对象，值为 123，然后定义一个指针 a，a 指向这个 PyObject 对象。\n可变对象和不可变对象 Python 中的对象分为两种类型，可变对象和不可变对象，不可变对象指 tuple、str、int 等类型的对象，可变对象指的是 dict、list、自定义对象等类型的对象，我们用一段代码说明他们的区别。\na = [1, 2, 3] print(id(a)) # 2587116690248 a += [4] print(id(a)) # 2587116690248 b = 1 print(id(b)) # 2006430784 b += 1 print(id(b)) # 2006430816 上面代码中我们分别定义了一个可变对象和一个不可变对象，并且对他们进行修改，打印修改前后的对象标识可以发现，对可变对象进行修改，变量对其引用不会发生变化，对不可变对象进行修改，变量引用发生了变化。\n上图是一个可变对象，当修改对象时，例如删除数组中的一个元素，实际上把其中一个元素从对象中移除，对象本身的标识是不发生变化的。\n改变一个不可变对象时，例如给一个 int 型加 2，语法上看上去是直接修改了 i 这个对象，但是如前面所说，i 只是一个指向对象 73 的一个变量，Python 会将这个变量指向的对象加 2 后，生成一个新的对象，然后再让 i 指向这个新的对象。\n参数传递时的表现 了解了对象的原理后，我们就可以来尝试理解一下参数传递时他们的不同表现了。\na = [1, 2, 3] print(id(a)) # 1437494204232 def mutable(a): print(id(a)) # 1437494204232 a += [4] print(id(a)) # 1437494204232 mutable(a) b = 1 print(id(b)) # 2006430784 def immutable(b): print(id(b)) # 2006430784 b += 1 print(id(b)) # 2006430816 immutable(b) 通过上面的代码可以看出，修改传进的可变参数时，会对外部对象产生影响，修改不可变参数时则不会影响。\n概括地说，Python 参数传递时，既不是传对象也不是传引用，之所以会有上述的区别，跟 Python 的对象机制有关，参数传递只是给对象绑定了一个新的变量（实际上是传递 C 中的指针）。\n参数传递时的坑 理解了参数传递的逻辑，我们需要注意一下这种逻辑可能引发的问题。\ndef test(b=[]): b += [1] print(b) test() # [1] test() # [1, 1] test() # [1, 1, 1] 上面的代码的输出，按照可变对象传参的逻辑，应该每次调用都输出[1]才对，而实际输出看上去好像默认参数好像只生效了一次。原因在于 Python 的函数也是对象（万物皆对象），这个对象只初始化一次，加上参数又是不可变对象，所以每次调用实际上都修改的是一个对象。\n解决这个问题，推荐再参数传递可变对象时，默认值设置为 None，在函数内部对 None 进行判断后再赋予默认值。\ndef test(b=None): b = b or [] b += [1] print(b) test() # [1] test() # [1] test() # [1] 再看一段代码。\ni = 1 def test(a=i): print(a) i = 2 test() # 1 由于参数默认值是在函数定义时而不是函数执行时确定的，所以这段代码 test 方法的参数默认值时 1 而不是 2。\n","permalink":"https://simpleapples.com/zh/posts/python-parameter-passing/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/images/20180422_01.png\"\u003e\u003c/p\u003e\n\u003cp\u003e面试的时候，有没有被问到 Python 传参是传引用还是传值这种问题？有没有听到过 Python 传参既不是传值也不是传引用这种说法？一个小小的参数默认值也可能让代码出现难以查找的 bug？\u003c/p\u003e\n\u003cp\u003e如果你也遇到过上面的问题，不妨我们来探究下 Python 函数传递的种种。\u003c/p\u003e\n\u003ch1 id=\"万物皆对象\"\u003e万物皆对象\u003c/h1\u003e\n\u003cp\u003ePython 中有一个非常重要的概念——万物皆对象，无论是一个数字、字符串，还是数组、字典，在 Python 中都会以一个对象的形式存在。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ea \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e123\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e对于上面这行代码，在 Python 看来就是创建一个 PyObject 对象，值为 123，然后定义一个指针 a，a 指向这个 PyObject 对象。\u003c/p\u003e\n\u003ch1 id=\"可变对象和不可变对象\"\u003e可变对象和不可变对象\u003c/h1\u003e\n\u003cp\u003ePython 中的对象分为两种类型，可变对象和不可变对象，不可变对象指 tuple、str、int 等类型的对象，可变对象指的是 dict、list、自定义对象等类型的对象，我们用一段代码说明他们的区别。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ea \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e [\u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e, \u003cspan style=\"color:#ae81ff\"\u003e2\u003c/span\u003e, \u003cspan style=\"color:#ae81ff\"\u003e3\u003c/span\u003e]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eprint(id(a))  \u003cspan style=\"color:#75715e\"\u003e# 2587116690248\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ea \u003cspan style=\"color:#f92672\"\u003e+=\u003c/span\u003e [\u003cspan style=\"color:#ae81ff\"\u003e4\u003c/span\u003e]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eprint(id(a)) \u003cspan style=\"color:#75715e\"\u003e# 2587116690248\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eb \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eprint(id(b)) \u003cspan style=\"color:#75715e\"\u003e# 2006430784\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eb \u003cspan style=\"color:#f92672\"\u003e+=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eprint(id(b)) \u003cspan style=\"color:#75715e\"\u003e# 2006430816\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e上面代码中我们分别定义了一个可变对象和一个不可变对象，并且对他们进行修改，打印修改前后的对象标识可以发现，对可变对象进行修改，变量对其引用不会发生变化，对不可变对象进行修改，变量引用发生了变化。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"可变对象的引用\" loading=\"lazy\" src=\"/images/20180422_02.png\"\u003e\u003c/p\u003e\n\u003cp\u003e上图是一个可变对象，当修改对象时，例如删除数组中的一个元素，实际上把其中一个元素从对象中移除，对象本身的标识是不发生变化的。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"不可变对象的引用\" loading=\"lazy\" src=\"/images/20180422_03.png\"\u003e\u003c/p\u003e\n\u003cp\u003e改变一个不可变对象时，例如给一个 int 型加 2，语法上看上去是直接修改了 i 这个对象，但是如前面所说，i 只是一个指向对象 73 的一个变量，Python 会将这个变量指向的对象加 2 后，生成一个新的对象，然后再让 i 指向这个新的对象。\u003c/p\u003e\n\u003ch1 id=\"参数传递时的表现\"\u003e参数传递时的表现\u003c/h1\u003e\n\u003cp\u003e了解了对象的原理后，我们就可以来尝试理解一下参数传递时他们的不同表现了。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ea \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e [\u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e, \u003cspan style=\"color:#ae81ff\"\u003e2\u003c/span\u003e, \u003cspan style=\"color:#ae81ff\"\u003e3\u003c/span\u003e]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eprint(id(a))  \u003cspan style=\"color:#75715e\"\u003e# 1437494204232\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003edef\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003emutable\u003c/span\u003e(a):\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\tprint(id(a))  \u003cspan style=\"color:#75715e\"\u003e# 1437494204232\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\ta \u003cspan style=\"color:#f92672\"\u003e+=\u003c/span\u003e [\u003cspan style=\"color:#ae81ff\"\u003e4\u003c/span\u003e]\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\tprint(id(a))  \u003cspan style=\"color:#75715e\"\u003e# 1437494204232\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003emutable(a)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eb \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eprint(id(b))  \u003cspan style=\"color:#75715e\"\u003e# 2006430784\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003edef\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eimmutable\u003c/span\u003e(b):\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\tprint(id(b))  \u003cspan style=\"color:#75715e\"\u003e# 2006430784\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\tb \u003cspan style=\"color:#f92672\"\u003e+=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\tprint(id(b))  \u003cspan style=\"color:#75715e\"\u003e# 2006430816\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eimmutable(b)\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e通过上面的代码可以看出，修改传进的可变参数时，会对外部对象产生影响，修改不可变参数时则不会影响。\u003c/p\u003e","title":"Python参数传递，既不是传值也不是传引用"},{"content":"asyncio 于 Python3.4 引入标准库，增加了对异步 I/O 的支持，asyncio 基于事件循环，可以轻松实现异步 I/O 操作。接下来，我们用基于 asyncio 的库实现一个高性能爬虫。\n准备工作 Earth View from Google Earth是一款 Chrome 插件，会在打开新标签页时自动加载一张来自 Google Earth 的背景图片。\n使用 Chrome 开发者工具观察插件的网络请求，我们发现插件会请求一个地址如https://www.gstatic.com/prettyearth/assets/data/v2/1234.json的 JSON 文件，文件中包含了经过 Base64 的图片内容，观察发现，图片的 ID 范围大致在 1000-8000 之间，我们的爬虫就要来爬取这些精美的背景图片。\n实现主要逻辑 由于爬取目标是 JSON 文件，爬虫的主要逻辑就变成了爬取 JSON\u0026ndash;\u0026gt;提取图片\u0026ndash;\u0026gt;保存图片。\nrequests 是一个常用的 http 请求库，但是由于 requests 的请求都是同步的，我们使用aiohttp这个异步 http 请求库来代替。\nasync def fetch_image_by_id(item_id): url = f\u0026#39;https://www.gstatic.com/prettyearth/assets/data/v2/{item_id}.json\u0026#39; # 由于URL是https的，所以选择不验证SSL async with aiohttp.ClientSession(connector=aiohttp.TCPConnector(verify_ssl=False)) as session: async with session.get(url) as response: # 获取后需要将JSON字符串转为对象 try: json_obj = json.loads(await response.text()) except json.decoder.JSONDecodeError as e: print(f\u0026#39;Download failed - {item_id}.jpg\u0026#39;) return # 获取JSON中的图片内容字段，经过Base64解码成二进制内容 image_str = json_obj[\u0026#39;dataUri\u0026#39;].replace(\u0026#39;data:image/jpeg;base64,\u0026#39;, \u0026#39;\u0026#39;) image_data = base64.b64decode(image_str) save_folder = dir_path = os.path.dirname( os.path.realpath(__file__)) + \u0026#39;/google_earth/\u0026#39; with open(f\u0026#39;{save_folder}{item_id}.jpg\u0026#39;, \u0026#39;wb\u0026#39;) as f: f.write(image_data) print(f\u0026#39;Download complete - {item_id}.jpg\u0026#39;) aiohttp 基于 asyncio，所以在调用时需要使用 async/await 语法糖，可以看到，由于 aiohttp 中提供了一个 ClientSession 上下文，代码中使用了 async with 的语法糖。\n加入并行逻辑 上面的代码是抓取单张图片的逻辑，批量抓取图片，需要再嵌套一层方法：\nasync def fetch_all_images(): # 使用Semaphore限制最大并发数 sem = asyncio.Semaphore(10) ids = [id for id in range(1000, 8000)] for current_id in ids: async with sem: await fetch_image_by_id(current_id) 接下来，将这个方法加入到 asyncio 的事件循环中。\nevent_loop = asyncio.get_event_loop() future = asyncio.ensure_future(fetch_all_images()) results = event_loop.run_until_complete(future) 使用 uvloop 加速 uvloop 基于 libuv，libuv 是一个使用 C 语言实现的高性能异步 I/O 库，uvloop 用来代替 asyncio 默认事件循环，可以进一步加快异步 I/O 操作的速度。\nuvloop 的使用非常简单，只要在获取事件循环前，调用如下方法，将 asyncio 的事件循环策略设置为 uvloop 的事件循环策略。\nasyncio.set_event_loop_policy(uvloop.EventLoopPolicy()) 使用上面的代码，我们可以快速将大约 1500 张的图片爬取下来。\n性能对比 为了验证 aiohttp 和 uvloop 的性能，笔者使用 requests+concurrent 库实现了一个多进程版的爬虫，分别爬取 20 个 id，消耗的时间如图。\n可以看到，耗时相差了大概 7 倍，aiohttp+uvloop 的组合在爬虫这种 I/O 密集型的场景下，可以说具有压倒性优势。相信在不远的将来，基于 asyncio 的库会将无数爬虫工程师从加班中拯救出来。\n","permalink":"https://simpleapples.com/zh/posts/a-crawler-based-on-aiohttp-and-uvloop/","summary":"\u003cp\u003easyncio 于 Python3.4 引入标准库，增加了对异步 I/O 的支持，asyncio 基于事件循环，可以轻松实现异步 I/O 操作。接下来，我们用基于 asyncio 的库实现一个高性能爬虫。\u003c/p\u003e\n\u003ch1 id=\"准备工作\"\u003e准备工作\u003c/h1\u003e\n\u003cp\u003e\u003ca href=\"https://chrome.google.com/webstore/detail/earth-view-from-google-ea/bhloflhklmhfpedakmangadcdofhnnoh\"\u003eEarth View from Google Earth\u003c/a\u003e是一款 Chrome 插件，会在打开新标签页时自动加载一张来自 Google Earth 的背景图片。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"Earth View from Google Earth\" loading=\"lazy\" src=\"/images/20180410_01.png\"\u003e\u003c/p\u003e\n\u003cp\u003e使用 Chrome 开发者工具观察插件的网络请求，我们发现插件会请求一个地址如\u003ca href=\"https://www.gstatic.com/prettyearth/assets/data/v2/1234.json\"\u003ehttps://www.gstatic.com/prettyearth/assets/data/v2/1234.json\u003c/a\u003e的 JSON 文件，文件中包含了经过 Base64 的图片内容，观察发现，图片的 ID 范围大致在 1000-8000 之间，我们的爬虫就要来爬取这些精美的背景图片。\u003c/p\u003e\n\u003ch1 id=\"实现主要逻辑\"\u003e实现主要逻辑\u003c/h1\u003e\n\u003cp\u003e由于爬取目标是 JSON 文件，爬虫的主要逻辑就变成了\u003cstrong\u003e爬取 JSON\u0026ndash;\u0026gt;提取图片\u0026ndash;\u0026gt;保存图片\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003erequests 是一个常用的 http 请求库，但是由于 requests 的请求都是同步的，我们使用\u003ca href=\"https://aiohttp.readthedocs.io/en/stable/\"\u003eaiohttp\u003c/a\u003e这个异步 http 请求库来代替。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003easync\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003edef\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003efetch_image_by_id\u003c/span\u003e(item_id):\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\turl \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003ef\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e\u0026#39;https://www.gstatic.com/prettyearth/assets/data/v2/\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e{\u003c/span\u003eitem_id\u003cspan style=\"color:#e6db74\"\u003e}\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e.json\u0026#39;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#75715e\"\u003e# 由于URL是https的，所以选择不验证SSL\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#66d9ef\"\u003easync\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003ewith\u003c/span\u003e aiohttp\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003eClientSession(connector\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003eaiohttp\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003eTCPConnector(verify_ssl\u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e\u003cspan style=\"color:#66d9ef\"\u003eFalse\u003c/span\u003e)) \u003cspan style=\"color:#66d9ef\"\u003eas\u003c/span\u003e session:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\u003cspan style=\"color:#66d9ef\"\u003easync\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003ewith\u003c/span\u003e session\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003eget(url) \u003cspan style=\"color:#66d9ef\"\u003eas\u003c/span\u003e response:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#75715e\"\u003e# 获取后需要将JSON字符串转为对象\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\t\u003cspan style=\"color:#66d9ef\"\u003etry\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\t\tjson_obj \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e json\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003eloads(\u003cspan style=\"color:#66d9ef\"\u003eawait\u003c/span\u003e response\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003etext())\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\t\u003cspan style=\"color:#66d9ef\"\u003eexcept\u003c/span\u003e json\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003edecoder\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003eJSONDecodeError \u003cspan style=\"color:#66d9ef\"\u003eas\u003c/span\u003e e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\t\tprint(\u003cspan style=\"color:#e6db74\"\u003ef\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e\u0026#39;Download failed - \u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e{\u003c/span\u003eitem_id\u003cspan style=\"color:#e6db74\"\u003e}\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e.jpg\u0026#39;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\t\t\u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#75715e\"\u003e# 获取JSON中的图片内容字段，经过Base64解码成二进制内容\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\timage_str \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e json_obj[\u003cspan style=\"color:#e6db74\"\u003e\u0026#39;dataUri\u0026#39;\u003c/span\u003e]\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003ereplace(\u003cspan style=\"color:#e6db74\"\u003e\u0026#39;data:image/jpeg;base64,\u0026#39;\u003c/span\u003e, \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;\u0026#39;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\timage_data \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e base64\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003eb64decode(image_str)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\tsave_folder \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e dir_path \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e os\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003epath\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003edirname(\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\t\tos\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003epath\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003erealpath(__file__)) \u003cspan style=\"color:#f92672\"\u003e+\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;/google_earth/\u0026#39;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\t\u003cspan style=\"color:#66d9ef\"\u003ewith\u003c/span\u003e open(\u003cspan style=\"color:#e6db74\"\u003ef\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e\u0026#39;\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e{\u003c/span\u003esave_folder\u003cspan style=\"color:#e6db74\"\u003e}{\u003c/span\u003eitem_id\u003cspan style=\"color:#e6db74\"\u003e}\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e.jpg\u0026#39;\u003c/span\u003e, \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;wb\u0026#39;\u003c/span\u003e) \u003cspan style=\"color:#66d9ef\"\u003eas\u003c/span\u003e f:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\t\tf\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003ewrite(image_data)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\tprint(\u003cspan style=\"color:#e6db74\"\u003ef\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e\u0026#39;Download complete - \u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e{\u003c/span\u003eitem_id\u003cspan style=\"color:#e6db74\"\u003e}\u003c/span\u003e\u003cspan style=\"color:#e6db74\"\u003e.jpg\u0026#39;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003eaiohttp 基于 asyncio，所以在调用时需要使用 async/await 语法糖，可以看到，由于 aiohttp 中提供了一个 ClientSession 上下文，代码中使用了 async with 的语法糖。\u003c/p\u003e","title":"实战 | 用aiohttp和uvloop实现一个高性能爬虫"},{"content":"Python 从设计之初就是一门面向对象的语言，面向对象思想的第一个要素就是封装。所谓封装，通俗的讲就是类中的属性和方法，分为公有和私有，公有可以被外界访问，私有不能被外界访问，这就是封装中最关键的概念——访问控制。\n访问控制有三种级别：私有、受保护、公有\n私有（Private）：只有类自身可以访问 受保护（Protected）：只有类自身和子类可以访问 公有（Public）：任何类都可以访问\n由于 Python 不像 Java，有访问控制符（private / public / protected），所以 Python 的访问控制也是容易被应聘者忽视和搞错的。\n公有（Public） 在 Python 的类中，默认情况下定义的属性都是公有的。\nclass Foo(object): bar = 123 def __init__(self, bob): self.bob = bob print(Foo.bar) # 123 foo = Foo(456) print(foo.bob) # 456 上面类Foo中的bar属性就是类属性，__init__方法中定义的 bob 是实例属性，bar和bob都是公有的属性，外部可以访问，分别 print 类中的bar和实例中的bob，输出了对应的值。\n受保护（Protected） 在 Python 中定义一个受保护的属性，只需要在其名字前加一个下划线_，我们将 Foo 方法中的bob和bar改为_bob和_bar，他们就变成了受保护的属性了，代码如下：\nclass Foo(object): _bar = 123 def __init__(self, bob): self._bob = bob class Son(Foo): def print_bob(self): print(self._bob) @classmethod def print_bar(cls): print(cls._bar) Son.print_bar() # 123 son = Son(456) son.print_bob() # 456 定义一个类Son继承自Foo，由于受保护的对象只能在类的内部和子类中被访问，不能直接调用print(Son._bar)或print(son._bob)来输出这两个属性的值，所以定义了print_bar和print_bob方法，实现在子类中输出，这段代码也正常的输出了_bar和_bob的值。\n接下来，试着反向验证一下，在类的外部，能不能访问其属性，将上面代码的输出部分修改如下：\nprint(Son._bar) # 123 son = Son(456) print(son._bob) # 456 （假装）惊讶的发现，竟然没有报错，也输出了正确的值。\nPython 中用加下划线来定义受保护变量，是一种约定的规范，而不是语言层面真的实现了访问控制，所以，我们定义的保护变量，依然可以在外部被访问到（这是个 feature，不是 bug）。\n私有（private） Python 定义私有属性，需要在属性名前加两个下划线__，把上面的代码修改一下，运行一下会发现下面的代码中的任何一个 print 都会报错的。\nclass Foo(object): __bar = 123 def __init__(self, bob): self.__bob = bob class Son(Foo): def print_bob(self): print(self.__bob) # Error @classmethod def print_bar(cls): print(cls.__bar) # Error print(Son.__bar) # Error son = Son(456) print(son._bob) # Error 深入一下——私有属性真的就访问不到了吗？ 要了解私有属性是否真的访问不到，需要从 Python 是如何实现私有属性入手。CPython 中，会把双下划线的属性变为_ClassName__PropertyName的形式，用代码演示一下：\nclass Foo(object): __bar = 123 print(Foo._Foo__bar) # 123 运行一下可以知道，正常输出了__bar的值，但是不推荐这样去访问私有属性，因为不同的 Python 解释器对于私有属性的处理不一样。\n特例 使用双下划线定义私有属性，有一种特殊情况，当属性后也有两个下划线的时候，这个属性会被 Python 解释器当做魔术方法，从而不做私有处理。\nclass Foo(object): __bar__ = 123 print(Foo.__bar__) # 123 上面代码输出了 123，证明 Python 解释器并没有把__bar__当做私有属性。当定义私有属性时，需要注意名字最后最多只能有一个下划线。\n另一个特例 假如定义的属性名就叫__呢？不妨直接试一下：\nclass Foo(object): __ = 123 print(Foo.__) # 123 可以发现名字叫__的属性也不会被认为是私有属性，名字是多个下划线的属性也不是私有属性（比如_______）。\n函数的访问控制 前面主要介绍了属性的访问控制，在 Python 中函数是一等公民，所谓一等公民，就是函数可以像变量一样使用，所以函数的访问控制和属性一样，一样应用上面的规则。\n","permalink":"https://simpleapples.com/zh/posts/python-access-control/","summary":"\u003cp\u003ePython 从设计之初就是一门面向对象的语言，面向对象思想的第一个要素就是封装。所谓封装，通俗的讲就是类中的属性和方法，分为公有和私有，公有可以被外界访问，私有不能被外界访问，这就是封装中最关键的概念——访问控制。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"面向对象编程\" loading=\"lazy\" src=\"/images/20180330_01.jpg\"\u003e\u003c/p\u003e\n\u003cp\u003e访问控制有三种级别：私有、受保护、公有\u003c/p\u003e\n\u003cp\u003e私有（Private）：只有类自身可以访问\n受保护（Protected）：只有类自身和子类可以访问\n公有（Public）：任何类都可以访问\u003c/p\u003e\n\u003cp\u003e由于 Python 不像 Java，有访问控制符（private / public / protected），所以 Python 的访问控制也是容易被应聘者忽视和搞错的。\u003c/p\u003e\n\u003ch1 id=\"公有public\"\u003e公有（Public）\u003c/h1\u003e\n\u003cp\u003e在 Python 的类中，默认情况下定义的属性都是公有的。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eFoo\u003c/span\u003e(object):\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\tbar \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e123\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#66d9ef\"\u003edef\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003e__init__\u003c/span\u003e(self, bob):\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\tself\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003ebob \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e bob\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eprint(Foo\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003ebar)  \u003cspan style=\"color:#75715e\"\u003e# 123\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003efoo \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e Foo(\u003cspan style=\"color:#ae81ff\"\u003e456\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eprint(foo\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003ebob)  \u003cspan style=\"color:#75715e\"\u003e# 456\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e上面类\u003ccode\u003eFoo\u003c/code\u003e中的\u003ccode\u003ebar\u003c/code\u003e属性就是类属性，\u003ccode\u003e__init__\u003c/code\u003e方法中定义的 bob 是实例属性，\u003ccode\u003ebar\u003c/code\u003e和\u003ccode\u003ebob\u003c/code\u003e都是公有的属性，外部可以访问，分别 print 类中的\u003ccode\u003ebar\u003c/code\u003e和实例中的\u003ccode\u003ebob\u003c/code\u003e，输出了对应的值。\u003c/p\u003e\n\u003ch1 id=\"受保护protected\"\u003e受保护（Protected）\u003c/h1\u003e\n\u003cp\u003e在 Python 中定义一个受保护的属性，只需要在其名字前加一个下划线\u003ccode\u003e_\u003c/code\u003e，我们将 Foo 方法中的\u003ccode\u003ebob\u003c/code\u003e和\u003ccode\u003ebar\u003c/code\u003e改为\u003ccode\u003e_bob\u003c/code\u003e和\u003ccode\u003e_bar\u003c/code\u003e，他们就变成了受保护的属性了，代码如下：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eFoo\u003c/span\u003e(object):\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t_bar \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e123\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#66d9ef\"\u003edef\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003e__init__\u003c/span\u003e(self, bob):\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\tself\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003e_bob \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e bob\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eSon\u003c/span\u003e(Foo):\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#66d9ef\"\u003edef\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eprint_bob\u003c/span\u003e(self):\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\tprint(self\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003e_bob)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#a6e22e\"\u003e@classmethod\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#66d9ef\"\u003edef\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eprint_bar\u003c/span\u003e(cls):\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\tprint(cls\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003e_bar)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eSon\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003eprint_bar()  \u003cspan style=\"color:#75715e\"\u003e# 123\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eson \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e Son(\u003cspan style=\"color:#ae81ff\"\u003e456\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003eson\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003eprint_bob()  \u003cspan style=\"color:#75715e\"\u003e# 456\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e定义一个类\u003ccode\u003eSon\u003c/code\u003e继承自\u003ccode\u003eFoo\u003c/code\u003e，由于受保护的对象只能在类的内部和子类中被访问，不能直接调用\u003ccode\u003eprint(Son._bar)\u003c/code\u003e或\u003ccode\u003eprint(son._bob)\u003c/code\u003e来输出这两个属性的值，所以定义了\u003ccode\u003eprint_bar\u003c/code\u003e和\u003ccode\u003eprint_bob\u003c/code\u003e方法，实现在子类中输出，这段代码也正常的输出了\u003ccode\u003e_bar\u003c/code\u003e和\u003ccode\u003e_bob\u003c/code\u003e的值。\u003c/p\u003e","title":"与面试官谈笑风生 | Python面向对象之访问控制"},{"content":"使用 Win10 的朋友会发现，每次开机锁屏界面都会有不一样的漂亮图片，这些图片通常选自优秀的摄影作品，十分精美。\n但是由于系统会自动更换这些图片，所以就算再好看的图片，也许下次开机之后就被替换掉了。\n借助 Python，我们可以用简单的几行代码，批量提取这些精美的锁屏图片。把喜欢的图片设置成桌面背景，就不用担心被替换掉啦。\n提取原理 Win10 系统会自动下载最新的锁屏壁纸，并将他们保存在一个系统文件夹中，路径是C:\\Users\\[用户名]\\AppData\\Local\\Packages\\Microsoft.Windows.ContentDeliveryManager_cw5n1h2txyewy\\LocalState\\Assets\n直接打开这个文件夹，里面会有随机命名的多个文件，每一个文件就是一张图片。但是由于文件没有扩展名，所以并不能预览。为了不搞坏系统文件，并且把这些文件变成可以预览的格式，我们用 Python 把这些文件复制出来，加上 JPG 作为扩展名。\n实现代码 import os, shutil from datetime import datetime # 把这个文件所在目录wallpapers文件夹作为保存图片的目录 save_folder = dir_path = os.path.dirname( os.path.realpath(__file__)) + \u0026#39;\\wallpapers\u0026#39; # 动态获取系统存放锁屏图片的位置 wallpaper_folder = os.getenv(\u0026#39;LOCALAPPDATA\u0026#39;) + ( \u0026#39;\\Packages\\Microsoft.Windows.ContentDeliveryManager_cw5n1h2txyewy\u0026#39; \u0026#39;\\LocalState\\Assets\u0026#39;) # 列出所有的文件 wallpapers = os.listdir(wallpaper_folder) for wallpaper in wallpapers: wallpaper_path = os.path.join(wallpaper_folder, wallpaper) # 小于150kb的不是锁屏图片 if (os.path.getsize(wallpaper_path) / 1024) \u0026lt; 150: continue wallpaper_name = wallpaper + \u0026#39;.jpg\u0026#39; save_path = os.path.join(save_folder, wallpaper_name) shutil.copyfile(wallpaper_path, save_path) print(\u0026#39;Save wallpaper \u0026#39; + save_path) 首先确定系统存放锁屏图片的文件夹位置，由于文件夹位于用户的个人文件夹内，每个用户的用户名是不一样的，所以我们需要通过系统的LOCALAPPDATA变量动态的获取路径。代码会把提取出来的图片保存在 wallpapers 文件夹下，所以代码文件所在的目录没有 wallpapers 文件夹，需要手工创建一个。\n执行上面这段 Python 代码，再打开 wallpapers 文件夹，就可以看到提取出的锁屏图片了。\n","permalink":"https://simpleapples.com/zh/posts/extract-lockscreen-wallpapers-in-win10/","summary":"\u003cp\u003e使用 Win10 的朋友会发现，每次开机锁屏界面都会有不一样的漂亮图片，这些图片通常选自优秀的摄影作品，十分精美。\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/images/20180326_01.jpg\"\u003e\u003c/p\u003e\n\u003cp\u003e但是由于系统会自动更换这些图片，所以就算再好看的图片，也许下次开机之后就被替换掉了。\u003c/p\u003e\n\u003cp\u003e借助 Python，我们可以用简单的几行代码，批量提取这些精美的锁屏图片。把喜欢的图片设置成桌面背景，就不用担心被替换掉啦。\u003c/p\u003e\n\u003ch1 id=\"提取原理\"\u003e提取原理\u003c/h1\u003e\n\u003cp\u003eWin10 系统会自动下载最新的锁屏壁纸，并将他们保存在一个系统文件夹中，路径是\u003ccode\u003eC:\\Users\\[用户名]\\AppData\\Local\\Packages\\Microsoft.Windows.ContentDeliveryManager_cw5n1h2txyewy\\LocalState\\Assets\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"随机命名的锁屏图片\" loading=\"lazy\" src=\"/images/20180326_02.png\"\u003e\u003c/p\u003e\n\u003cp\u003e直接打开这个文件夹，里面会有随机命名的多个文件，每一个文件就是一张图片。但是由于文件没有扩展名，所以并不能预览。为了不搞坏系统文件，并且把这些文件变成可以预览的格式，我们用 Python 把这些文件复制出来，加上 JPG 作为扩展名。\u003c/p\u003e\n\u003ch1 id=\"实现代码\"\u003e实现代码\u003c/h1\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003eimport\u003c/span\u003e os\u003cspan style=\"color:#f92672\"\u003e,\u003c/span\u003e shutil\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003efrom\u003c/span\u003e datetime \u003cspan style=\"color:#f92672\"\u003eimport\u003c/span\u003e datetime\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# 把这个文件所在目录wallpapers文件夹作为保存图片的目录\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003esave_folder \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e dir_path \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e os\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003epath\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003edirname(\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\tos\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003epath\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003erealpath(__file__)) \u003cspan style=\"color:#f92672\"\u003e+\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;\\wallpapers\u0026#39;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# 动态获取系统存放锁屏图片的位置\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ewallpaper_folder \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e os\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003egetenv(\u003cspan style=\"color:#e6db74\"\u003e\u0026#39;LOCALAPPDATA\u0026#39;\u003c/span\u003e) \u003cspan style=\"color:#f92672\"\u003e+\u003c/span\u003e (\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#e6db74\"\u003e\u0026#39;\\Packages\\Microsoft.Windows.ContentDeliveryManager_cw5n1h2txyewy\u0026#39;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#e6db74\"\u003e\u0026#39;\\LocalState\\Assets\u0026#39;\u003c/span\u003e)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#75715e\"\u003e# 列出所有的文件\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003ewallpapers \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e os\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003elistdir(wallpaper_folder)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003efor\u003c/span\u003e wallpaper \u003cspan style=\"color:#f92672\"\u003ein\u003c/span\u003e wallpapers:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\twallpaper_path \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e os\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003epath\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003ejoin(wallpaper_folder, wallpaper)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#75715e\"\u003e# 小于150kb的不是锁屏图片\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e (os\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003epath\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003egetsize(wallpaper_path) \u003cspan style=\"color:#f92672\"\u003e/\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e1024\u003c/span\u003e) \u003cspan style=\"color:#f92672\"\u003e\u0026lt;\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e150\u003c/span\u003e:\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\t\t\u003cspan style=\"color:#66d9ef\"\u003econtinue\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\twallpaper_name \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e wallpaper \u003cspan style=\"color:#f92672\"\u003e+\u003c/span\u003e \u003cspan style=\"color:#e6db74\"\u003e\u0026#39;.jpg\u0026#39;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\tsave_path \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e os\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003epath\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003ejoin(save_folder, wallpaper_name)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\tshutil\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003ecopyfile(wallpaper_path, save_path)\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\tprint(\u003cspan style=\"color:#e6db74\"\u003e\u0026#39;Save wallpaper \u0026#39;\u003c/span\u003e \u003cspan style=\"color:#f92672\"\u003e+\u003c/span\u003e save_path)\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e首先确定系统存放锁屏图片的文件夹位置，由于文件夹位于用户的个人文件夹内，每个用户的用户名是不一样的，所以我们需要通过系统的\u003ccode\u003eLOCALAPPDATA\u003c/code\u003e变量动态的获取路径。代码会把提取出来的图片保存在 wallpapers 文件夹下，所以代码文件所在的目录没有 wallpapers 文件夹，需要手工创建一个。\u003c/p\u003e","title":"用Python批量提取Win10锁屏壁纸"},{"content":"\n在网络中传输数据时，为了防止网络拥塞，需限制流出网络的流量，使流量以比较均匀的速度向外发送，令牌桶算法就实现了这个功能，可控制发送到网络上数据的数目，并允许突发数据的发送。\n什么是令牌 从名字上看令牌桶，大概就是一个装有令牌的桶吧，那么什么是令牌呢？\n紫薇格格拿的令箭，可以发号施令，令行禁止。在计算机的世界中，令牌也有令行禁止的意思，有令牌，则相当于得到了进行操作的授权，没有令牌，就什么都不能做。\n用令牌实现限速器 我们用 1 块令牌来代表发送 1 字节数据的资格，假设我们源源不断的发放令牌给程序，程序就有资格源源不断的发送数据，当我们不发放令牌给程序，程序就相当于被限流，无法发送数据了。接下来我们说说限速器，所谓限速器，就是让程序在单位时间内，最多只能发送一定大小的数据。假设在 1 秒发放 10 块令牌，那么程序发送数据的速度就会被限制在 10bytes/s。如果 1 秒内有大于 10bytes 的数据需要发送，就会因为没有令牌而被丢弃。\n改进限速器——加个桶 我们实现的限速器，速度是恒定的，但是在实际的应用中，往往会有突发的传输需求（需要更快速的发送，但是不会持续太久，也不会引起网络拥塞），这种数据碰上我们的限速器，就因为拿不到令牌而无法发送。\n对限速器进行一下改动，依然 1 秒产生 10 块令牌，但是我们把产生出来的令牌先放到一个桶里，当程序需要发送的时候，从桶里取令牌，不需要的时候，令牌就会在桶里沉淀下来，假设桶里沉淀了 10 块令牌，程序最多就可以在 1 秒内发送 20bytes 的数据，满足了突发数据传输的要求，并且由于桶里的令牌被用完，下一秒最多依然只能发 10bytes 的数据，不会因为持续发送大量数据，对网络造成压力。\n15 行 Python 代码实践令牌桶 令牌桶需要以一定的速度生成令牌放入桶中，当程序要发送数据时，再从桶中取出令牌。这里似乎有点问题，如果我们使用一个死循环，来不停地发放令牌，程序就被阻塞住了，有没有更好的办法？\n我们可以在取令牌的时候，用现在的时间减去上次取令牌的时间，乘以令牌的发放速度，计算出桶里可以取的令牌数量（当然不能超过桶的大小），从而避免循环发放的逻辑。\n接下来看代码：\nimport time class TokenBucket(object): # rate是令牌发放速度，capacity是桶的大小 def __init__(self, rate, capacity): self._rate = rate self._capacity = capacity self._current_amount = 0 self._last_consume_time = int(time.time()) # token_amount是发送数据需要的令牌数 def consume(self, token_amount): increment = (int(time.time()) - self._last_consume_time) * self._rate # 计算从上次发送到这次发送，新发放的令牌数量 self._current_amount = min( increment + self._current_amount, self._capacity) # 令牌数量不能超过桶的容量 if token_amount \u0026gt; self._current_amount: # 如果没有足够的令牌，则不能发送数据 return False self._last_consume_time = int(time.time()) self._current_amount -= token_amount return True ","permalink":"https://simpleapples.com/zh/posts/implementation-of-the-token-bucket-algorithm-in-python/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/images/20180320_01.jpg\"\u003e\u003c/p\u003e\n\u003cp\u003e在网络中传输数据时，为了防止网络拥塞，需限制流出网络的流量，使流量以比较均匀的速度向外发送，令牌桶算法就实现了这个功能，\u003cstrong\u003e可控制发送到网络上数据的数目，并允许突发数据的发送。\u003c/strong\u003e\u003c/p\u003e\n\u003ch1 id=\"什么是令牌\"\u003e什么是令牌\u003c/h1\u003e\n\u003cp\u003e从名字上看令牌桶，大概就是一个装有令牌的桶吧，那么什么是令牌呢？\u003c/p\u003e\n\u003cp\u003e紫薇格格拿的令箭，可以发号施令，令行禁止。在计算机的世界中，令牌也有令行禁止的意思，有令牌，则相当于得到了进行操作的授权，没有令牌，就什么都不能做。\u003c/p\u003e\n\u003ch1 id=\"用令牌实现限速器\"\u003e用令牌实现限速器\u003c/h1\u003e\n\u003cp\u003e我们用 1 块令牌来代表发送 1 字节数据的资格，假设我们源源不断的发放令牌给程序，程序就有资格源源不断的发送数据，当我们不发放令牌给程序，程序就相当于被限流，无法发送数据了。接下来我们说说限速器，所谓限速器，就是让程序在单位时间内，最多只能发送一定大小的数据。假设在 1 秒发放 10 块令牌，那么程序发送数据的速度就会被限制在 10bytes/s。如果 1 秒内有大于 10bytes 的数据需要发送，就会因为没有令牌而被丢弃。\u003c/p\u003e\n\u003ch1 id=\"改进限速器加个桶\"\u003e改进限速器——加个桶\u003c/h1\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/images/20180320_02.jpg\"\u003e\u003c/p\u003e\n\u003cp\u003e我们实现的限速器，速度是恒定的，但是在实际的应用中，往往会有突发的传输需求（需要更快速的发送，但是不会持续太久，也不会引起网络拥塞），这种数据碰上我们的限速器，就因为拿不到令牌而无法发送。\u003c/p\u003e\n\u003cp\u003e对限速器进行一下改动，依然 1 秒产生 10 块令牌，但是我们把产生出来的令牌先放到一个桶里，当程序需要发送的时候，从桶里取令牌，不需要的时候，令牌就会在桶里沉淀下来，假设桶里沉淀了 10 块令牌，程序最多就可以在 1 秒内发送 20bytes 的数据，满足了突发数据传输的要求，并且由于桶里的令牌被用完，下一秒最多依然只能发 10bytes 的数据，不会因为持续发送大量数据，对网络造成压力。\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/images/20180320_03.jpg\"\u003e\u003c/p\u003e\n\u003ch1 id=\"15-行-python-代码实践令牌桶\"\u003e15 行 Python 代码实践令牌桶\u003c/h1\u003e\n\u003cp\u003e令牌桶需要以一定的速度生成令牌放入桶中，当程序要发送数据时，再从桶中取出令牌。这里似乎有点问题，如果我们使用一个死循环，来不停地发放令牌，程序就被阻塞住了，有没有更好的办法？\u003c/p\u003e\n\u003cp\u003e我们可以在取令牌的时候，用现在的时间减去上次取令牌的时间，乘以令牌的发放速度，计算出桶里可以取的令牌数量（当然不能超过桶的大小），从而避免循环发放的逻辑。\u003c/p\u003e\n\u003cp\u003e接下来看代码：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" style=\"color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;\"\u003e\u003ccode class=\"language-python\" data-lang=\"python\"\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#f92672\"\u003eimport\u003c/span\u003e time\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\u003cspan style=\"color:#66d9ef\"\u003eclass\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003eTokenBucket\u003c/span\u003e(object):\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#75715e\"\u003e# rate是令牌发放速度，capacity是桶的大小\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003edef\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003e__init__\u003c/span\u003e(self, rate, capacity):\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        self\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003e_rate \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e rate\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        self\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003e_capacity \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e capacity\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        self\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003e_current_amount \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e \u003cspan style=\"color:#ae81ff\"\u003e0\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        self\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003e_last_consume_time \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e int(time\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003etime())\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#75715e\"\u003e# token_amount是发送数据需要的令牌数\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e    \u003cspan style=\"color:#66d9ef\"\u003edef\u003c/span\u003e \u003cspan style=\"color:#a6e22e\"\u003econsume\u003c/span\u003e(self, token_amount):\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        increment \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e (int(time\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003etime()) \u003cspan style=\"color:#f92672\"\u003e-\u003c/span\u003e self\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003e_last_consume_time) \u003cspan style=\"color:#f92672\"\u003e*\u003c/span\u003e self\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003e_rate  \u003cspan style=\"color:#75715e\"\u003e# 计算从上次发送到这次发送，新发放的令牌数量\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        self\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003e_current_amount \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e min(\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            increment \u003cspan style=\"color:#f92672\"\u003e+\u003c/span\u003e self\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003e_current_amount, self\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003e_capacity)  \u003cspan style=\"color:#75715e\"\u003e# 令牌数量不能超过桶的容量\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003eif\u003c/span\u003e token_amount \u003cspan style=\"color:#f92672\"\u003e\u0026gt;\u003c/span\u003e self\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003e_current_amount:  \u003cspan style=\"color:#75715e\"\u003e# 如果没有足够的令牌，则不能发送数据\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e            \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003eFalse\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        self\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003e_last_consume_time \u003cspan style=\"color:#f92672\"\u003e=\u003c/span\u003e int(time\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003etime())\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        self\u003cspan style=\"color:#f92672\"\u003e.\u003c/span\u003e_current_amount \u003cspan style=\"color:#f92672\"\u003e-=\u003c/span\u003e token_amount\n\u003c/span\u003e\u003c/span\u003e\u003cspan style=\"display:flex;\"\u003e\u003cspan\u003e        \u003cspan style=\"color:#66d9ef\"\u003ereturn\u003c/span\u003e \u003cspan style=\"color:#66d9ef\"\u003eTrue\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e","title":"15行Python代码，帮你理解令牌桶算法"},{"content":"\n区块链是一个近期非常火的概念，随便走进一个写字楼的电梯，都会听到有人谈论区块链，或者炒币: ) 希望通过这篇文章，能让你对区块链的概念有一个整体的认识，在理解概念后，下一篇文章将用大约 300 行 Python 代码，实现一个区块链网络。\n区块 和 链 所谓区块，就是一个块咯（要不然还是什么？），把这些块一个一个连在一起，像链条一样，就称为区块链（别急着打我，先往下看）。\n这是一些链条，链条的价值更多的体现在锁楼下小电动车的时候，不过我们再仔细看一下这个链条是不是有点像那什么？⛓\n很聪明，高中生物老师在冲你微笑！这就是传说中的脱氧核糖核酸（DNA），DNA 也是一种链式结构，携带了遗传信息。区块链中的“区块”，就好比 DNA 分子中的脱氧核糖核苷酸（我也不知道自己在说什么），而区块链中的“链”，就好比 DNA 分子的链式结构。\nDNA 和链条的价值差异，关键在于 DNA 携带了大量遗传信息，而链条什么都没有携带。对于区块链来说，携带信息也是它的一个重要特点（不携带信息连锁电动车的作用都没有）。\n当区块链携带的是账务信息的时候，它就变成了一个特别厉害的东西——账本（我们给他起了个 00 后的名字——比特币）。\nPeer-to-Peer 为了显得专业一些，我们祭出比特币的创造者，中本聪的论文《Bitcoin: A Peer-to-Peer Electronic Cash System》，从这篇论文的题目我们可以看到，区块链是基于Peer-to-Peer的，下面就来了解一下什么是 Peer-to-Peer。\nPeer-to-Peer，简称 P2P（不是互联网借贷的那个 P2P），它是一种点对点网络，看图（我也不知道该怎么讲）。\n图中每一个方脑袋就是一个 Peer（节点），注意一下，这些方脑袋有一个共同点，他们都一毛一样（不仅长得一样，每一个脑袋都跟其它脑袋相连）。这也是 P2P 网络的最大特点——去中心化，P2P 网络中不存在中心节点，所有节点都是平等的，任何一个节点，想跟谁说话就跟谁说话，并且谁（节点）都不能说了算。\n共识机制 你和好基友老王，还有你们共同喜欢的一个姑娘阿圆（对，就是圆滚滚的圆），组成了一个三节点的 P2P 网络，根据 P2P 网络定义你们三个人谁都不能说了算。这一天，阿圆生日，你和老王同时给阿圆送了一个大蛋糕，那么问题来了，阿圆先吃哪个呢？\n既然没有人能说了算，也不能让你和老王决斗（计算机这么做恐怕人类会毁灭），那么就需要采用一个文明的办法决定——商量。既然商量，就要有规矩，这个规矩叫共识机制。\nProof-of-work 区块链共识机制有很多种，Proof-of-work（POW，工作量证明）是其中一种，所谓工作量证明，有点像是比武招亲。你和老王对阿圆都很好，阿圆也很难抉择到底先吃谁的蛋糕，于是她请了两位武力相当的武林高手，让你和老王分别与高手过招，谁赢了高手，就先吃谁的蛋糕，如果你们都赢了高手，那么谁先赢算数。\n把这些捏在一起 了解了 POW、共识机制、P2P、区块、链的概念，我们就可以把他们拼在一起，看看会发生什么了。\n我们把 P2P 网络中的每一个节点，赋予一条链，这样网络中所有的链都是平等的了，接下来在其中一条链上增加一个带有信息的区块，P2P 网络会将这个区块同步到所有的链上，也就是这条信息会被存储在所有节点。\n把上面的一段话缩成一句（会显得比较厉害）：\n区块链是用分布式数据库识别、传播和记载信息的智能化对等网络, 也称为价值互联网。\n看到这里是不是对区块链略知一二了？\n","permalink":"https://simpleapples.com/zh/posts/understanding-blockchain/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/images/20180314_01.png\"\u003e\u003c/p\u003e\n\u003cp\u003e区块链是一个近期非常火的概念，随便走进一个写字楼的电梯，都会听到有人谈论区块链，或者炒币: ) 希望通过这篇文章，能让你对区块链的概念有一个整体的认识，在理解概念后，\u003cstrong\u003e下一篇文章将用大约 300 行 Python 代码，实现一个区块链网络。\u003c/strong\u003e\u003c/p\u003e\n\u003ch1 id=\"区块-和-链\"\u003e区块 和 链\u003c/h1\u003e\n\u003cp\u003e所谓区块，就是一个块咯（要不然还是什么？），把这些块一个一个连在一起，像链条一样，就称为区块链（别急着打我，先往下看）。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"区块和区块链\" loading=\"lazy\" src=\"/images/20180314_02.jpg\"\u003e\u003c/p\u003e\n\u003cp\u003e这是一些链条，链条的价值更多的体现在锁楼下小电动车的时候，不过我们再仔细看一下这个链条是不是有点像那什么？⛓\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"脱氧核糖核酸\" loading=\"lazy\" src=\"/images/20180314_03.gif\"\u003e\u003c/p\u003e\n\u003cp\u003e很聪明，高中生物老师在冲你微笑！这就是传说中的脱氧核糖核酸（DNA），DNA 也是一种链式结构，\u003cstrong\u003e携带了遗传信息\u003c/strong\u003e。区块链中的“区块”，就好比 DNA 分子中的脱氧核糖核苷酸（我也不知道自己在说什么），而区块链中的“链”，就好比 DNA 分子的链式结构。\u003c/p\u003e\n\u003cp\u003eDNA 和链条的价值差异，关键在于 DNA 携带了大量遗传\u003cstrong\u003e信息\u003c/strong\u003e，而链条什么都没有携带。对于区块链来说，携带信息也是它的一个重要特点（不携带信息连锁电动车的作用都没有）。\u003c/p\u003e\n\u003cp\u003e当区块链携带的是账务信息的时候，它就变成了一个特别厉害的东西——账本（我们给他起了个 00 后的名字——比特币）。\u003c/p\u003e\n\u003ch1 id=\"peer-to-peer\"\u003ePeer-to-Peer\u003c/h1\u003e\n\u003cp\u003e为了显得专业一些，我们祭出比特币的创造者，中本聪的论文\u003ca href=\"https://bitcoin.org/bitcoin.pdf\"\u003e《Bitcoin: A Peer-to-Peer Electronic Cash System》\u003c/a\u003e，从这篇论文的题目我们可以看到，区块链是基于\u003cstrong\u003ePeer-to-Peer\u003c/strong\u003e的，下面就来了解一下什么是 Peer-to-Peer。\u003c/p\u003e\n\u003cp\u003ePeer-to-Peer，简称 P2P（不是互联网借贷的那个 P2P），它是一种点对点网络，看图（我也不知道该怎么讲）。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"P2P网络\" loading=\"lazy\" src=\"/images/20180314_04.jpg\"\u003e\u003c/p\u003e\n\u003cp\u003e图中每一个方脑袋就是一个 Peer（节点），注意一下，这些方脑袋有一个共同点，他们都一毛一样（不仅长得一样，每一个脑袋都跟其它脑袋相连）。这也是 P2P 网络的最大特点——\u003cstrong\u003e去中心化\u003c/strong\u003e，P2P 网络中不存在中心节点，所有节点都是平等的，任何一个节点，想跟谁说话就跟谁说话，并且谁（节点）都不能说了算。\u003c/p\u003e\n\u003ch1 id=\"共识机制\"\u003e共识机制\u003c/h1\u003e\n\u003cp\u003e你和好基友老王，还有你们共同喜欢的一个姑娘阿圆（对，就是圆滚滚的圆），组成了一个三节点的 P2P 网络，根据 P2P 网络定义你们三个人谁都不能说了算。这一天，阿圆生日，你和老王同时给阿圆送了一个大蛋糕，那么问题来了，阿圆先吃哪个呢？\u003c/p\u003e\n\u003cp\u003e既然没有人能说了算，也不能让你和老王决斗（计算机这么做恐怕人类会毁灭），那么就需要采用一个文明的办法决定——商量。既然商量，就要有规矩，这个规矩叫\u003cstrong\u003e共识机制\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/images/20180314_05.png\"\u003e\u003c/p\u003e\n\u003ch1 id=\"proof-of-work\"\u003eProof-of-work\u003c/h1\u003e\n\u003cp\u003e区块链共识机制有很多种，Proof-of-work（POW，工作量证明）是其中一种，所谓工作量证明，有点像是比武招亲。你和老王对阿圆都很好，阿圆也很难抉择到底先吃谁的蛋糕，于是她请了两位武力相当的武林高手，让你和老王分别与高手过招，谁赢了高手，就先吃谁的蛋糕，如果你们都赢了高手，那么谁先赢算数。\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/images/20180314_06.jpg\"\u003e\u003c/p\u003e\n\u003ch1 id=\"把这些捏在一起\"\u003e把这些捏在一起\u003c/h1\u003e\n\u003cp\u003e了解了 POW、共识机制、P2P、区块、链的概念，我们就可以把他们拼在一起，看看会发生什么了。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"区块链诞生了！\" loading=\"lazy\" src=\"/images/20180314_07.jpeg\"\u003e\u003c/p\u003e\n\u003cp\u003e我们把 P2P 网络中的每一个节点，赋予一条链，这样网络中所有的链都是平等的了，接下来在其中一条链上增加一个带有信息的区块，P2P 网络会将这个区块同步到所有的链上，也就是这条信息会被存储在所有节点。\u003c/p\u003e\n\u003cp\u003e把上面的一段话缩成一句（会显得比较厉害）：\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e区块链是用分布式数据库识别、传播和记载信息的智能化对等网络, 也称为价值互联网。\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e看到这里是不是对区块链略知一二了？\u003c/p\u003e","title":"最爱你的人，会让你不费脑细胞的理解区块链原理"},{"content":"\nLRU 算法在后端工程师面试中，是一个比较常出现的题目，这篇文章带大家一起，理解 LRU 算法，并最终用 Python 轻松实现一个基于 LRU 算法的缓存。\n缓存是什么 先看一张图，当我们访问网页，浏览器会给服务器发请求，服务器会经过一系列的运算，把页面返回给浏览器。\n当有多个浏览器同时访问的时候，就会在短时间内发起多个请求，而服务器对每一个请求都要进行一系列相同的操作。重复工作不仅浪费资源，还可能导致响应速度变慢。\n而缓存则可以把服务器返回的页面保存下来，当有其他的浏览器再访问时候，就不必劳服务器大驾，直接由缓存返回页面。为了保证响应速度，缓存通常是基于比较昂贵的硬件，比如 RAM，这就决定了我们很难用大量的缓存把所有的页面都存下来，当恰好没有缓存浏览器请求的页面时，依然需要请求服务器。由于缓存容量有限，而数据量无限（互联网每天新产生的页面数无法估计），就需要把好刚用在刀刃上，缓存那些最有用的信息。\nLRU 是什么 LRU 是一种缓存淘汰算法（在 OS 中也叫内存换页算法），由于缓存空间是有限的，所以要淘汰缓存中不常用的数据，留下常用的数据，达到缓存效率的最大化。LRU 就是这样一种决定“淘汰谁留下谁”的算法，LRU 是 Least recently used 的缩写，从字面意思“最近最少使用”，我们就可以理解 LRU 的淘汰规则。\nLRU 的淘汰逻辑 我们用一张图来描述 LRU 的淘汰逻辑，图中的缓存是一个列表结构，上面是头结点下面是尾节点，缓存容量为 8（8 个小格子）：\n有新数据（意味着数据之前没有被缓存过）时，加入到列表头 缓存到达最大容量时，需要淘汰数据多出来的数据，此时淘汰列表尾部的数据 当缓存中有数据被命中，则将数据移动到列表头部（相当于新加入缓存） 按上面的逻辑我们可以看到，一个数据如果经常被访问就会不断地被移动到列表头部，不会被淘汰出缓存，而越不经常访问的数据，越容易被挤出缓存。\n20 行 Python 代码实践 LRU 接下来我们用 Python 来实现一个采用 LRU 算法的缓存。\n从前面的文章中我们可以知道，缓存简化下来就两个功能，一个是往里装数据（缓存数据），一个是往外吐数据（命中缓存），所以我们的缓存对外只需要 put 和 get 两个接口就可以了。\n按照前面的示意图，缓存内部我们只需要有一个列表（list）就可以实现 LRU 逻辑，不过用列表虽然能实现逻辑，但是在判断是否命中缓存时，速度可能非常慢（列表需要遍历才能知道数据有没有在里面）。在 Python 中，我们可以用基于 hash 的结构，比如字典（dict）或集合（set），来快速判断数据是否存在，解决列表实现的性能问题。但是字典和集合又是没有顺序的，如果能有一种既能排序，又是基于 hash 存储的数据结构，就好了。\n在 Python 的 collections 包中，已经内置了这种实用的结构 OrderedDict，OrderedDict 是 dict 的子类，但是存储在内部的元素是有序的（列表的特点）。\n解决了数据结构的问题，我们可以直接上手写逻辑了，代码如下：\nclass LRUCache: def __init__(self, capacity): self.capacity = capacity self.queue = collections.OrderedDict() def get(self, key): if key not in self.queue: return -1 // 要找的数据不在缓存中返回-1 value = self.queue.pop(key) // 将命中缓存的数据移除 self.queue[key] = value // 将命中缓存的数据重新添加到头部 return self.queue[key] def put(self, key, value): if key in self.queue: // 如果已经在缓存中，则先移除老的数据 self.queue.pop(key) elif len(self.queue.items()) == self.capacity: self.queue.popitem(last=False) // 如果不在缓存中并且到达最大容量，则把最后的数据淘汰 self.queue[key] = value // 将新数据添加到头部 下次面试在遇到 LRU 的题目，是不是就胸有成竹了？\n","permalink":"https://simpleapples.com/zh/posts/lru-algorithm-implemented-in-python/","summary":"\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/images/20180306_01.png\"\u003e\u003c/p\u003e\n\u003cp\u003eLRU 算法在后端工程师面试中，是一个比较常出现的题目，这篇文章带大家一起，理解 LRU 算法，并最终用 Python 轻松实现一个基于 LRU 算法的缓存。\u003c/p\u003e\n\u003ch2 id=\"缓存是什么\"\u003e缓存是什么\u003c/h2\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/images/20180306_02.jpg\"\u003e\u003c/p\u003e\n\u003cp\u003e先看一张图，当我们访问网页，浏览器会给服务器发请求，服务器会经过一系列的运算，把页面返回给浏览器。\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/images/20180306_03.jpg\"\u003e\u003c/p\u003e\n\u003cp\u003e当有多个浏览器同时访问的时候，就会在短时间内发起多个请求，而服务器对每一个请求都要进行一系列相同的操作。重复工作不仅浪费资源，还可能导致响应速度变慢。\u003c/p\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/images/20180306_04.jpg\"\u003e\u003c/p\u003e\n\u003cp\u003e而缓存则可以把服务器返回的页面保存下来，当有其他的浏览器再访问时候，就不必劳服务器大驾，直接由缓存返回页面。为了保证响应速度，缓存通常是基于比较昂贵的硬件，比如 RAM，这就决定了我们很难用大量的缓存把所有的页面都存下来，当恰好没有缓存浏览器请求的页面时，依然需要请求服务器。由于缓存容量有限，而数据量无限（互联网每天新产生的页面数无法估计），就需要把好刚用在刀刃上，缓存那些最有用的信息。\u003c/p\u003e\n\u003ch2 id=\"lru-是什么\"\u003eLRU 是什么\u003c/h2\u003e\n\u003cp\u003eLRU 是一种缓存淘汰算法（在 OS 中也叫内存换页算法），由于缓存空间是有限的，所以要淘汰缓存中不常用的数据，留下常用的数据，达到缓存效率的最大化。LRU 就是这样一种决定“淘汰谁留下谁”的算法，LRU 是 Least recently used 的缩写，从字面意思“最近最少使用”，我们就可以理解 LRU 的淘汰规则。\u003c/p\u003e\n\u003ch2 id=\"lru-的淘汰逻辑\"\u003eLRU 的淘汰逻辑\u003c/h2\u003e\n\u003cp\u003e\u003cimg loading=\"lazy\" src=\"/images/20180306_05.png\"\u003e\u003c/p\u003e\n\u003cp\u003e我们用一张图来描述 LRU 的淘汰逻辑，图中的缓存是一个列表结构，上面是头结点下面是尾节点，缓存容量为 8（8 个小格子）：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e有新数据（意味着数据之前没有被缓存过）时，加入到列表头\u003c/li\u003e\n\u003cli\u003e缓存到达最大容量时，需要淘汰数据多出来的数据，此时淘汰列表尾部的数据\u003c/li\u003e\n\u003cli\u003e当缓存中有数据被命中，则将数据移动到列表头部（相当于新加入缓存）\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e按上面的逻辑我们可以看到，一个数据如果经常被访问就会不断地被移动到列表头部，不会被淘汰出缓存，而越不经常访问的数据，越容易被挤出缓存。\u003c/p\u003e\n\u003ch2 id=\"20-行-python-代码实践-lru\"\u003e20 行 Python 代码实践 LRU\u003c/h2\u003e\n\u003cp\u003e接下来我们用 Python 来实现一个采用 LRU 算法的缓存。\u003c/p\u003e\n\u003cp\u003e从前面的文章中我们可以知道，缓存简化下来就两个功能，一个是往里装数据（缓存数据），一个是往外吐数据（命中缓存），所以我们的缓存对外只需要 put 和 get 两个接口就可以了。\u003c/p\u003e\n\u003cp\u003e按照前面的示意图，缓存内部我们只需要有一个列表（list）就可以实现 LRU 逻辑，不过用列表虽然能实现逻辑，但是在判断是否命中缓存时，速度可能非常慢（列表需要遍历才能知道数据有没有在里面）。在 Python 中，我们可以用基于 hash 的结构，比如字典（dict）或集合（set），来快速判断数据是否存在，解决列表实现的性能问题。但是字典和集合又是没有顺序的，如果能有一种既能排序，又是基于 hash 存储的数据结构，就好了。\u003c/p\u003e\n\u003cp\u003e在 Python 的 collections 包中，已经内置了这种实用的结构 OrderedDict，OrderedDict 是 dict 的子类，但是存储在内部的元素是有序的（列表的特点）。\u003c/p\u003e","title":"面试不再怕，20行Python代码帮你搞懂LRU算法"}]