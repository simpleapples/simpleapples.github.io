<!DOCTYPE html>
<html lang="zh" dir="auto">
  <head>
    <script
      src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload"
      data-no-instant
      defer
    ></script>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, shrink-to-fit=no"
    />
    <meta name="robots" content="noindex, nofollow" />
    <title>简析Python中的四种队列 | simpleapples</title>
    <meta name="keywords" content="" />
    <meta
      name="description"
      content="队列是一种只允许在一端进行插入操作，而在另一端进行删除操作的线性表。
在Python文档中搜索队列（queue）会发现，Python标准库中包含了四种队列，分别是queue.Queue / asyncio.Queue / multiprocessing.Queue / collections.deque。
collections.deque
deque是双端队列（double-ended queue）的缩写，由于两端都能编辑，deque既可以用来实现栈（stack）也可以用来实现队列（queue）。
deque支持丰富的操作方法，主要方法如图：

相比于list实现的队列，deque实现拥有更低的时间和空间复杂度。list实现在出队（pop）和插入（insert）时的空间复杂度大约为O(n)，deque在出队（pop）和入队（append）时的时间复杂度是O(1)。
deque也支持in操作符，可以使用如下写法：
q = collections.deque([1, 2, 3, 4])
print(5 in q)  # False
print(1 in q)  # True
deque还封装了顺逆时针的旋转的方法：rotate。
# 顺时针
q = collections.deque([1, 2, 3, 4])
q.rotate(1)
print(q)  # [4, 1, 2, 3]
q.rotate(1)
print(q)  # [3, 4, 1, 2]

# 逆时针
q = collections.deque([1, 2, 3, 4])
q.rotate(-1)
print(q)  # [2, 3, 4, 1]
q.rotate(-1)
print(q)  # [3, 4, 1, 2]
线程安全方面，通过查看collections.deque中的append()、pop()等方法的源码可以知道，他们都是原子操作，所以是GIL保护下的线程安全方法。
static PyObject *
deque_append(dequeobject *deque, PyObject *item) { 
    Py_INCREF(item);
    if (deque_append_internal(deque, item, deque-&gt;maxlen) &lt; 0) 
        return NULL;
    Py_RETURN_NONE;
}
通过dis方法可以看到，append是原子操作（一行字节码）。"
    />
    <meta name="author" content="" />
    <link
      rel="canonical"
      href="http://localhost:1313/zh/four-types-of-queue-in-python/"
    />
    <link
      crossorigin="anonymous"
      href="/assets/css/stylesheet.8fe10233a706bc87f2e08b3cf97b8bd4c0a80f10675a143675d59212121037c0.css"
      integrity="sha256-j&#43;ECM6cGvIfy4Is8&#43;XuL1MCoDxBnWhQ2ddWSEhIQN8A="
      rel="preload stylesheet"
      as="style"
    />
    <link rel="icon" href="http://localhost:1313/favicon.ico" />
    <link
      rel="icon"
      type="image/png"
      sizes="16x16"
      href="http://localhost:1313/favicon-16x16.png"
    />
    <link
      rel="icon"
      type="image/png"
      sizes="32x32"
      href="http://localhost:1313/favicon-32x32.png"
    />
    <link
      rel="apple-touch-icon"
      href="http://localhost:1313/apple-touch-icon.png"
    />
    <link rel="mask-icon" href="http://localhost:1313/safari-pinned-tab.svg" />
    <meta name="theme-color" content="#2e2e33" />
    <meta name="msapplication-TileColor" content="#2e2e33" />
    <link
      rel="alternate"
      hreflang="zh"
      href="http://localhost:1313/zh/four-types-of-queue-in-python/"
    />
    <noscript>
      <style>
        #theme-toggle,
        .top-link {
          display: none;
        }
      </style>
      <style>
        @media (prefers-color-scheme: dark) {
          :root {
            --theme: rgb(29, 30, 32);
            --entry: rgb(46, 46, 51);
            --primary: rgb(218, 218, 219);
            --secondary: rgb(155, 156, 157);
            --tertiary: rgb(65, 66, 68);
            --content: rgb(196, 196, 197);
            --code-block-bg: rgb(46, 46, 51);
            --code-bg: rgb(55, 56, 62);
            --border: rgb(51, 51, 51);
          }

          .list {
            background: var(--theme);
          }

          .list:not(.dark)::-webkit-scrollbar-track {
            background: 0 0;
          }

          .list:not(.dark)::-webkit-scrollbar-thumb {
            border-color: var(--theme);
          }
        }
      </style>
    </noscript>
  </head>

  <body class="" id="top">
    <script>
      if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add("dark");
      } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove("dark");
      } else if (window.matchMedia("(prefers-color-scheme: dark)").matches) {
        document.body.classList.add("dark");
      }
    </script>

    <header class="header">
      <nav class="nav">
        <div class="logo">
          <a
            href="http://localhost:1313/zh/"
            accesskey="h"
            title="simpleapples (Alt + H)"
            >simpleapples</a
          >
          <div class="logo-switches">
            <button
              id="theme-toggle"
              accesskey="t"
              title="(Alt + T)"
              aria-label="Toggle theme"
            >
              <svg
                id="moon"
                xmlns="http://www.w3.org/2000/svg"
                width="24"
                height="18"
                viewBox="0 0 24 24"
                fill="none"
                stroke="currentColor"
                stroke-width="2"
                stroke-linecap="round"
                stroke-linejoin="round"
              >
                <path
                  d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"
                ></path>
              </svg>
              <svg
                id="sun"
                xmlns="http://www.w3.org/2000/svg"
                width="24"
                height="18"
                viewBox="0 0 24 24"
                fill="none"
                stroke="currentColor"
                stroke-width="2"
                stroke-linecap="round"
                stroke-linejoin="round"
              >
                <circle cx="12" cy="12" r="5"></circle>
                <line x1="12" y1="1" x2="12" y2="3"></line>
                <line x1="12" y1="21" x2="12" y2="23"></line>
                <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                <line x1="1" y1="12" x2="3" y2="12"></line>
                <line x1="21" y1="12" x2="23" y2="12"></line>
                <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
              </svg>
            </button>
            <ul class="lang-switch">
              <li>|</li>
              <li>
                <a
                  href="http://localhost:1313/"
                  title="English"
                  aria-label="English"
                  >En</a
                >
              </li>
            </ul>
          </div>
        </div>
        <ul id="menu">
          <li>
            <a href="http://localhost:1313/zh/about/" title="about">
              <span>about</span>
            </a>
          </li>
          <li>
            <a href="http://localhost:1313/zh/categories/" title="categories">
              <span>categories</span>
            </a>
          </li>
        </ul>
      </nav>
    </header>
    <main class="main">
      <article class="post-single">
        <header class="post-header">
          <h1 class="post-title entry-hint-parent">简析Python中的四种队列</h1>
          <div class="post-meta">
            <span title="2018-05-22 10:25:00 +0000 +0000">五月 22, 2018</span>
          </div>
        </header>
        <div class="post-content">
          <p>
            队列是一种只允许在一端进行插入操作，而在另一端进行删除操作的线性表。
          </p>
          <p>
            在Python文档中搜索队列（queue）会发现，Python标准库中包含了四种队列，分别是queue.Queue
            / asyncio.Queue / multiprocessing.Queue / collections.deque。
          </p>
          <h1 id="collectionsdeque">
            collections.deque<a
              hidden
              class="anchor"
              aria-hidden="true"
              href="#collectionsdeque"
              >#</a
            >
          </h1>
          <p>
            deque是双端队列（double-ended
            queue）的缩写，由于两端都能编辑，deque既可以用来实现栈（stack）也可以用来实现队列（queue）。
          </p>
          <p>deque支持丰富的操作方法，主要方法如图：</p>
          <p><img loading="lazy" src="/images/20180522_01.jpg" /></p>
          <p>
            相比于list实现的队列，deque实现拥有更低的时间和空间复杂度。list实现在出队（pop）和插入（insert）时的空间复杂度大约为O(n)，deque在出队（pop）和入队（append）时的时间复杂度是O(1)。
          </p>
          <p>deque也支持in操作符，可以使用如下写法：</p>
          <div class="highlight">
            <pre
              tabindex="0"
              style="
                color: #f8f8f2;
                background-color: #272822;
                -moz-tab-size: 4;
                -o-tab-size: 4;
                tab-size: 4;
              "
            ><code class="language-python" data-lang="python"><span style="display:flex;"><span>q <span style="color:#f92672">=</span> collections<span style="color:#f92672">.</span>deque([<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>])
</span></span><span style="display:flex;"><span>print(<span style="color:#ae81ff">5</span> <span style="color:#f92672">in</span> q)  <span style="color:#75715e"># False</span>
</span></span><span style="display:flex;"><span>print(<span style="color:#ae81ff">1</span> <span style="color:#f92672">in</span> q)  <span style="color:#75715e"># True</span>
</span></span></code></pre>
          </div>
          <p>deque还封装了顺逆时针的旋转的方法：rotate。</p>
          <div class="highlight">
            <pre
              tabindex="0"
              style="
                color: #f8f8f2;
                background-color: #272822;
                -moz-tab-size: 4;
                -o-tab-size: 4;
                tab-size: 4;
              "
            ><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e"># 顺时针</span>
</span></span><span style="display:flex;"><span>q <span style="color:#f92672">=</span> collections<span style="color:#f92672">.</span>deque([<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>])
</span></span><span style="display:flex;"><span>q<span style="color:#f92672">.</span>rotate(<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>print(q)  <span style="color:#75715e"># [4, 1, 2, 3]</span>
</span></span><span style="display:flex;"><span>q<span style="color:#f92672">.</span>rotate(<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>print(q)  <span style="color:#75715e"># [3, 4, 1, 2]</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 逆时针</span>
</span></span><span style="display:flex;"><span>q <span style="color:#f92672">=</span> collections<span style="color:#f92672">.</span>deque([<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>])
</span></span><span style="display:flex;"><span>q<span style="color:#f92672">.</span>rotate(<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>print(q)  <span style="color:#75715e"># [2, 3, 4, 1]</span>
</span></span><span style="display:flex;"><span>q<span style="color:#f92672">.</span>rotate(<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>print(q)  <span style="color:#75715e"># [3, 4, 1, 2]</span>
</span></span></code></pre>
          </div>
          <p>
            线程安全方面，通过查看collections.deque中的append()、pop()等方法的源码可以知道，他们都是原子操作，所以是GIL保护下的线程安全方法。
          </p>
          <div class="highlight">
            <pre
              tabindex="0"
              style="
                color: #f8f8f2;
                background-color: #272822;
                -moz-tab-size: 4;
                -o-tab-size: 4;
                tab-size: 4;
              "
            ><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> PyObject <span style="color:#f92672">*</span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">deque_append</span>(dequeobject <span style="color:#f92672">*</span>deque, PyObject <span style="color:#f92672">*</span>item) { 
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Py_INCREF</span>(item);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">deque_append_internal</span>(deque, item, deque<span style="color:#f92672">-&gt;</span>maxlen) <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>) 
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>    Py_RETURN_NONE;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre>
          </div>
          <p>通过dis方法可以看到，append是原子操作（一行字节码）。</p>
          <p><img loading="lazy" src="/images/20180522_02.png" /></p>
          <p>
             综上，collections.deque是一个可以方便实现队列的数据结构，具有线程安全的特性，并且有很高的性能。
          </p>
          <h1 id="queuequeue--asyncioqueue">
            queue.Queue &amp; asyncio.Queue<a
              hidden
              class="anchor"
              aria-hidden="true"
              href="#queuequeue--asyncioqueue"
              >#</a
            >
          </h1>
          <p>
            queue.Queue和asyncio.Queue都是支持多生产者、多消费者的队列，基于collections.deque，他们都提供了Queue（FIFO队列）、PriorityQueue（优先级队列）、LifoQueue（LIFO队列），接口方面也相同。
          </p>
          <p>
            区别在于queue.Queue适用于多线程的场景，asyncio.Queue适用于协程场景下的通信，由于asyncio的加成，queue.Queue下的阻塞接口在asyncio.Queue中则是以返回协程对象的方式执行，具体差异如下表：
          </p>
          <table>
            <thead>
              <tr>
                <th></th>
                <th>queue.Queue</th>
                <th>asyncio.Queue</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>介绍</td>
                <td>同步队列</td>
                <td>asyncio队列</td>
              </tr>
              <tr>
                <td>线程安全</td>
                <td>是</td>
                <td>否</td>
              </tr>
              <tr>
                <td>超时机制</td>
                <td>通过timeout参数实现</td>
                <td>通过asyncio.wait_for()方法实现</td>
              </tr>
              <tr>
                <td>qsize()</td>
                <td>
                  预估的队列长度（获取qsize到下一个操作之间，queue有可能被其它的线程修改，导致qsize大小发生变化）
                </td>
                <td>
                  准确的队列长度（由于是单线程，所以queue不会被其它线程修改）
                </td>
              </tr>
              <tr>
                <td>put() / set()</td>
                <td>
                  put(item, block=True,
                  timeout=None)，可以通过设置block是否为True来配置put和set方法是否为阻塞，并且可以为阻塞操作设置最大时长timeout，block为False时行为和put_nowait()方法一致。
                </td>
                <td>
                  put()方法会返回一个协程对象，所以没有block参数和timeout参数，如果需要非阻塞方法，可以使用put_nowait()，如果需要对阻塞方法应用超时，可以使用coroutine
                  asyncio.wait_for()。
                </td>
              </tr>
            </tbody>
          </table>
          <h1 id="multiprocessingqueue">
            multiprocessing.Queue<a
              hidden
              class="anchor"
              aria-hidden="true"
              href="#multiprocessingqueue"
              >#</a
            >
          </h1>
          <p>
            multiprocessing提供了三种队列，分别是Queue、SimpleQueue、JoinableQueue。
          </p>
          <p><img loading="lazy" src="/images/20180522_03.png" /></p>
          <p>
            multiprocessing.Queue既是线程安全也是进程安全的，相当于queue.Queue的多进程克隆版。和threading.Queue很像，multiprocessing.Queue支持put和get操作，底层结构是multiprocessing.Pipe。
          </p>
          <p>
            multiprocessing.Queue底层是基于Pipe构建的，但是数据传递时并不是直接写入Pipe，而是写入进程本地buffer，通过一个feeder线程写入底层Pipe，这样做是为了实现超时控制和非阻塞put/get，所以Queue提供了join_thread、cancel_join_thread、close函数来控制feeder的行为，close函数用来关闭feeder线程、join_thread用来join
            feeder线程，cancel_join_thread用来在控制在进程退出时，不自动join
            feeder线程，使用cancel_join_thread有可能导致部分数据没有被feeder写入Pipe而导致的数据丢失。
          </p>
          <p>
            和threading.Queue不同的是，multiprocessing.Queue默认不支持join()和task_done操作，这两个支持需要使用mp.JoinableQueue对象。
          </p>
          <p>
            SimpleQueue是一个简化的队列，去掉了Queue中的buffer，没有了使用Queue可能出现的问题，但是put和get方法都是阻塞的并且没有超时控制。
          </p>
          <h1 id="总结">
            总结<a hidden class="anchor" aria-hidden="true" href="#总结">#</a>
          </h1>
          <p>
            通过对比可以发现，上述四种结构都实现了队列，但是用处却各有偏重，collections.deque在数据结构层面实现了队列，但是并没有应用场景方面的支持，可以看做是一个基础的数据结构。queue模块实现了面向多生产线程、多消费线程的队列，asyncio.queue模块则实现了面向多生产协程、多消费协程的队列，而multiprocessing.queue模块实现了面向多成产进程、多消费进程的队列。
          </p>
          <h1 id="参考">
            参考<a hidden class="anchor" aria-hidden="true" href="#参考">#</a>
          </h1>
          <p>
            <a
              href="https://docs.python.org/3/library/collections.html#collections.deque"
              >https://docs.python.org/3/library/collections.html#collections.deque</a
            >
            <a
              href="https://docs.python.org/3/library/queue.html?highlight=queue#module-queue"
              >https://docs.python.org/3/library/queue.html</a
            >
            <a
              href="https://docs.python.org/3/library/asyncio-queue.html?highlight=queue"
              >https://docs.python.org/3/library/asyncio-queue.html</a
            >
            <a
              href="https://docs.python.org/3/library/multiprocessing.html#multiprocessing.Queue"
              >https://docs.python.org/3/library/multiprocessing.html#multiprocessing.Queue</a
            >
            <a href="https://bugs.python.org/issue15329"
              >https://bugs.python.org/issue15329</a
            >
            <a
              href="http://blog.ftofficer.com/2009/12/python-multiprocessing-3-about-queue/"
              >http://blog.ftofficer.com/2009/12/python-multiprocessing-3-about-queue/</a
            >
            <a
              href="http://cyrusin.github.io/2016/04/27/python-gil-implementaion/"
              >http://cyrusin.github.io/2016/04/27/python-gil-implementaion/</a
            >
          </p>
        </div>

        <footer class="post-footer">
          <ul class="post-tags"></ul>
        </footer>
      </article>
    </main>

    <footer class="footer">
      <span
        >&copy; 2025 <a href="http://localhost:1313/zh/">simpleapples</a></span
      >
      ·

      <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank"
          >Hugo</a
        >
        &
        <a
          href="https://github.com/adityatelange/hugo-PaperMod/"
          rel="noopener"
          target="_blank"
          >PaperMod</a
        >
      </span>
    </footer>
    <a
      href="#top"
      aria-label="go to top"
      title="Go to Top (Alt + G)"
      class="top-link"
      id="top-link"
      accesskey="g"
    >
      <svg
        xmlns="http://www.w3.org/2000/svg"
        viewBox="0 0 12 6"
        fill="currentColor"
      >
        <path d="M12 6H0l6-6z" />
      </svg>
    </a>

    <script>
      let menu = document.getElementById("menu");
      if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
          localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        };
      }

      document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
        anchor.addEventListener("click", function (e) {
          e.preventDefault();
          var id = this.getAttribute("href").substr(1);
          if (!window.matchMedia("(prefers-reduced-motion: reduce)").matches) {
            document
              .querySelector(`[id='${decodeURIComponent(id)}']`)
              .scrollIntoView({
                behavior: "smooth",
              });
          } else {
            document
              .querySelector(`[id='${decodeURIComponent(id)}']`)
              .scrollIntoView();
          }
          if (id === "top") {
            history.replaceState(null, null, " ");
          } else {
            history.pushState(null, null, `#${id}`);
          }
        });
      });
    </script>
    <script>
      var mybutton = document.getElementById("top-link");
      window.onscroll = function () {
        if (
          document.body.scrollTop > 800 ||
          document.documentElement.scrollTop > 800
        ) {
          mybutton.style.visibility = "visible";
          mybutton.style.opacity = "1";
        } else {
          mybutton.style.visibility = "hidden";
          mybutton.style.opacity = "0";
        }
      };
    </script>
    <script>
      document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
          document.body.classList.remove("dark");
          localStorage.setItem("pref-theme", "light");
        } else {
          document.body.classList.add("dark");
          localStorage.setItem("pref-theme", "dark");
        }
      });
    </script>
  </body>
</html>
