<!DOCTYPE html>
<html lang="zh" dir="auto">
  <head>
    <script
      src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload"
      data-no-instant
      defer
    ></script>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, shrink-to-fit=no"
    />
    <meta name="robots" content="noindex, nofollow" />
    <title>基于 JWT &#43; Refresh Token 的用户认证实践 | simpleapples</title>
    <meta name="keywords" content="" />
    <meta
      name="description"
      content="
HTTP 是一个无状态的协议，一次请求结束后，下次在发送服务器就不知道这个请求是谁发来的了（同一个 IP 不代表同一个用户），在 Web 应用中，用户的认证和鉴权是非常重要的一环，实践中有多种可用方案，并且各有千秋。
基于 Session 的会话管理
在 Web 应用发展的初期，大部分采用基于 Session 的会话管理方式，逻辑如下。

客户端使用用户名密码进行认证
服务端生成并存储 Session，将 SessionID 通过 Cookie 返回给客户端
客户端访问需要认证的接口时在 Cookie 中携带 SessionID
服务端通过 SessionID 查找 Session 并进行鉴权，返回给客户端需要的数据


基于 Session 的方式存在多种问题。

服务端需要存储 Session，并且由于 Session 需要经常快速查找，通常存储在内存或内存数据库中，同时在线用户较多时需要占用大量的服务器资源。
当需要扩展时，创建 Session 的服务器可能不是验证 Session 的服务器，所以还需要将所有 Session 单独存储并共享。
由于客户端使用 Cookie 存储 SessionID，在跨域场景下需要进行兼容性处理，同时这种方式也难以防范 CSRF 攻击。

基于 Token 的会话管理
鉴于基于 Session 的会话管理方式存在上述多个缺点，无状态的基于 Token 的会话管理方式诞生了，所谓无状态，就是服务端不再存储信息，甚至是不再存储 Session，逻辑如下。

客户端使用用户名密码进行认证
服务端验证用户名密码，通过后生成 Token 返回给客户端
客户端保存 Token，访问需要认证的接口时在 URL 参数或 HTTP Header 中加入 Token
服务端通过解码 Token 进行鉴权，返回给客户端需要的数据

"
    />
    <meta name="author" content="" />
    <link
      rel="canonical"
      href="http://localhost:1313/zh/combining-jwt-with-refresh-token/"
    />
    <link
      crossorigin="anonymous"
      href="/assets/css/stylesheet.8fe10233a706bc87f2e08b3cf97b8bd4c0a80f10675a143675d59212121037c0.css"
      integrity="sha256-j&#43;ECM6cGvIfy4Is8&#43;XuL1MCoDxBnWhQ2ddWSEhIQN8A="
      rel="preload stylesheet"
      as="style"
    />
    <link rel="icon" href="http://localhost:1313/favicon.ico" />
    <link
      rel="icon"
      type="image/png"
      sizes="16x16"
      href="http://localhost:1313/favicon-16x16.png"
    />
    <link
      rel="icon"
      type="image/png"
      sizes="32x32"
      href="http://localhost:1313/favicon-32x32.png"
    />
    <link
      rel="apple-touch-icon"
      href="http://localhost:1313/apple-touch-icon.png"
    />
    <link rel="mask-icon" href="http://localhost:1313/safari-pinned-tab.svg" />
    <meta name="theme-color" content="#2e2e33" />
    <meta name="msapplication-TileColor" content="#2e2e33" />
    <link
      rel="alternate"
      hreflang="zh"
      href="http://localhost:1313/zh/combining-jwt-with-refresh-token/"
    />
    <noscript>
      <style>
        #theme-toggle,
        .top-link {
          display: none;
        }
      </style>
      <style>
        @media (prefers-color-scheme: dark) {
          :root {
            --theme: rgb(29, 30, 32);
            --entry: rgb(46, 46, 51);
            --primary: rgb(218, 218, 219);
            --secondary: rgb(155, 156, 157);
            --tertiary: rgb(65, 66, 68);
            --content: rgb(196, 196, 197);
            --code-block-bg: rgb(46, 46, 51);
            --code-bg: rgb(55, 56, 62);
            --border: rgb(51, 51, 51);
          }

          .list {
            background: var(--theme);
          }

          .list:not(.dark)::-webkit-scrollbar-track {
            background: 0 0;
          }

          .list:not(.dark)::-webkit-scrollbar-thumb {
            border-color: var(--theme);
          }
        }
      </style>
    </noscript>
  </head>

  <body class="" id="top">
    <script>
      if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add("dark");
      } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove("dark");
      } else if (window.matchMedia("(prefers-color-scheme: dark)").matches) {
        document.body.classList.add("dark");
      }
    </script>

    <header class="header">
      <nav class="nav">
        <div class="logo">
          <a
            href="http://localhost:1313/zh/"
            accesskey="h"
            title="simpleapples (Alt + H)"
            >simpleapples</a
          >
          <div class="logo-switches">
            <button
              id="theme-toggle"
              accesskey="t"
              title="(Alt + T)"
              aria-label="Toggle theme"
            >
              <svg
                id="moon"
                xmlns="http://www.w3.org/2000/svg"
                width="24"
                height="18"
                viewBox="0 0 24 24"
                fill="none"
                stroke="currentColor"
                stroke-width="2"
                stroke-linecap="round"
                stroke-linejoin="round"
              >
                <path
                  d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"
                ></path>
              </svg>
              <svg
                id="sun"
                xmlns="http://www.w3.org/2000/svg"
                width="24"
                height="18"
                viewBox="0 0 24 24"
                fill="none"
                stroke="currentColor"
                stroke-width="2"
                stroke-linecap="round"
                stroke-linejoin="round"
              >
                <circle cx="12" cy="12" r="5"></circle>
                <line x1="12" y1="1" x2="12" y2="3"></line>
                <line x1="12" y1="21" x2="12" y2="23"></line>
                <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                <line x1="1" y1="12" x2="3" y2="12"></line>
                <line x1="21" y1="12" x2="23" y2="12"></line>
                <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
              </svg>
            </button>
            <ul class="lang-switch">
              <li>|</li>
              <li>
                <a
                  href="http://localhost:1313/"
                  title="English"
                  aria-label="English"
                  >En</a
                >
              </li>
            </ul>
          </div>
        </div>
        <ul id="menu">
          <li>
            <a href="http://localhost:1313/zh/about/" title="about">
              <span>about</span>
            </a>
          </li>
          <li>
            <a href="http://localhost:1313/zh/categories/" title="categories">
              <span>categories</span>
            </a>
          </li>
        </ul>
      </nav>
    </header>
    <main class="main">
      <article class="post-single">
        <header class="post-header">
          <h1 class="post-title entry-hint-parent">
            基于 JWT &#43; Refresh Token 的用户认证实践
          </h1>
          <div class="post-meta">
            <span title="2018-12-13 13:07:00 +0000 GMT">十二月 13, 2018</span>
          </div>
        </header>
        <div class="post-content">
          <p><img loading="lazy" src="/images/20181213_01.jpg" /></p>
          <p>
            HTTP
            是一个无状态的协议，一次请求结束后，下次在发送服务器就不知道这个请求是谁发来的了（同一个
            IP 不代表同一个用户），在 Web
            应用中，用户的认证和鉴权是非常重要的一环，实践中有多种可用方案，并且各有千秋。
          </p>
          <h3 id="基于-session-的会话管理">
            基于 Session 的会话管理<a
              hidden
              class="anchor"
              aria-hidden="true"
              href="#基于-session-的会话管理"
              >#</a
            >
          </h3>
          <p>
            在 Web 应用发展的初期，大部分采用基于 Session
            的会话管理方式，逻辑如下。
          </p>
          <ul>
            <li>客户端使用用户名密码进行认证</li>
            <li>
              服务端生成并存储 Session，将 SessionID 通过 Cookie 返回给客户端
            </li>
            <li>客户端访问需要认证的接口时在 Cookie 中携带 SessionID</li>
            <li>
              服务端通过 SessionID 查找 Session
              并进行鉴权，返回给客户端需要的数据
            </li>
          </ul>
          <p><img loading="lazy" src="/images/20181213_02.jpg" /></p>
          <p>基于 Session 的方式存在多种问题。</p>
          <ul>
            <li>
              服务端需要存储 Session，并且由于 Session
              需要经常快速查找，通常存储在内存或内存数据库中，同时在线用户较多时需要占用大量的服务器资源。
            </li>
            <li>
              当需要扩展时，创建 Session 的服务器可能不是验证 Session
              的服务器，所以还需要将所有 Session 单独存储并共享。
            </li>
            <li>
              由于客户端使用 Cookie 存储
              SessionID，在跨域场景下需要进行兼容性处理，同时这种方式也难以防范
              CSRF 攻击。
            </li>
          </ul>
          <h3 id="基于-token-的会话管理">
            基于 Token 的会话管理<a
              hidden
              class="anchor"
              aria-hidden="true"
              href="#基于-token-的会话管理"
              >#</a
            >
          </h3>
          <p>
            鉴于基于 Session 的会话管理方式存在上述多个缺点，无状态的基于 Token
            的会话管理方式诞生了，所谓无状态，就是服务端不再存储信息，甚至是不再存储
            Session，逻辑如下。
          </p>
          <ul>
            <li>客户端使用用户名密码进行认证</li>
            <li>服务端验证用户名密码，通过后生成 Token 返回给客户端</li>
            <li>
              客户端保存 Token，访问需要认证的接口时在 URL 参数或 HTTP Header
              中加入 Token
            </li>
            <li>服务端通过解码 Token 进行鉴权，返回给客户端需要的数据</li>
          </ul>
          <p><img loading="lazy" src="/images/20181213_03.jpg" /></p>
          <p>
            基于 Token 的会话管理方式有效解决了基于 Session
            的会话管理方式带来的问题。
          </p>
          <ul>
            <li>
              服务端不需要存储和用户鉴权有关的信息，鉴权信息会被加密到 Token
              中，服务端只需要读取 Token 中包含的鉴权信息即可
            </li>
            <li>避免了共享 Session 导致的不易扩展问题</li>
            <li>不需要依赖 Cookie，有效避免 Cookie 带来的 CSRF 攻击问题</li>
            <li>使用 CORS 可以快速解决跨域问题</li>
          </ul>
          <h3 id="jwt-介绍">
            JWT 介绍<a hidden class="anchor" aria-hidden="true" href="#jwt-介绍"
              >#</a
            >
          </h3>
          <p>
            JWT 是 JSON Web Token 的缩写，JWT
            本身没有定义任何技术实现，它只是定义了一种基于 Token
            的会话管理的规则，涵盖 Token 需要包含的标准内容和 Token 的生成过程。
          </p>
          <p>一个 JWT Token 长这样。</p>
          <pre
            tabindex="0"
          ><code>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE1NDQ1MTE3NDMsImp0aSI6IjYxYmVmNjkyLTE4M2ItNGYxYy1hZjE1LWUwMDM0MTczNzkxOSJ9.CZzB2-JI1oPRFxNMaoFz9-9cKGTYVXkOC2INMoEYNNA
</code></pre>
          <p>
            仔细辨别会发现它由
            <code>A.B.C</code>
            三部分组成，这三部分依次是头部（Header）、负载（Payload）、签名（Signature），头部和负载以
            JSON 形式存在，这就是 JWT 中的 JSON，三部分的内容都分别单独经过了
            Base64 编码，以 <code>.</code> 拼接成一个 JWT Token。
          </p>
          <p>JWT 的 Header 中存储了所使用的加密算法和 Token 类型。</p>
          <div class="highlight">
            <pre
              tabindex="0"
              style="
                color: #f8f8f2;
                background-color: #272822;
                -moz-tab-size: 4;
                -o-tab-size: 4;
                tab-size: 4;
              "
            ><code class="language-json" data-lang="json"><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">&#34;alg&#34;</span>: <span style="color:#e6db74">&#34;HS256&#34;</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">&#34;typ&#34;</span>: <span style="color:#e6db74">&#34;JWT&#34;</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre>
          </div>
          <p>
            Payload 是负载，JWT
            规范规定了一些字段，并推荐使用，开发者也可以自己指定字段和内容，例如下面的内容。
          </p>
          <div class="highlight">
            <pre
              tabindex="0"
              style="
                color: #f8f8f2;
                background-color: #272822;
                -moz-tab-size: 4;
                -o-tab-size: 4;
                tab-size: 4;
              "
            ><code class="language-json" data-lang="json"><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#960050;background-color:#1e0010">username:</span> <span style="color:#960050;background-color:#1e0010">&#39;yage&#39;,</span>
</span></span><span style="display:flex;"><span>  <span style="color:#960050;background-color:#1e0010">email:</span> <span style="color:#960050;background-color:#1e0010">&#39;sa@simpleapples.com&#39;,</span>
</span></span><span style="display:flex;"><span>  <span style="color:#960050;background-color:#1e0010">role:</span> <span style="color:#960050;background-color:#1e0010">&#39;user&#39;,</span>
</span></span><span style="display:flex;"><span>  <span style="color:#960050;background-color:#1e0010">exp:</span> <span style="color:#960050;background-color:#1e0010">1544602234</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre>
          </div>
          <p>
            需要注意的是，Payload的内容只经过了 Base64
            编码，对客户端来说当于明文存储，所以不要放置敏感信息。
          </p>
          <p>
            Signature 部分用来验证 JWT Token 是否被篡改，所以这部分会使用一个
            Secret 将前两部分加密，逻辑如下。
          </p>
          <pre
            tabindex="0"
          ><code>HMACSHA256(base64UrlEncode(header) + &#34;.&#34; + base64UrlEncode(payload), secret)
</code></pre>
          <h3 id="jwt-优势--问题">
            JWT 优势 &amp; 问题<a
              hidden
              class="anchor"
              aria-hidden="true"
              href="#jwt-优势--问题"
              >#</a
            >
          </h3>
          <p>
            JWT 拥有基于 Token 的会话管理方式所拥有的一切优势，不依赖
            Cookie，使得其可以防止 CSRF 攻击，也能在禁用 Cookie
            的浏览器环境中正常运行。
          </p>
          <p>
            而 JWT 的最大优势是服务端不再需要存储
            Session，使得服务端认证鉴权业务可以方便扩展，避免存储 Session
            所需要引入的 Redis 等组件，降低了系统架构复杂度。但这也是 JWT
            最大的劣势，由于有效期存储在 Token 中，JWT Token
            一旦签发，就会在有效期内一直可用，无法在服务端废止，当用户进行登出操作，只能依赖客户端删除掉本地存储的
            JWT Token，如果需要禁用用户，单纯使用 JWT 就无法做到了。
          </p>
          <h3 id="基于-jwt-的实践">
            基于 JWT 的实践<a
              hidden
              class="anchor"
              aria-hidden="true"
              href="#基于-jwt-的实践"
              >#</a
            >
          </h3>
          <p>
            既然 JWT
            依然存在诸多问题，甚至无法满足一些业务上的需求，但是我们依然可以基于
            JWT
            在实践中进行一些改进，来形成一个折中的方案，毕竟，在用户会话管理场景下，没有银弹。
          </p>
          <p>
            前面讲的 Token，都是 Access Token，也就是访问资源接口时所需要的
            Token，还有另外一种 Token，Refresh Token，通常情况下，Refresh Token
            的有效期会比较长，而 Access Token 的有效期比较短，当 Access Token
            由于过期而失效时，使用 Refresh Token 就可以获取到新的 Access
            Token，如果 Refresh Token 也失效了，用户就只能重新登录了。
          </p>
          <p>在 JWT 的实践中，引入 Refresh Token，将会话管理流程改进如下。</p>
          <ul>
            <li>客户端使用用户名密码进行认证</li>
            <li>
              服务端生成有效时间较短的 Access Token（例如 10
              分钟），和有效时间较长的 Refresh Token（例如 7 天）
            </li>
            <li>客户端访问需要认证的接口时，携带 Access Token</li>
            <li>
              如果 Access Token 没有过期，服务端鉴权后返回给客户端需要的数据
            </li>
            <li>
              如果携带 Access Token 访问需要认证的接口时鉴权失败（例如返回 401
              错误），则客户端使用 Refresh Token 向刷新接口申请新的 Access Token
            </li>
            <li>
              如果 Refresh Token 没有过期，服务端向客户端下发新的 Access Token
            </li>
            <li>客户端使用新的 Access Token 访问需要认证的接口</li>
          </ul>
          <p><img loading="lazy" src="/images/20181213_04.jpg" /></p>
          <p>
            将生成的 Refresh Token 以及过期时间存储在服务端的数据库中，由于
            Refresh Token 不会在客户端请求业务接口时验证，只有在申请新的 Access
            Token 时才会验证，所以将 Refresh Token
            存储在数据库中，不会对业务接口的响应时间造成影响，也不需要像 Session
            一样一直保持在内存中以应对大量的请求。
          </p>
          <p>
            上述的架构，提供了服务端禁用用户 Token
            的方式，当用户需要登出或禁用用户时，只需要将服务端的 Refresh Token
            禁用或删除，用户就会在 Access Token 过期后，由于无法获取到新的
            Access Token
            而再也无法访问需要认证的接口。这样的方式虽然会有一定的窗口期（取决于
            Access Token 的失效时间），但是结合用户登出时客户端删除 Access Token
            的操作，基本上可以适应常规情况下对用户认证鉴权的精度要求。
          </p>
          <h3 id="总结">
            总结<a hidden class="anchor" aria-hidden="true" href="#总结">#</a>
          </h3>
          <p>
            JWT
            的使用，提高了开发者开发用户认证鉴权功能的效率，降低了系统架构复杂度，避免了大量的数据库和缓存查询，降低了业务接口的响应延迟。然而
            JWT 的这些优点也增加了 Token 管理上的难度，通过引入 Refresh
            Token，既能继续使用 JWT 所带来的优势，又能使得 Token
            管理的精度符合业务的需求。
          </p>
        </div>

        <footer class="post-footer">
          <ul class="post-tags"></ul>
        </footer>
      </article>
    </main>

    <footer class="footer">
      <span
        >&copy; 2025 <a href="http://localhost:1313/zh/">simpleapples</a></span
      >
      ·

      <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank"
          >Hugo</a
        >
        &
        <a
          href="https://github.com/adityatelange/hugo-PaperMod/"
          rel="noopener"
          target="_blank"
          >PaperMod</a
        >
      </span>
    </footer>
    <a
      href="#top"
      aria-label="go to top"
      title="Go to Top (Alt + G)"
      class="top-link"
      id="top-link"
      accesskey="g"
    >
      <svg
        xmlns="http://www.w3.org/2000/svg"
        viewBox="0 0 12 6"
        fill="currentColor"
      >
        <path d="M12 6H0l6-6z" />
      </svg>
    </a>

    <script>
      let menu = document.getElementById("menu");
      if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
          localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        };
      }

      document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
        anchor.addEventListener("click", function (e) {
          e.preventDefault();
          var id = this.getAttribute("href").substr(1);
          if (!window.matchMedia("(prefers-reduced-motion: reduce)").matches) {
            document
              .querySelector(`[id='${decodeURIComponent(id)}']`)
              .scrollIntoView({
                behavior: "smooth",
              });
          } else {
            document
              .querySelector(`[id='${decodeURIComponent(id)}']`)
              .scrollIntoView();
          }
          if (id === "top") {
            history.replaceState(null, null, " ");
          } else {
            history.pushState(null, null, `#${id}`);
          }
        });
      });
    </script>
    <script>
      var mybutton = document.getElementById("top-link");
      window.onscroll = function () {
        if (
          document.body.scrollTop > 800 ||
          document.documentElement.scrollTop > 800
        ) {
          mybutton.style.visibility = "visible";
          mybutton.style.opacity = "1";
        } else {
          mybutton.style.visibility = "hidden";
          mybutton.style.opacity = "0";
        }
      };
    </script>
    <script>
      document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
          document.body.classList.remove("dark");
          localStorage.setItem("pref-theme", "light");
        } else {
          document.body.classList.add("dark");
          localStorage.setItem("pref-theme", "dark");
        }
      });
    </script>
  </body>
</html>
