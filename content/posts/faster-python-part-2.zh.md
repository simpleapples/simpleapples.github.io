---
date: "2018-10-25T18:20:00+00:00"
title: "翻译 | 更快的Python（二）"
categories:
  - Python
---

![](/images/20181025_11.png)

更快的 Python（[Python Faster Way](http://pythonfasterway.org)）使用代码示例来说明如何书写 Python 代码能带来更高的性能。本文对代码进行了讲解，从性能和可读性等角度来选择出最适合的写法。

<!-- more -->

### 例子 11：字符串连接

![](/images/20181025_01.png)

- 最差/最优时间比：**1.15**
- 使用建议：一次性连接多个（3 个以上）的字符串的时候，使用 join，其他情况使用加号或 f-string。
- 说明：又是一个字符串连接的问题，不过这个例子举的不好，join 适用的场景是一次连接多个字符串，会比加号连接多个字符串要快很多（加号相当于一个一个连接）。

### 例子 12：数字的格式化

![](/images/20181025_02.png)

- 最差/最优时间比：**1.29**
- 使用建议：需要复杂格式，推荐使用 format 方法；将数字转换为字符串，直接使用 str 方法。
- 说明：将数字转为字符串，使用 str 方法要快于 format 方法，因为 format 方法支持在转换过程中增加规则，例如将数字转为货币形式（每三位加一个逗号分隔符）。

### 例子 13：获取内置列表类型的长度

![](/images/20181025_03.png)

- 最差/最优时间比：**1.20**
- 使用建议：使用 len()方法。
- 说明：当调用 len()方法时，系统实际上是调用了对象内置的**len**方法，从这个层面理解，直接调用**len**应该比 len()方法更快。但是当 len()内置的列表方法时，Python 解释器做了优化，直接返回了列表对象中存储长度信息的变量，并不会调用**len**。

### 例子 14：整数类型的运算

![](/images/20181025_04.png)

- 最差/最优时间比：**2.63**
- 使用建议：不要直接调用**add**等魔术方法。
- 说明：对于整数类型，调用魔术方法完成运算的速度远远慢于直接使用运算符，使用运算符时，Python 解释器直接调用 C 实现的 operaotr 包中的运算方法，所以速度很快；而使用调用魔术方法，在 Python 层面多出了调用**add**等魔术方法的额外操作。

### 例子 15：自定义类型的运算符重载

![](/images/20181025_05.png)

- 最差/最优时间比：**1.06**
- 使用建议：不要直接调用**add**等魔术方法。
- 说明：对于重载了运算符的对象，没有对应的 C 实现运算方法，所以直接直接调用魔术方法速度会更快。

### 例子 16：对 range 结果求和

![](/images/20181025_06.png)

- 最差/最优时间比：**2.95**
- 使用建议：推荐使用第一种。
- 说明：和第一种相比，第三种会遍历 range 先生成一个列表，然后将列表传给 sum，速度最慢，而第一种直接传递迭代器给 sum，省去了遍历生成列表的过程；第二种和第一种相比则是在 Python 层面实现了求和，而 sum 是 C 层面实现的求和，所以也没有第一种块。

### 例子 17：for 循环和表达式构建列表的区别

![](/images/20181025_07.png)

- 最差/最优时间比：**2.05**
- 使用建议：推荐使用表达式构建。
- 说明：两种方式看上去逻辑一样，都是把 range 迭代器遍历，生成一个列表，但是表达式是在字节码层面构建了一个循环来生成，而第二种则是在 Python 层面创建列表，并不断 Append，性能上要差于第一种。

### 例子 18：for 循环和表达式构建字典的区别

![](/images/20181025_08.png)

- 最差/最优时间比：**1.49**
- 使用建议：推荐使用表达式。
- 说明：dict 的 update 方法适用于合并两个字典的情况，也就是说可以一次合并多个 key，所以相比于直接访问 key 速度要慢；根据图中的测试，在 100 这个量级上，表达式生成的速度要慢一些，但是在更大的量级上，表达式的优势就体现出来了，并且更加 Pythonic。首先表达式方法是在字节码层面生成循环的，所以理论上比 Python 层面生成循环构建字典要快的，那么为什么在小量级的场景下，字节码反倒没有优势呢？根据 dis 出的字节码可以看到，表达式构建首先会 MAKE_FUNCTION 然后再 CALL_FUNCTION，这里会有一些基本的消耗，量级小的时候，这些基本消耗占比高，量级越大，这些基本消耗所占比例就越低，表达式方法的优势也就越明显。

### 例子 19：for 循环和表达式构建字典的区别

![](/images/20181025_09.png)

- 最差/最优时间比：**2.89**
- 使用建议：推荐使用表达式构建。
- 说明：理由同上一个例子。

### 例子 20：转换为 bool 值

![](/images/20181025_10.png)

- 最差/最优时间比：**N/A**
- 使用建议：根据具体情况选择。
- 说明：这个比较似乎没有什么好说的，时间的区别主要原因是构建 a 对象的成本不同。

### 参考文章

- [Python Faster Way](http://pythonfasterway.org)
